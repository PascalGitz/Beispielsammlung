[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Beispielsammlung",
    "section": "",
    "text": "Vorwort\nDie folgenden Beispiele umfassen die wesentlichen Aspekte der im Rahmen der Vorlesung Baudynamik vorgestellten Theorie. Anhand von numerischen Beispielen werden die Grundlagen der Baudynamik vertieft behandelt.\nTo-Dos\n\nBilder mit CAD zeichnen\nSymbole müssen mit Skizzen und Berechnungen übereinstimmen.\nBestimmung Steifigkeitsmatrix Gleichgewicht der “alleinstehenden Federkraft”\nGeneralisierte Grössen Höhe des EMS.\nÜberlagerung der Ersatzkräfte klären\n\nVorzeichen Torsion\n\nEKV mein System ist viel zu steif\nEKV-Rayleigh Nachgiebigkeitsmatrix Überlagerung der Biegemomente"
  },
  {
    "objectID": "rayleigh_01.html#aufgabenstellung",
    "href": "rayleigh_01.html#aufgabenstellung",
    "title": "1  Beispiel: Kragarm mit 2 Punktmassen",
    "section": "1.1 Aufgabenstellung",
    "text": "1.1 Aufgabenstellung\nDas in Abbildung 1.1 dargestellte System stellt einen Kragarm mit verteilter Masse und 2 Punktmassen dar. Eine mögliche Formfunktion ist rechts daneben gezeigt.\n\n\n\nAbbildung 1.1: Kragarm mit verteilter Masse und zwei Punktmassen\n\n\nGesucht:\n\nGrundfrequenz (1. Eigenfrequenz \\(\\omega_n\\)) des Systems, berechnet mit dem Rayleigh-Quotienten.\n\nGegeben:\n\nRandbedingungen für den Spezialfall: \\(m_{const} = 0 \\text{ und } m_1 = m_2 = m\\)\nFormfunktion: \\[ \\Psi(x) = 1 - \\cos(\\frac{\\pi x}{2L})\\]"
  },
  {
    "objectID": "rayleigh_01.html#sec-ml_2punktmassen",
    "href": "rayleigh_01.html#sec-ml_2punktmassen",
    "title": "1  Beispiel: Kragarm mit 2 Punktmassen",
    "section": "1.2 Musterlösung",
    "text": "1.2 Musterlösung\n\n1.2.1 Grundfrequenz\nMithilfe der in der Vorlesung hergeleiteten Bewegungsgleichung kann anhand der Formfunktion \\(\\Psi\\) die erste Eigenkreisfrequenz ermittelt werden. Der Rayleigh-Quotient ist eine Energiebetrachtung. Er setzt die potenzielle, maximale Energie \\(E_{pot,max}\\) zur kinetischen, maximalen Energie \\(E_{kin,max}\\) ins Verhältnis. Daraus lässt sich die Kreisfrequenz \\(\\omega_n\\) herauslösen.\n\\[\nu'' \\int_0^L m\\Psi^2 dx + u \\int_0^L (EI(\\Psi'')^2)dx = f(x,t)\n\\tag{1.1}\\]\nDurch Substitution resultiert die bekannte Bewegungsgleichung:\n\\[\nm^\\star u'' + k^\\star u  = f(x,t)\n\\text{ mit } k^\\star = \\int_0^L (EI(\\Psi'')^2)dx\n\\text{ und } m^\\star = \\int_0^L m\\Psi^2dx\n\\tag{1.2}\\]\nAus der Bewegungsgleichung kann die Eigenkreisfrequenz ermittelt werden:\n\\[\n\\omega_1 = \\sqrt{\\frac{k^\\star}{m^\\star}}\n\\tag{1.3}\\]\n\nfrom sympy.abc import *\n\nL = sp.symbols('L', positive=True)\n\n\n1.2.1.1 Berechnung der Masse\nDie Masse in Gleichung 1.3 kann mittels der Lösung des Integrals in Gleichung 1.2 bestimmt werden. Dabei sind die Punktmassen mittels der entsprechenden Deformation an den Stellen \\(L\\) und \\(\\frac{L}{2}\\) zu berücksichtigen, sowie die verteilte Masse über die gesamte Länge.\n\nm_1, m_2 = sp.symbols('m_1, m_2')\n\n\nPsi_x = 1 - sp.cos(sp.pi*x/(2*L))\nm_star = sp.integrate(m*Psi_x**2, (x,0,L)) + Psi_x.subs(x,L/2)**2*m_1 + Psi_x.subs(x,L)**2*m_2\n\nrender.eq_display(sp.Symbol('m^\\star'), \"Integral(m*Psi**2, (x,0,L))+Symbol('\\Psi(x=L/2)')**2*m_1 + Symbol('\\Psi(x=L)')**2*m_2\",\n                  sp.Symbol('\\Psi(x)^2'), Psi_x**2,\n                  sp.Symbol('m^\\star'), m_star)\n\n\\[\\begin{equation}m^{\\star} = \\Psi(x=L)^{2} m_{2} + \\Psi(x=L/2)^{2} m_{1} + \\int\\limits_{0}^{L} \\Psi^{2} m\\, dx\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi(x)^{2} = \\left(1 - \\cos{\\left(\\frac{\\pi x}{2 L} \\right)}\\right)^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}m^{\\star} = m \\left(- \\frac{4 L}{\\pi} + \\frac{3 L}{2}\\right) + m_{1} \\left(1 - \\frac{\\sqrt{2}}{2}\\right)^{2} + m_{2}\\end{equation}\\]\n\n\n\n\n1.2.1.2 Berechnung der Steifigkeit\nDie Steifigkeit in Gleichung 1.3 kann mittels der Lösung des Integrals in Gleichung 1.2 bestimmt werden. Zur Ermittlung der Steifigkeit \\(k^\\star\\) muss zuerst der Ansatz zweimal nach \\(x\\) abgeleitet werden.\n\nPsi_x_diff_1 = sp.diff(Psi_x, x)\nPsi_x_diff_2 = sp.diff(Psi_x, x,x)\n\n\nrender.eq_display('Psi(x)', Psi_x,\n                  'Derivative(Psi(x),x)', Psi_x_diff_1,\n                  'Derivative(Psi(x),x,x)', Psi_x_diff_2,)\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = 1 - \\cos{\\left(\\frac{\\pi x}{2 L} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d}{d x} \\Psi{\\left(x \\right)} = \\frac{\\pi \\sin{\\left(\\frac{\\pi x}{2 L} \\right)}}{2 L}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d x^{2}} \\Psi{\\left(x \\right)} = \\frac{\\pi^{2} \\cos{\\left(\\frac{\\pi x}{2 L} \\right)}}{4 L^{2}}\\end{equation}\\]\n\n\nDurch das Einsetzen der zweiten Ableitung in den Anteil für \\(k^\\star\\) aus Gleichung 1.2 resultiert die Steifigkeit zu:\n\\[\nk^\\star = (\\frac{\\pi}{2L})^4 \\int_0^L(EI(\\cos(\\frac{\\pi x}{2L})^2)) dx\n\\tag{1.4}\\]\nDurch die Lösung des Integrals folgt:\n\nk_star = sp.integrate(E*I*Psi_x_diff_2**2,(x,0,L))\n\nrender.eq_display(sp.Symbol('k^\\star'), k_star)\n\n\\[\\begin{equation}k^{\\star} = \\frac{\\pi^{4} E I}{32 L^{3}}\\end{equation}\\]\n\n\n\n\n1.2.1.3 Berechnung der Grundfrequenz\nDurch das Einsetzen der berechneten Werte resultiert die Eigenkreisfrequenz in Gleichung 1.3 zu:\n\nomega_1 = sp.sqrt(k_star / m_star, evaluate=False)\n\nrender.eq_display('omega_1', omega_1)\n\n\\[\\begin{equation}\\omega_{1} = \\sqrt{\\frac{\\pi^{4} E I}{32 L^{3} \\left(m \\left(- \\frac{4 L}{\\pi} + \\frac{3 L}{2}\\right) + m_{1} \\left(1 - \\frac{\\sqrt{2}}{2}\\right)^{2} + m_{2}\\right)}}\\end{equation}\\]\n\n\n\n\n1.2.1.4 Auswertung des Spezialfalls\nMit Hilfe der Randbedingungen für den Spezialfall aus der Aufgabenstellung resultiert die Grundfrequenz zu:\n\nrender.eq_display('omega_1', omega_1.subs([[m_1, M],[m_2,M],[m,0]],evaluate=False),\n                  'omega_1', omega_1.subs(([[m_1, M],[m_2,M],[m,0]])).evalf(3).subs((E*I/M)**0.5, sp.sqrt((E*I/M))).subs(L**(-1.5), sp.sqrt(L**-3,evaluate=False)))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{\\sqrt{2} \\pi^{2} \\sqrt{\\frac{E I}{M \\left(1 - \\frac{\\sqrt{2}}{2}\\right)^{2} + M}}}{8 L^{\\frac{3}{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{1.67 \\sqrt{\\frac{E I}{M}}}{L^{\\frac{3}{2}}}\\end{equation}\\]\n\n\nDie exakte erste Eigenfrequenz eines Zweimassenschwingers mit konstanter Steifigkeit und gleichen Massen, mit entsprechenden Randbedingungen gemäss der Aufgabenstellung, ist:\n\\[\n\\omega_1 \\simeq \\sqrt{\\frac{3.007\\frac{EI}{L^3}}{1.102 M}} = 1.652 \\sqrt{\\frac{EI}{ML^3}} = \\frac{1.652 \\sqrt{\\frac{E I}{M}}}{L^{\\frac{3}{2}}}\n\\tag{1.5}\\]\nDie Berechnung mit Hilfe des Rayleigh-Quotienten stellt also eine (sehr) gute Abschätzung der ersten Eigenfrequenz dar."
  },
  {
    "objectID": "rayleigh_02.html#aufgabenstellung",
    "href": "rayleigh_02.html#aufgabenstellung",
    "title": "2  Beispiel: Kragarm mit 1 Punktmasse",
    "section": "2.1 Aufgabenstellung",
    "text": "2.1 Aufgabenstellung\nDas in Abbildung 2.1 dargestellte System stellt einen Kragarm mit verteilter Masse und einer Punktmasse dar. Eine mögliche Formfunktion ist rechts daneben gezeigt.\n\n\n\nAbbildung 2.1: Kragarm mit verteilter Masse und einer Punktmasse\n\n\nGesucht:\n\nGrundfrequenz (1. Eigenfrequenz \\(\\omega_n\\)) des Systems in Abbildung 2.1, berechnet mit dem Rayleigh-Quotienten.\n\nGegeben:\n\nAusgewertet für den Spezialfall: \\(m_{const} = 0 \\text{ und } m = m\\)\nFormfunktion: \\[ \\Psi(x) = 1 - \\cos(\\frac{\\pi x}{2L})\\]"
  },
  {
    "objectID": "rayleigh_02.html#musterlösung",
    "href": "rayleigh_02.html#musterlösung",
    "title": "2  Beispiel: Kragarm mit 1 Punktmasse",
    "section": "2.2 Musterlösung",
    "text": "2.2 Musterlösung\nDas Vorgehen entspricht dem Vorgehen in Kapitel 1.2.\n\n2.2.1 Grundfrequenz\n\nfrom sympy.abc import *\n\nL = sp.symbols('L', positive=True)\nm_const = sp.symbols('m_const')\n\n\n2.2.1.1 Berechnung der Masse\nDie Masse in Gleichung 1.3 kann mittels der Lösung des Integrals in Gleichung 1.2 bestimmt werden. Dabei ist die Punktmasse mittels der entsprechenden Deformation an der Stelle \\(L\\) zu berücksichtigen, sowie die verteilte Masse über die gesamte Länge.\n\nPsi_x = 1 - sp.cos(sp.pi*x/(2*L))\nm_star = sp.integrate(m_const*Psi_x**2, (x,0,L)) + Psi_x.subs(x,L)**2*m\n\nrender.eq_display(sp.Symbol('m^\\star'), \"Integral(m_const*Psi**2, (x,0,L)) + Symbol('\\Psi(x=L)')**2*m\",\n                  sp.Symbol('\\Psi(x)^2'), Psi_x**2,\n                  sp.Symbol('m^\\star'), m_star)\n\n\\[\\begin{equation}m^{\\star} = \\Psi(x=L)^{2} m + \\int\\limits_{0}^{L} \\Psi^{2} m_{const}\\, dx\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi(x)^{2} = \\left(1 - \\cos{\\left(\\frac{\\pi x}{2 L} \\right)}\\right)^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}m^{\\star} = m + m_{const} \\left(- \\frac{4 L}{\\pi} + \\frac{3 L}{2}\\right)\\end{equation}\\]\n\n\n\n\n2.2.1.2 Berechnung der Steifigkeit\nDie Steifigkeit in Gleichung 1.3 kann mittels der Lösung des Integrals in Gleichung 1.2 bestimmt werden. Zur Ermittlung der Steifigkeit \\(k^\\star\\) muss zuerst der Ansatz zweimal nach \\(x\\) abgeleitet werden.\n\nPsi_x_diff_1 = sp.diff(Psi_x, x)\nPsi_x_diff_2 = sp.diff(Psi_x, x,x)\n\n\nrender.eq_display('Psi(x)', Psi_x,\n                  'Derivative(Psi(x),x)', Psi_x_diff_1,\n                  'Derivative(Psi(x),x,x)', Psi_x_diff_2,)\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = 1 - \\cos{\\left(\\frac{\\pi x}{2 L} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d}{d x} \\Psi{\\left(x \\right)} = \\frac{\\pi \\sin{\\left(\\frac{\\pi x}{2 L} \\right)}}{2 L}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d x^{2}} \\Psi{\\left(x \\right)} = \\frac{\\pi^{2} \\cos{\\left(\\frac{\\pi x}{2 L} \\right)}}{4 L^{2}}\\end{equation}\\]\n\n\nDurch das Einsetzen der zweiten Ableitung in den Anteil für \\(k^\\star\\) aus Gleichung 1.2 resultiert die Steifigkeit zu:\n\\[\nk^\\star = (\\frac{\\pi}{2L})^4 \\int_0^L(EI(\\cos(\\frac{\\pi x}{2L})^2)) dx\n\\tag{2.1}\\]\nDurch die Lösung des Integrals folgt:\n\nk_star = sp.integrate(E*I*Psi_x_diff_2**2,(x,0,L))\n\nrender.eq_display(sp.Symbol('k^\\star'), k_star)\n\n\\[\\begin{equation}k^{\\star} = \\frac{\\pi^{4} E I}{32 L^{3}}\\end{equation}\\]\n\n\n\n\n2.2.1.3 Berechnung der Grundfrequenz\nDurch das Einsetzen der berechneten Werte resultiert die Eigenkreisfrequenz in Gleichung 1.3 zu:\n\nomega_1 = sp.sqrt(k_star / m_star, evaluate=False)\n\nrender.eq_display('omega_1', omega_1)\n\n\\[\\begin{equation}\\omega_{1} = \\sqrt{\\frac{\\pi^{4} E I}{32 L^{3} \\left(m + m_{const} \\left(- \\frac{4 L}{\\pi} + \\frac{3 L}{2}\\right)\\right)}}\\end{equation}\\]\n\n\n\n\n2.2.1.4 Auswertung des Spezialfalls\nMit Hilfe der Randbedingungen für den Spezialfall aus der Aufgabenstellung resultiert die Grundfrequenz zu:\n\nrender.eq_display('omega_1', omega_1.subs([[m_const,0]],evaluate=False),\n                  'omega_1', omega_1.subs(([[m_const,0]])).evalf(3).subs((E*I/m)**0.5, sp.sqrt((E*I/m))).subs(L**(-1.5), sp.sqrt(L**-3,evaluate=False)))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{\\sqrt{2} \\pi^{2} \\sqrt{\\frac{E I}{m}}}{8 L^{\\frac{3}{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{1.74 \\sqrt{\\frac{E I}{m}}}{L^{\\frac{3}{2}}}\\end{equation}\\]"
  },
  {
    "objectID": "rayleigh_03.html#aufgabenstellung",
    "href": "rayleigh_03.html#aufgabenstellung",
    "title": "3  Beispiel: Einfacher Balken mit konstanter Masse",
    "section": "3.1 Aufgabenstellung",
    "text": "3.1 Aufgabenstellung\nDas System in Abbildung 3.1 zeigt einen einfachen Balken mit einer konstanten Streckenlast belastet.\n\n\n\nAbbildung 3.1: Statisches System des einfachen Balkens\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega_1\\) mit Hilfe der analytischen Formfunktion Gleichung 3.1 \\[\n\\Psi(x) = \\sin{\\frac{\\pi x}{L}}\n\\tag{3.1}\\]\nEigenkreisfrequenz \\(\\omega_1\\) mit Hilfe der Biegelinie\n\nGegeben:\n\nLänge des Balkens \\(L\\)\nVerteilte Masse ist konstant \\(m_{const}\\)\nExakte Lösung der Eigenkreisfrequenz gemäss Gleichung 3.2\n\n\\[\n\\omega_1 = \\pi^2 \\cdot \\sqrt{\\frac{E\\cdot I}{m_{const}\\cdot L^4}}\n\\tag{3.2}\\]"
  },
  {
    "objectID": "rayleigh_03.html#musterlösung",
    "href": "rayleigh_03.html#musterlösung",
    "title": "3  Beispiel: Einfacher Balken mit konstanter Masse",
    "section": "3.2 Musterlösung",
    "text": "3.2 Musterlösung\n\n3.2.1 Analytische Formfunktion\nAls Formfunktion wird eine Sinus-Funktion gewählt. Dabei ist sicherzustellen, dass die Formfunktion normiert ist. Das heisst, der maximale Wert der Funktion ist \\(1\\). Dazu sind die kinematischen Randbedingungen einzuhalten. Entsprechend des Systems in Abbildung 3.1 muss die Verformung bei den Lagern null sein. Die gewählte Formfunktion bedingt keine weitere Anpassung zur Normierung.\n\nx,L = sp.symbols('x L', positive=True)\n\nPsi_x = sp.sin(sp.pi*x/L)\n\nrender.eq_display('Psi(x)',Psi_x)\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = \\sin{\\left(\\frac{\\pi x}{L} \\right)}\\end{equation}\\]\n\n\n\nplot_frei = sp.plot(Psi_x.subs(L,1),(x,0,1),size=(5.9,2))\n\n\n\n\nAbbildung 3.2: Frei gewählte Formfunktion\n\n\n\n\n\n3.2.1.1 Rayleigh - Quotient\nDer Rayleigh-Quotient ist eine Energiebetrachtung. Er setzt die potenzielle, maximale Energie \\(E_{pot,max}\\) zur kinetischen, maximalen Energie \\(E_{kin,max}\\) ins Verhältnis. Daraus lässt sich die Kreisfrequenz \\(\\omega_n\\) herauslösen. Die Lösung der Integrale wird hier mit einer Mathematik-Software durchgeführt. Die einzelnen Teilschritte werden nicht aufgeführt. \\[\nE_{pot,max} = E_{kin,max}\n\\tag{3.3}\\]\n\\[\n\\omega_1^2 = \\frac{\\int_0^L EI[u''(x)]^2 dx}{\\int_0^L m_{const.}[u(x)]^2 dx}\n\\tag{3.4}\\]\nDies lässt sich mit entsprechender Formfunktion schreiben:\n\\[\n\\omega_1^2 = \\frac{\\int_0^L EI[\\Psi''(x)]^2 dx}{\\int_0^L m_{const.}[\\Psi(x)]^2 dx}\n\\tag{3.5}\\]\nDurch die Ermittlung der zweiten Ableitung der Formfunktion:\n\nPsi_x_diff_1 = sp.diff(Psi_x, x)\nPsi_x_diff_2 = sp.diff(Psi_x, x,x)\n\n\nrender.eq_display('Psi(x)', Psi_x,\n                  'Derivative(Psi(x),x)', Psi_x_diff_1,\n                  'Derivative(Psi(x),x,x)', Psi_x_diff_2,)\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = \\sin{\\left(\\frac{\\pi x}{L} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d}{d x} \\Psi{\\left(x \\right)} = \\frac{\\pi \\cos{\\left(\\frac{\\pi x}{L} \\right)}}{L}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d x^{2}} \\Psi{\\left(x \\right)} = - \\frac{\\pi^{2} \\sin{\\left(\\frac{\\pi x}{L} \\right)}}{L^{2}}\\end{equation}\\]\n\n\nDiese eingesetzt in die Gleichung 3.5:\n\nE, I, m_const = sp.symbols('E I m_const',real=True)\nomega_1 = sp.sqrt(sp.integrate(E*I*sp.diff(Psi_x,x,2)**2, (x,0,L)) /sp.integrate(m_const*Psi_x**2, (x,0,L)) )\n\n\nrender.eq_display('omega_1', omega_1.doit())\n\n\\[\\begin{equation}\\omega_{1} = \\frac{\\pi^{2} \\sqrt{\\frac{E I}{m_{const}}}}{L^{2}}\\end{equation}\\]\n\n\nDies entspricht der exakten Lösung Gleichung 3.2! Grund dafür ist, dass die gewählte Formfunktion mit der dynamischen Deformation übereinstimmt.\n\n\n\n3.2.2 Formfunktion aus Biegelinie\nDie Biegelinie für das System in Abbildung 3.1 ist folgend beschrieben. Beachte dabei, dass die Deformation nach “unten” positiv definiert ist. Die Funktion kann aus Hilfswerken entnommen werden.\n\na, b,F = sp.symbols('a b F')\n\nb = L/2\na = b\n\n\nzeta = x/L\nbeta = b/L\nalpha = a/L\n\nw_x_biegelinie_1 = (F*L**3 / 6 *(beta * zeta*(-zeta**2-beta**2+1)))/(E*I)\nw_x_biegelinie_2 = sp.simplify((F*L**3 / 6 *(beta * zeta*(-zeta**2-beta**2+1)+(zeta-alpha)**3)))/(E*I)\n\nw_x_biegelinie = sp.Piecewise((w_x_biegelinie_1,x&lt;=a), (w_x_biegelinie_2,x&gt;a))\nrender.eq_display('w(x)', w_x_biegelinie)\n\n\n\\[\\begin{equation}w{\\left(x \\right)} = \\begin{cases} \\frac{F L^{2} x \\left(\\frac{3}{4} - \\frac{x^{2}}{L^{2}}\\right)}{12 E I} & \\text{for}\\: x \\leq \\frac{L}{2} \\\\\\frac{F \\left(x \\left(3 L^{2} - 4 x^{2}\\right) - \\left(L - 2 x\\right)^{3}\\right)}{48 E I} & \\text{otherwise} \\end{cases}\\end{equation}\\]\n\n\n\nplot_biege = sp.plot(w_x_biegelinie.subs([(L,1),(F,1),(E,1),(I,1)]), (x,0,1),size=(5.9,2))\n\n\n\n\nAbbildung 3.3: Formfunktion aus Biegelinie abgeleitet\n\n\n\n\n\n3.2.2.1 Normierung\nEs ist ersichtlich, dass die Formfunktion noch eine Normierung benötigt. Dazu wird der Maximalwert zu \\(1\\) gesetzt. Die Randbedingungen sind bereits erfüllt.\n\nw_x_biegelinie_norm = w_x_biegelinie * w_x_biegelinie.subs(x,L/2)**-1\n\nrender.eq_display('w_norm(x)', w_x_biegelinie_norm)\n\n\\[\\begin{equation}w_{norm}{\\left(x \\right)} = \\frac{48 E I \\left(\\begin{cases} \\frac{F L^{2} x \\left(\\frac{3}{4} - \\frac{x^{2}}{L^{2}}\\right)}{12 E I} & \\text{for}\\: x \\leq \\frac{L}{2} \\\\\\frac{F \\left(x \\left(3 L^{2} - 4 x^{2}\\right) - \\left(L - 2 x\\right)^{3}\\right)}{48 E I} & \\text{otherwise} \\end{cases}\\right)}{F L^{3}}\\end{equation}\\]\n\n\n\nplot_norm_biege = sp.plot(w_x_biegelinie_norm.subs([(L,1),(F,1),(E,1),(I,1)]), (x,0,1),size=(5.9,2))\n\n\n\n\nAbbildung 3.4: Normierte Formfunktion aus Biegelinie abgeleitet\n\n\n\n\n\n\n3.2.2.2 Rayleigh - Quotient\nDurch das Einsetzen der bestimmten Formfunktion aus der Biegelinie in Gleichung 3.5 kann die Eigenkreisfrequenz ermittelt werden.\n\nomega_1_biege = sp.sqrt(sp.integrate(E*I*sp.diff(w_x_biegelinie_norm,x,2)**2, (x,0,L)) /sp.integrate(m_const*w_x_biegelinie_norm**2, (x,0,L)) )\n\n\nrender.eq_display('omega_1_biege', omega_1_biege.evalf(3))\n\n\\[\\begin{equation}\\omega_{1 biege} = \\frac{9.94 \\left(\\frac{E I}{m_{const}}\\right)^{0.5}}{L^{2}}\\end{equation}\\]\n\n\n\n\n\n3.2.3 Vergleich beider Lösungen\nEin Vergleich der Eigenkreisfrequenz aus der Biegeform mit der exakten Lösung aus Gleichung 3.2 zeigt eine minimale Abweichung.\n\n\nrender.eq_display(sp.Symbol('\\\\text{Abweichung}'), ((omega_1_biege / omega_1-1)*100).evalf(2)*unit.percent)\n\n\\[\\begin{equation}\\text{Abweichung} = 0.72 \\%\\end{equation}\\]\n\n\n\nplot_vergleich = sp.plot(w_x_biegelinie_norm.subs([(L,1),(F,1),(E,1),(I,1)]),Psi_x.subs(L,1), (x,0,1),size=(5.9,2))\n\n\n\n\nAbbildung 3.5: Überlagerung beider Funktionen\n\n\n\n\nUm die minimale Abweichung offensichtlicher darzustellen ist in Abbildung 3.6 ein Teilbereich dargestellt.\n\nplot_vergleich = sp.plot(w_x_biegelinie_norm.subs([(L,1),(F,1),(E,1),(I,1)]),Psi_x.subs(L,1), (x,0,0.01),size=(5.9,2))\n\n\n\n\nAbbildung 3.6: Ausschnitt der Überlagerung beider Funktionen"
  },
  {
    "objectID": "ems_01.html#aufgabenstellung",
    "href": "ems_01.html#aufgabenstellung",
    "title": "4  Beispiel: Logarithmisches Dekrement",
    "section": "4.1 Aufgabenstellung",
    "text": "4.1 Aufgabenstellung\nDas in Abbildung 4.1 dargestellte System zeigt ein Rahmentragwerk. Dieses kann als Einmassenschwinger modelliert werden, welcher eine gedämpfte freie Schwingung erfährt.\n\n\n\nAbbildung 4.1: Am Riegel ausgelenktes System\n\n\nUm die Systemeigenschaften des Rahmens zu untersuchen, wird eine Kopfverschiebung bzw. Auslenkung des Rahmens von \\(u_0 = 20\\text{ mm}\\) aufgebracht. Danach wird die Halterung schlagartig gelöst und der Rahmen kann frei schwingen. Die angebrachte Messeinrichtung registriert eine max. Kopfverschiebung nach dem ersten Zurückschwingen von \\(u_1 = 15\\text{ mm}\\) nach \\(T_D = 0.2 \\text{s}\\).\nGesucht:\n\nLaterale bzw. horizontale Steifigkeit \\(k\\) des Rahmens\nDie Dämpfungsrate \\(\\zeta\\) und die Dämpfungskonstante \\(c\\)\nDie Amplitude der Auslenkung des Rahmens nach 10 Schwingzyklen\n\nGegeben:\n\nEA_riegel, EI_riegel,EA_stuetze, EI_stuetze, k, m, u, c, T_D, zeta, H, u_0, u_1 = sp.symbols('EA_riegel, EI_riegel,EA_stuetze, EI_stuetze, k, m, u, c,T_D, zeta H u_0 u_1')\n\n\nparams = {EA_riegel:sp.oo,\n          EI_riegel:sp.oo,\n          EA_stuetze:sp.oo,\n          m:1941*unit.N*unit.second**2/unit.m,\n          u_0:20*unit.mm,\n          u_1:15*unit.mm,\n          T_D:0.2*unit.second}\n\nrender.dict_to_table(params)\n\n\n\nTabelle 4.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(EA_{riegel} = \\infty\\)\n\\(EA_{stuetze} = \\infty\\)\n\n\n\\(EI_{riegel} = \\infty\\)\n\\(T_{D} = 0.2 \\text{s}\\)\n\n\n\\(m = \\frac{1941 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(u_{0} = 20 \\text{mm}\\)\n\n\n\\(u_{1} = 15 \\text{mm}\\)"
  },
  {
    "objectID": "ems_01.html#sec-ml_log_dek",
    "href": "ems_01.html#sec-ml_log_dek",
    "title": "4  Beispiel: Logarithmisches Dekrement",
    "section": "4.2 Musterlösung",
    "text": "4.2 Musterlösung\n\n4.2.1 Horizontale Steifigkeit\n\n4.2.1.1 Logarithmisches Dekrement\nDa keine Angaben über die Profile der Stützen gemacht werden, kann mittels des logarithmischen Dekrements die Eigenkreisfrequenz bestimmt werden. Anhand der Eigenkreisfrequenz lässt sich die Steifigkeit ableiten.\n\ndef plot_log_dek():\n\n    parameter_1 = {'omega_n':10,\n                'zeta':0.05,\n                'u0':20,\n                'v0':1}\n\n\n    ##Lösung der Gesamtantwort\n    t, zeta, omega_n, u0, v0, A1, A2 = sp.symbols('t  zeta, omega_n, u0, v0, A1, A2')\n    x = sp.Function('x')(t)\n    randbedingungen = {sp.diff(x,t).subs(t,0):v0,\n                    x.subs(t,0):u0}\n    DGL_gedaempft = sp.diff(x,t,2) + 2 *zeta*omega_n*sp.diff(x,t)+omega_n**2*x\n    x_solution = sp.dsolve(DGL_gedaempft, x, ics=randbedingungen)\n    gesamtantwort = sp.lambdify(t,x_solution.subs(parameter_1).rhs,'numpy')\n\n    t_array = np.linspace(0,10,1000)\n\n    ## Plots\n    fig = plt.figure(figsize=(5.9, 2.5))\n\n\n    plt.plot(t_array, gesamtantwort(t_array), label='Gesamtantwort')\n    plt.grid()\n    plt.xlabel('Zeit [s]')\n    plt.ylabel('Verschiebung')\n    plt.xlim(0,10)\n    # plt.yticks(y_range)\n    # plt.xticks(y_range)\n    plt.legend(loc='upper right')\n\n    # MASSLINIE\n\n    start = 1.2\n    end = 1.95\n    ht = 15\n    plt.annotate(\"\", xy=(start, ht), xytext=(end, ht),  arrowprops=dict(arrowstyle='&lt;-&gt;'))\n    plt.annotate(\"\", xy=(start, ht), xytext=(end, ht),  arrowprops=dict(arrowstyle='|-|'))\n    bbox=dict(fc=\"white\", ec=\"none\")\n    plt.text((start +end)/2, ht+3, \"$T_d$\", ha=\"center\", va=\"center\", bbox=bbox)\n\n\n    # Punktbeschriftung\n    plt.annotate('$u_0$',xy=(start, 11), xytext=(start+0.2, 11-2), color='red')\n    plt.annotate('$u_1$',xy=(end, 11), xytext=(end+0.1, 11-4), color='blue')\n\n\n\n    plt.show()\n\nplot_log_dek()\n\nC:\\Users\\Pascal Gitz\\miniconda3\\envs\\calcs\\lib\\site-packages\\matplotlib\\cbook\\__init__.py:1340: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n\n\n\n\n\nAbbildung 4.2: Beispiel eines logarithmischen Dekrements\n\n\n\n\n\ndelta = sp.ln(u_0 / u_1)\nzeta = delta/ (2*sp.pi)\nrender.eq_display('delta', delta,\n                  'delta', delta.subs(params).evalf(3))\n\n\\[\\begin{equation}\\delta = \\log{\\left(\\frac{u_{0}}{u_{1}} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta = 0.288\\end{equation}\\]\n\n\n\n\n4.2.1.2 Dämpfungsrate\nAnhand des logarithmischen Dekrements kann die Dämpfungsrate bestimmt werden.\n\ndef plot_daempfungsrate():\n    uN, N , T_d, zeta= sp.symbols('uN N T_d zeta')\n    naherung_dekrement = 2*sp.pi * zeta\n    dekrement_genau = 2*sp.pi*zeta / (sp.sqrt(1-zeta**2))\n    dekrement_genau_lamb = sp.lambdify(zeta, dekrement_genau)\n    naherung_dekrement_lamb = sp.lambdify(zeta, naherung_dekrement)\n    zeta_array = np.linspace(0,1,1000)\n\n\n    fig = plt.figure(figsize=(5.9, 2.5))\n\n\n\n    plt.plot(zeta_array, dekrement_genau_lamb(zeta_array), label='Exakte Gleichung')\n    plt.plot(zeta_array, naherung_dekrement_lamb(zeta_array), color='red',label='Näherung', linestyle='dashed')\n    plt.grid()\n\n    plt.xlabel('Dämpfungsrate $\\zeta$')\n    plt.ylabel('Logarithmisches Dekrement $\\delta$')\n    plt.xlim(0,1)\n    plt.ylim(0,10)\n    # plt.yticks(y_range)\n    # plt.xticks(y_range)\n    plt.legend(loc='upper left')\n\n    plt.show()\nplot_daempfungsrate()\n\n&lt;lambdifygenerated-2&gt;:2: RuntimeWarning: divide by zero encountered in divide\n  return 2*pi*zeta/sqrt(1 - zeta**2)\n\n\n\n\n\nAbbildung 4.3: Dämpfungsrate anhand des logarithmischen Dekrements\n\n\n\n\nFür kleine Dämpfungsraten kann folgende Gleichung verwendet werden:\n\\[\n\\zeta \\simeq \\frac{\\delta}{2\\pi}\n\\tag{4.1}\\]\nDie exakte Lösung bestimmt sich folgender massen:\n\nzeta = delta / (sp.sqrt(4*sp.pi**2 + delta**2))\n\nrender.eq_display('zeta_', 'delta/(sqrt(4*pi**2+delta**2))',\n                  'zeta_', zeta,\n                  'zeta_', zeta.subs(params).evalf(3))\n\n\\[\\begin{equation}\\zeta_{} = \\frac{\\delta}{\\sqrt{\\delta^{2} + 4 \\pi^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\zeta_{} = \\frac{\\log{\\left(\\frac{u_{0}}{u_{1}} \\right)}}{\\sqrt{\\log{\\left(\\frac{u_{0}}{u_{1}} \\right)}^{2} + 4 \\pi^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\zeta_{} = 0.0457\\end{equation}\\]\n\n\n\n\n4.2.1.3 Eigenkreisfrequenz\nAus der Aufgabenstellung ist die gedämpfte Periode von \\(T_D = 0.2 s\\) bekannt. Anhand dieser lässt sich die gedämpfte Eigenkreisfrequenz \\(\\omega_D\\) bestimmen und unter Berücksichtigung der Dämpfungsrate \\(\\zeta\\) kann die Eigenkreisfrequenz \\(\\omega_n\\) bestimmt werden.\n\nomega_D = (2*sp.pi)/ T_D\n\nomega_n = omega_D / (sp.sqrt(1-zeta**2))\nrender.eq_display('omega_D', omega_D,\n                  'omega_D', omega_D.subs(params).evalf(4),\n                  'omega_n', \"omega_D / (sqrt(1-zeta_**2))\",\n                  'omega_n', omega_n.subs(params).evalf(4))\n\n\\[\\begin{equation}\\omega_{D} = \\frac{2 \\pi}{T_{D}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{D} = \\frac{31.42}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{\\omega_{D}}{\\sqrt{1 - \\zeta_{}^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{31.45}{\\text{s}}\\end{equation}\\]\n\n\n\n\n4.2.1.4 Steifigkeit\nWir kennen die Beziehung zwischen Eigenkreisfrequenz und Steifigkeit:\n\\[\n\\omega_n = \\sqrt{\\frac{k}{m}}\n\\tag{4.2}\\]\n\nk = m*omega_n**2\n\nrender.eq_display('k','m*omega_n**2',\n                  'k',k.subs(params).evalf(3))\n\n\\[\\begin{equation}k = m \\omega_{n}^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}k = \\frac{1.92 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n\n4.2.2 Dämpfungskonstante\nAnhand der Dämpfungsrate \\(\\zeta\\) lässt sich leicht die Dämpfungskonstante bestimmen:\n\\[\n\\zeta = \\frac{c}{2\\omega_nm}\n\\tag{4.3}\\]\n\nc = zeta * 2*omega_n*m\nrender.eq_display('c',c.subs(params).evalf(3))\n\n\\[\\begin{equation}c = \\frac{5.58 \\cdot 10^{3} \\text{N} \\text{s}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n4.2.3 Amplitude nach 10 Schwingzyklen\nDas Verhalten der Amplitude ist in Abbildung 4.2 dargestellt.\n\\[\n\\delta = \\ln({\\frac{u_0}{u_1}})\n\\tag{4.4}\\]\n\\(\\delta\\) ist ein konstanter Wert und kann auf 10 Zyklen erweitert werden.\n\neq = sp.Eq(sp.Symbol('delta'), sp.ln(u_0/u_1))\n\nu_10 = u_0 * sp.exp(-10*delta)\nrender.eq_display('u_1', sp.solve(eq, u_1)[0],\n                  'u_10', 'u_0*exp(-10*delta)',\n                  'u_10', u_10.subs(params).evalf(4))\n\n\\[\\begin{equation}u_{1} = u_{0} e^{- \\delta}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{10} = u_{0} e^{- 10 \\delta}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{10} = 1.126 \\text{mm}\\end{equation}\\]"
  },
  {
    "objectID": "ems_02.html#aufgabenstellung",
    "href": "ems_02.html#aufgabenstellung",
    "title": "5  Beispiel: Impulssatz",
    "section": "5.1 Aufgabenstellung",
    "text": "5.1 Aufgabenstellung\nAbbildung 5.1 zeigt das System eines Stahlrahmens. Dieser wird durch eine kurzzeitig einwirkende Stossbelastung \\(F(t)\\) in Höhe des Rahmenriegels beansprucht.\n\n\n\nAbbildung 5.1: System des Stahlrahmens mit kurzzeitig einwirkender Stossbelastung\n\n\nGesucht:\n\nDer Maximalwert der zu erwartenden Riegelauslenkung (näherungsweise)\nDarstellung des zeitlichen Verlaufs \\(u(t)\\) in einem Diagramm\nNachweis der Elastizität des Systems anhand der Rückstellkraft (Spannungsnachweis mit Fliessspannung \\(f_y\\) als Grenze)\n\nGegeben:\n\nLastfunktion gemäss Abbildung 5.2\n\n\nEA_riegel, EI_riegel,EA_stuetze, EI_stuetze,  m_tot,  H, f_y, t, F_max, t_1, t_2,W_el_y = sp.symbols('EA_riegel, EI_riegel,EA_stuetze, EI_stuetze,  m_tot, H, f_y, t, F_max, t_1, t_2 W_el_y')\n\nA_1, A_2,u_0, v_0 = sp.symbols('A_1:3 u_0 v_0')\n\nu = sp.Function('u')(t)\n\n\nparams_not_relevant = {\n    EA_riegel:sp.oo,\n    EI_riegel:sp.oo,\n    EA_stuetze:sp.oo,\n}\n\n# render.dict_render(params_not_relevant)\n\n\nparams = {              \n          EI_stuetze:23646000.0*unit.N*unit.m**2,\n          m_tot:5000.0*unit.N*unit.second**2/unit.m,\n          W_el_y:938.0*10**3*unit.mm**3,\n          H:3000.0*unit.mm,\n          F_max:1000.0*10**3*unit.N,\n          t_1:0.003*unit.second,\n          t_2:0.006*unit.second,\n          f_y:355.0*unit.N/unit.mm**2,\n          u_0:0.0\n          }\n\nparams_plot = convert.param_value(params)\n\n\nparams_tot = params.copy()\nparams_tot.update(params_not_relevant)\n\n\n\nrender.dict_to_table(params_tot)\n\n\n\nTabelle 5.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(EA_{riegel} = \\infty\\)\n\\(EA_{stuetze} = \\infty\\)\n\n\n\\(EI_{riegel} = \\infty\\)\n\\(EI_{stuetze} = 23646000.0 \\text{m}^{2} \\text{N}\\)\n\n\n\\(F_{max} = 1000000.0 \\text{N}\\)\n\\(H = 3000.0 \\text{mm}\\)\n\n\n\\(W_{el y} = 938000.0 \\text{mm}^{3}\\)\n\\(f_{y} = \\frac{355.0 \\text{N}}{\\text{mm}^{2}}\\)\n\n\n\\(m_{tot} = \\frac{5000.0 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(t_{1} = 0.003 \\text{s}\\)\n\n\n\\(t_{2} = 0.006 \\text{s}\\)\n\\(u_{0} = 0.0\\)\n\n\n\n\n\n\n\nF_1 = t*F_max / t_1 \nF_2 =  F_1.subs(t,t_1)-((t-t_1)*F_max / t_1)\nF_t = sp.Piecewise((F_1,t&lt;t_1), (F_2,t&lt;=t_2), (0, t&gt;t_2))\np_last = sp.plot(F_t.subs(params_plot), (t,0,0.008), size=(5.9,2))\n\n\n\n\n\nAbbildung 5.2: Lastfunktion der kurzzeitig einwirkenden Stossbelastung"
  },
  {
    "objectID": "ems_02.html#musterlösung",
    "href": "ems_02.html#musterlösung",
    "title": "5  Beispiel: Impulssatz",
    "section": "5.2 Musterlösung",
    "text": "5.2 Musterlösung\n\n5.2.1 Horizontale Steifigkeit\nFür entsprechende Anwendungsfälle gibt es fertige Lösungen zur Bestimmung der Steifigkeit. Gemäss Abbildung 5.1 ist die Stütze am Fuss- und Kopfpunkt eingespannt (Änderungen der Lagerung beeinflussen die Steifigkeit!). Somit resultiert die Steifigkeit zu:\n\\[\nk_{Stuetze} = \\frac{12EI_{Stuetze}}{H^3}\n\\tag{5.1}\\]\nDiese gilt für eine einzelne Stütze. Angewendet auf das Beispiel folgt die Systemsteifigkeit zu:\n\nk = 2 * 12 * EI_stuetze / H**3\n\nrender.eq_display('k_', k,\n                  'k_', k.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}k_{} = \\frac{24 EI_{stuetze}}{H^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{} = \\frac{2.1 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n5.2.2 Eigenkreisfrequenz\n\nomega_n = sp.sqrt(k/m_tot)\n\nrender.eq_display('omega_n', 'sqrt(k/m)',\n                  'omega_n', omega_n,\n                  'omega_n', omega_n.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{n} = \\sqrt{\\frac{k}{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = 2 \\sqrt{6} \\sqrt{\\frac{EI_{stuetze}}{H^{3} m_{tot}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{64.8}{\\text{s}}\\end{equation}\\]\n\n\n\n\n5.2.3 Bewegungsgleichung\nDie Bewegungsgleichung für einen ungedämpften Einmassenschwinger ist die folgende:\n\\[\nm u(t)'' + k u(t) = F(t)\n\\tag{5.2}\\]\n\n5.2.3.1 Approximation der Lösung\nEs handelt sich um eine inhomogene Differentialgleichung 2.Ordnung. Auf die exakte Lösung der Gleichung wird nicht eingegangen. Es wird versucht die bemessungsrelevanten Parameter näherungsweise zu bestimmen. Dies lässt sich mit dem Impulssatz approximieren.\n\\[\nF \\Delta t = m \\Delta v\n\\tag{5.3}\\]\nDieser besagt, dass die einwirkende Kraft \\(F\\) im betrachteten Zeitabschnitt \\(\\Delta t\\) der Masse \\(m\\) multipliziert mit der Geschwindigkeitsänderung \\(\\Delta v\\) des Objekts entspricht. Für eine kurze Anregung, wie im Beispiel der Fall ist, kann die Anfangsgeschwindigkeit wie folgt bestimmt werden:\n\\[\nv_0 = \\frac{I}{m}\n\\tag{5.4}\\]\n\\[\nI = \\int_{0}^{t_2} F(t) \\,dt\n\\tag{5.5}\\]\n\nI = sp.integrate(F_t.subs(params), (t,0,t_2.subs(params)))\nv_0 = I / m_tot\n\n## Die Anfangsgeschwindigkeit wird zum Params dict hinzugefügt\nparams['v_0'] = v_0.subs(params)\nparams_plot = convert.param_value(params)\n\n\nrender.eq_display('I_', I,\n                  'v_0', v_0,\n                  'v_0', v_0.subs(params))\n\n\\[\\begin{equation}I_{} = 3000.0 \\text{N} \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}v_{0} = \\frac{3000.0 \\text{N} \\text{s}}{m_{tot}}\\end{equation}\\]\n\n\n\\[\\begin{equation}v_{0} = \\frac{0.6 \\text{m}}{\\text{s}}\\end{equation}\\]\n\n\nDurch die Impuls-Betrachtung vereinfacht sich die Bewegungsgleichung zu:\n\\[\nm u(t)'' + k u(t) = 0\n\\tag{5.6}\\]\nMit der Anfangsgeschwindigkeit als Randbedingung.\n\\[\nu'(t=0) = v_0  \n\\tag{5.7}\\]\nund der Startauslenkung:\n\\[\nu(t=0) = u_0 = 0\n\\tag{5.8}\\]\nKann mittels der folgenden Ansatzfunktion die homogene Differentialgleichung gelöst werden:\n\\[\nu(t) = A_1 \\cos(\\omega_n t) + A_2 \\sin(\\omega_n t)\n\\tag{5.9}\\]\n\n\nbewegungsgleichung = m_tot*sp.diff(u,t,2) + k*u\nansatzfunktion = sp.Eq(u,A_1 * sp.cos(omega_n*t) + A_2*sp.sin(omega_n*t))\neq_randbedingung_1 = sp.Eq(u_0,ansatzfunktion.rhs.subs(t,0))\neq_randbedingung_2 = sp.Eq(v_0, sp.diff(ansatzfunktion.rhs,t).subs(t,0))\nA_solve = sp.solve([eq_randbedingung_1, eq_randbedingung_2],[A_1, A_2],dict=True)[0]\n\n\nu_t = ansatzfunktion.subs(A_solve)\nrender.eq_display('u(t)',u_t.rhs.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u{\\left(t \\right)} = 0.00925 \\sin{\\left(\\frac{16.7406358567675 \\sqrt{15} t}{\\text{s}} \\right)} \\text{m}\\end{equation}\\]\n\n\n\nu_t_plot = u_t.subs(params_plot).rhs/unit.N/unit.second\nplot_beweg=sp.plot(u_t_plot, (t,0,0.15), ylabel='u(t) [m]',xlabel='t [s]',size=(5.9,2))\n\n\n\n\n\nAbbildung 5.3: Zeitlicher Verlauf der Auslenkung\n\n\n\n\n\n\n\n5.2.4 Rückstellkraft\nAnhand der maximalen Amplitude lässt sich die maximale Rückstellkraft für den gesamten Rahmen bestimmen.\n\\[\nF_R = k   u = k   A\n\\tag{5.10}\\]\n\nt_max = sp.solve(sp.Eq(sp.diff(u_t.rhs,t),0),t)\nu_max = u_t.subs(t, t_max[0].subs(params_plot)*unit.second).subs(params).rhs\n\nF_R = k * u_max\n\nrender.eq_display('u_max', 'A',\n                  'A', u_max.simplify().evalf(3),\n                  'F_R', F_R.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{max} = A\\end{equation}\\]\n\n\n\\[\\begin{equation}A = 0.00925 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}F_{R} = 1.94 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\n5.2.4.1 Spannungsnachweis\nDie Rückstellkraft wirkt im Zentrum der Masse und bewirkt das maximale Biegemoment bei den Fusspunkten.\n\n\n\nBiegemomentenverlauf durch die statische Ersatzkraft\n\n\n\nM_max = F_R/2 * H * sp.Rational(0.5)\n\nsigma_max = M_max /W_el_y\n\nrender.eq_display('M_max', 'F_R /2 * H * Rational(0.5)',\n                  'M_max', M_max.subs(params).simplify().evalf(3),\n                  'sigma_max', 'M_max / W_el_y',\n                  'sigma_max', unit.convert_to(sigma_max.subs(params).simplify().evalf(3), unit.mm),\n                  sp.Symbol('\\\\text{Nachweis}'), unit.convert_to(sigma_max.subs(params).simplify().evalf(3), unit.mm)&lt;f_y,\n                  sp.Symbol('\\\\text{Nachweis}'), unit.convert_to(sigma_max.subs(params).simplify().evalf(3), unit.mm)&lt;f_y.subs(params))\n\n\\[\\begin{equation}M_{max} = \\frac{F_{R} H}{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}M_{max} = 1.46 \\cdot 10^{5} \\text{m} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\sigma_{max} = \\frac{M_{max}}{W_{el y}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\sigma_{max} = \\frac{156.0 \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\text{Nachweis} = \\frac{156.0 \\text{N}}{\\text{mm}^{2}} &lt; f_{y}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\text{Nachweis} = \\text{True}\\end{equation}\\]"
  },
  {
    "objectID": "ems_03.html#aufgabenstellung",
    "href": "ems_03.html#aufgabenstellung",
    "title": "6  Beispiel: Dynamischer Vergrösserungsfaktor",
    "section": "6.1 Aufgabenstellung",
    "text": "6.1 Aufgabenstellung\nDas System in Abbildung 6.1 zeigt einen Biegeträger, gelagert als einfacher Balken mit einer Auskragung. Dieser wird am Kragarm mit der dynamischen Last F(t) in vertikaler Richtung beansprucht.\n\n\n\nAbbildung 6.1: Statisches System des Biegeträgers\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega\\)\nDynamischer Vergrösserungsfaktor \\(V(\\omega)\\)\nMaximale dynamische Amplitude im stationären Fall \\(u_{max}\\)\n\nGegeben:\n\nBiegeträger ist masselos\nEs sind lediglich Biegeverformungen zu betrachten \\(G \\cdot A = \\infty\\) \\[\nF(t) = F_0 \\cdot \\cos(\\omega \\cdot t) = 50 \\text{kN} \\cdot \\cos(62.8 \\cdot t)\n\\tag{6.1}\\]\n\n\nF_0, m, zeta, EI, l_1, l_2 = sp.symbols('F_0, m_, zeta, EI, l_1, l_2 ')\n\nk, omega, t  = sp.symbols('k omega t')\n\n\nparams = {F_0:50*10**3*unit.N,\n          m:1000*unit.N*unit.second**2/unit.m,\n          zeta:0.005,\n          EI:30000*10**3*unit.N*unit.m**2,\n          l_1:3000*unit.mm,\n          l_2:2000*unit.mm,\n          omega:62.8/unit.second}\n\nparams_plot = convert.param_value(params)\n\nrender.dict_to_table(params)\n\n\n\nTabelle 6.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(EI = 30000000 \\text{m}^{2} \\text{N}\\)\n\\(F_{0} = 50000 \\text{N}\\)\n\n\n\\(l_{1} = 3000 \\text{mm}\\)\n\\(l_{2} = 2000 \\text{mm}\\)\n\n\n\\(m_{} = \\frac{1000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(\\omega = \\frac{62.8}{\\text{s}}\\)\n\n\n\\(\\zeta = 0.005\\)"
  },
  {
    "objectID": "ems_03.html#musterlösung",
    "href": "ems_03.html#musterlösung",
    "title": "6  Beispiel: Dynamischer Vergrösserungsfaktor",
    "section": "6.2 Musterlösung",
    "text": "6.2 Musterlösung\n\nF_t = F_0*sp.cos(omega*t)\n\n# render.eq_display('F(t)', F_t,\n                #   'F(t)', F_t.subs(params))\n\n\n6.2.1 Eigenkreisfrequenz\nDie Eigenkreisfrequenz lässt sich aus der folgenden Gleichung bestimmen:\n\\[\n\\omega_n = \\sqrt{\\frac{k}{m}}\n\\tag{6.2}\\]\n\n6.2.1.1 Steifigkeit des Systems\nDie Steifigkeit des Systems lässt sich anhand der statischen Deformation bestimmen. Sie entspricht dem Verhältnis zwischen Einwirkung und der daraus resultierenden Verformung.\n\\[\nk = \\frac{F}{u}\n\\tag{6.3}\\]\nHändisch lässt sich die Deformation mittels realem und virtuellem Kräftezustand, anhand der Arbeitsgleichung bestimmen. Dargestellt in Abbildung 6.2. Die Ermittlung der Steifigkeit bedingt lediglich das Verhältnis zwischen Einwirkung und Deformation, folglich darf Betrag der realen Kraft frei gewählt werden.\n\n\n\nAbbildung 6.2: Realer und virtueller Kräftezustand\n\n\nUm lediglich Biegeverformungen zu berücksichtigen, kann die Verformung nachfolgender Gleichung bestimmt werden.\n\\[\nu = \\frac{1}{E I_y} \\cdot \\int_{0}^{l_1+l_2} M_y\\bar{M_y} \\,dx\n\\tag{6.4}\\]\n\nu_steifigkeit = 1/EI * (sp.Rational(1,3) * -2000*unit.N*unit.m * -2*unit.m * (l_1+l_2))\nk = 1000*unit.N / u_steifigkeit\n\n\nrender.eq_display('u', u_steifigkeit,\n                  'u', u_steifigkeit.subs(params).evalf(3),\n                  'k', k,\n                  'k', k.subs(params))\n\n\\[\\begin{equation}u = \\frac{4000 \\left(l_{1} + l_{2}\\right) \\text{m}^{2} \\text{N}}{3 EI}\\end{equation}\\]\n\n\n\\[\\begin{equation}u = 0.222 \\text{mm}\\end{equation}\\]\n\n\n\\[\\begin{equation}k = \\frac{3 EI}{4 \\left(l_{1} + l_{2}\\right) \\text{m}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k = \\frac{4500 \\text{N}}{\\text{mm}}\\end{equation}\\]\n\n\n\n\n6.2.1.2 Eigenkreisfrequenz\n\nomega_n = sp.sqrt(k/m)\n\nrender.eq_display(\n                  'omega_n', omega_n,\n                  'omega_n', omega_n.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{n} = \\frac{\\sqrt{3} \\sqrt{\\frac{EI}{m_{} \\left(l_{1} + l_{2}\\right)}}}{2 \\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{67.1}{\\text{s}}\\end{equation}\\]\n\n\n\n\n\n6.2.2 Vergrösserungsfaktor\nDer Vergrösserungsfaktor beschreibt das Verhältnis zwischen der maximalen statischen Amplitude und der maximalen dynamischen Amplitude:\n\\[V(\\omega) = \\frac{u_{max}}{u_0}\\]\nDieser lässt sich mit der Dämpfungsrate \\(\\zeta\\), Anregungsfrequenz \\(\\omega\\) und der Eigenfrequenz \\(\\omega_n\\) beschreiben.\n\ndef plot_vergroesserungsfaktor():\n    import numpy as np\n    \n    # Gleichung des Vergrösserungsfaktors\n    def vergroesserungsfaktor(omega_omega_n, zeta):\n        1/(sp.sqrt((1-(omega/omega_n)**2)**2 + (2*zeta*(omega/omega_n))**2))\n        return 1/(np.sqrt((1-(omega_omega_n)**2)**2 + (2*zeta*(omega_omega_n))**2))\n    \n    omega_omega_n_array = np.linspace(0, 2, 1000)\n    zeta_array = [0.00, 0.01, 0.05, 0.1, 0.2, 0.5, 0.7]\n\n\n    # Plot\n    fig = plt.figure(figsize=(5.9, 2.5))\n    for z in zeta_array:\n        plt.plot(omega_omega_n_array,vergroesserungsfaktor(omega_omega_n_array, z), label=f'$\\zeta = {z}$')\n\n\n    plt.grid()\n    plt.xlabel('$\\omega / \\omega_n$')\n    plt.ylabel('$V(\\omega)$')\n    plt.legend(loc='upper left')\n    plt.xlim(0,2)\n    plt.ylim(0,10)\n    plt.show()\n    \nplot_vergroesserungsfaktor()\n\n\n\n\nAbbildung 6.3: Einfluss der Dämpfung und der Anregungsfrequenz auf den Vergrösserungsfaktor\n\n\n\n\n\nV_omega = 1/(sp.sqrt((1-(omega/omega_n)**2)**2 + (2*zeta*(omega/omega_n))**2))\n\n\n\nrender.eq_display('V(omega)', '1/(sqrt((1-(omega/omega_n)**2)**2 + (2*zeta_*(omega/omega_n))**2))',\n                  'V(omega)', V_omega.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = 8.07\\end{equation}\\]\n\n\n\n\n6.2.3 Statische Amplitude\nDie Einwirkung lässt sich aus der Anregungsfunktion Gleichung 6.1 bestimmen für \\(t=0\\). Mit der bekannten Systemsteifigkeit bestimmt sich die Deformation.\n\nu_stat = F_0 / k\n\nrender.eq_display('u_stat', 'F_0 / k',\n                  'u_stat', u_stat,\n                  'u_stat', u_stat.subs(params).evalf(4))\n\n\\[\\begin{equation}u_{stat} = \\frac{F_{0}}{k}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{stat} = \\frac{4 F_{0} \\left(l_{1} + l_{2}\\right) \\text{m}^{2}}{3 EI}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{stat} = 11.11 \\text{mm}\\end{equation}\\]\n\n\n\n6.2.3.1 Stationäre Amplitude\nDurch die Vergrösserung der statischen Deformation mit dem Vergrösserungsfaktor resultiert die maximale Amplitude der stationären Lösung.\n\nu_dyn = u_stat * V_omega\n\nrender.eq_display('u_dyn', 'u_stat * V(omega)',\n                  'u_dyn', u_dyn,\n                  'u_dyn', unit.convert_to(u_dyn.subs(params).simplify().evalf(3), unit.mm))\n\n\\[\\begin{equation}u_{dyn} = u_{stat} V{\\left(\\omega \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{dyn} = \\frac{4 F_{0} \\left(l_{1} + l_{2}\\right) \\text{m}^{2}}{3 EI \\sqrt{\\frac{16 m_{} \\omega^{2} \\zeta^{2} \\left(l_{1} + l_{2}\\right) \\text{m}^{2}}{3 EI} + \\left(- \\frac{4 m_{} \\omega^{2} \\left(l_{1} + l_{2}\\right) \\text{m}^{2}}{3 EI} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{dyn} = 89.6 \\text{mm}\\end{equation}\\]\n\n\nDer Nachweis der Gebrauchstauglichkeit wäre damit sicherlich nicht erfüllt. Das Beispiel soll aufzeigen, wenn die Erregerfrequenz im Bereich der Eigenfrequenz zu liegen kommt, es zu grossen Amplifikationen der Verformungen bzw. zu Resonanzeffekten kommen kann.\nDa meist die Masse und die Erregung (z.B. Maschine) gegeben ist, kann man zum Beispiel ein Dämpfungselement einbauen, was jedoch keinen wesentlichen Einfluss auf das Frequenzverhältnis hat. Dadurch werden jedoch die Amplituden begrenzt.\nEine weitere Möglichkeit wäre die Biegesteifigkeit \\(E\\cdot I\\) zu erhöhen. Das System wird steifer und die Eigenfrequenz grösser. Man spricht in dem Fall von einer Hochabstimmung.\n\nu_p = V_omega.subs(params) * u_stat *sp.cos(omega *t)\n\n# render.eq_display('u_p', u_p.subs(params).simplify().evalf(3))\n\n\nomega_d = omega_n * sp.sqrt(1-zeta**2)\n\n# render.eq_display('omega_d', 'omega_n *sqrt(1-zeta_**2)',\n#                   'omega_d', omega_d.subs(params).simplify().evalf(3))\n\n\nA_1, A_2 = sp.symbols('A_1:3')\nomega_d_raw = omega_d*unit.second\nomega_n_raw = omega_n * unit.second\nu_h_ansatz = sp.exp(-zeta*omega_n_raw*t)*(A_1 * sp.cos(omega_d_raw*t)+A_2*sp.sin(omega_d_raw*t))\nrandbedingung_1 = (u_h_ansatz+u_p).subs(t,0)\nrandbedingung_2 = sp.diff((u_h_ansatz+u_p),t).subs(t,0)\n\nA_solve = sp.solve([randbedingung_1, randbedingung_2], [A_1, A_2], dict=True)[0]\n\n\nu_h = u_h_ansatz.subs(A_solve)\n\n\nu_t = u_h.subs(params).simplify()/unit.m + u_p.subs(params_plot).simplify()/unit.m**2\n\nu_t_plot = u_t.subs(params_plot).subs(unit.second, 1)\n\nplot_gesamt=sp.plot(u_t_plot, (t,0,10), adaptive=False, nb_of_points=500, \n        xlabel='$t [s]$',\n        ylabel='$u(t)$ [m]',\n        size=(5.9,3))\n\n\n\n\n\n\nAbbildung 6.4: Gesamtantwort des Systems\n\n\n\n\nIn der Abbildung 6.4 ist die Gesamtantwort des Systems dargestellt. Wenn Dämpfung im System vorhanden ist, dann verschwindet die transiente bzw. homogene Lösung \\(u(t)\\) und das System schwingt mit der stationären Lösung bzw. partikulären Lösung \\(u(t)\\) in der Anregungsfrequenz. In Bezug auf die Abbildung 6.4 schwingt das System am Anfang stärker, durch das Abklingen der Anfangsauslenkung durch die Dämpfung schwingt das System nur noch in der Anregungsfrequenz weiter. Die Anregung zwingt dem System seine Schwingung auf. In der Praxis sind die Anlaufphasen zu beachten, solange der transiente Teil noch nicht abgeklungen ist. Dort sind die Amplituden grösser und es gilt zu untersuchen, ob diese kurzfristige Überschreitung Konsequenzen (z.B. zul. Verformungen oder Bauteilspannungen) für das Tragsystem hat."
  },
  {
    "objectID": "ems_04.html#aufgabenstellung",
    "href": "ems_04.html#aufgabenstellung",
    "title": "7  Beispiel: Gesamtantwort ohne Dämpfung",
    "section": "7.1 Aufgabenstellung",
    "text": "7.1 Aufgabenstellung\nDas System in Abbildung 7.1 zeigt ein Stabwerk, welches durch eine Werkzeugmaschine angeregt wird.\n\n\n\nAbbildung 7.1: Statisches System des Stabwerks\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega_n\\)\nDynamischer Vergrösserungsfaktor \\(V(\\omega)\\)\nStationäre Antwort \\(u_p(t)\\) mit dem dynamischen Vergrösserungsfaktor \\(V(\\omega)\\)\nGesamtantwort \\(u(t)\\) mit den Anfangsbedingungen \\(u(t=0) = 0 \\text{ und } u'(t=0)=0\\)\nFestigkeitsnachweis der Diagonalen\n\nGegeben:\n\nAlle Stäbe ausser Diagonalen \\(E\\cdot A = \\infty\\)\nAlle Stäbe S355\n\n\n\n\nAbbildung 7.2: Aufbau der Werkzeugmaschine\n\n\n\nm_tot, E, H, B, Diam, f_yd, m_1, n, e = sp.symbols('m_tot, E, H, B, \\oslash_Diag, f_yd, m_1, n, e')\n\nF_0, omega, t, zeta = sp.symbols('F_0, omega, t, zeta')\n\n\nparams = {              \n          m_tot:5000*unit.N*unit.second**2/unit.m, \n          E:210*10**3*unit.N/unit.mm**2,\n          H:4000*unit.mm,\n          B:6000*unit.mm,\n          Diam:12*unit.mm,\n          f_yd:338*unit.N/unit.mm**2,\n          m_1:200*unit.N*unit.second**2/unit.m,\n          n:150/unit.minute,\n          e:0.1*unit.m,\n          zeta:0.0,\n          }\n\nparams_plot = convert.param_value(params)\n\nrender.dict_to_table(params)\n\n\n\nTabelle 7.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(B = 6000 \\text{mm}\\)\n\\(E = \\frac{210000 \\text{N}}{\\text{mm}^{2}}\\)\n\n\n\\(H = 4000 \\text{mm}\\)\n\\(\\oslash_{Diag} = 12 \\text{mm}\\)\n\n\n\\(e = 0.1 \\text{m}\\)\n\\(f_{yd} = \\frac{338 \\text{N}}{\\text{mm}^{2}}\\)\n\n\n\\(m_{1} = \\frac{200 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(m_{tot} = \\frac{5000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\n\n\\(n = \\frac{150}{\\text{minute}}\\)\n\\(\\zeta = 0.0\\)"
  },
  {
    "objectID": "ems_04.html#musterlösung",
    "href": "ems_04.html#musterlösung",
    "title": "7  Beispiel: Gesamtantwort ohne Dämpfung",
    "section": "7.2 Musterlösung",
    "text": "7.2 Musterlösung\n\nF_t = F_0 * sp.cos(omega*t)\n\n\n7.2.1 Systemsteifigkeit\nZur Ermittlung der Eigenkreisfrequenz wird die Steifigkeit des gesamten Systems benötigt.\n\n\n\nAbbildung 7.3: Verformungszustand des Systems für die Einheitskraft\n\n\nDas System wird mit einer Einheitskraft belastet. Aufgrund der Eigenschaften der Pendelstäbe (lediglich Normalkräfte) und deren unendlich grossen Dehnsteifigkeit, spielt lediglich die Verformung der Diagonalen eine Rolle. Dazu gilt, dass die Diagonalen nur Zugkräfte aufnehmen können. Das bedeutet, dass letztlich ein Stab aktiv ist für die beschrieben Situation in Abbildung 7.3.\nDazu muss die Normalkraft in der Diagonalen bestimmt werden.\n\nalpha = sp.atan(H/B)\n\nZ_Diag = 1000*unit.N /sp.cos(alpha)\n\n\nrender.eq_display('alpha', alpha,\n                  'alpha', alpha.subs(params).evalf(3),\n                  'Z_Diag', Z_Diag,\n                  'Z_Diag',Z_Diag.subs(params).evalf(3))\n\n\\[\\begin{equation}\\alpha = \\operatorname{atan}{\\left(\\frac{H}{B} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\alpha = 0.588\\end{equation}\\]\n\n\n\\[\\begin{equation}Z_{Diag} = 1000 \\sqrt{1 + \\frac{H^{2}}{B^{2}}} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Z_{Diag} = 1.2 \\cdot 10^{3} \\text{N}\\end{equation}\\]\n\n\nMittels der Arbeitsgleichung lässt sich die Verformung bestimmen. Für die Integration zweier Normalkraftverläufe gilt die folgende Beziehung:\n\\[\nu = \\frac{1}{EA_{Diag}}  \\int_{0}^{l_{Diag}} N_x\\bar{N_x} \\,dx\n\\tag{7.1}\\]\nLänge der Diagonalen:\n\nl_Diag = B /sp.cos(alpha)\nA_Diag = sp.pi * Diam**2 / 4\nu_for_k = 1/(E*A_Diag) * Z_Diag * Z_Diag/(1000*unit.N) * l_Diag\n\nk = 1000*unit.N / u_for_k\nrender.eq_display('l_Diag', l_Diag,\n                  'l_Diag', unit.convert_to(l_Diag.subs(params).evalf(3), unit.m),)\n\n\\[\\begin{equation}l_{Diag} = B \\sqrt{1 + \\frac{H^{2}}{B^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}l_{Diag} = 7.21 \\text{m}\\end{equation}\\]\n\n\nQuerschnittsfläche der Diagonalen:\n\nrender.eq_display('A_Diag', A_Diag,\n                  'A_Diag', A_Diag.subs(params).evalf(3))\n\n\\[\\begin{equation}A_{Diag} = \\frac{\\pi \\oslash_{Diag}^{2}}{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}A_{Diag} = 113.0 \\text{mm}^{2}\\end{equation}\\]\n\n\nDeformation der Diagonalen\n\nrender.eq_display(\n                  'u_k', u_for_k,\n                  'u_k', u_for_k.subs(params).evalf(3))\n\n\\[\\begin{equation}u_{k} = \\frac{4000 B \\left(1 + \\frac{H^{2}}{B^{2}}\\right)^{\\frac{3}{2}} \\text{N}}{\\pi E \\oslash_{Diag}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{k} = 0.439 \\text{mm}\\end{equation}\\]\n\n\nSteifigkeit des Systems:\n\nrender.eq_display('k', 'F/u_k',\n                  'k', k.subs(params).evalf(3))\n\n\\[\\begin{equation}k = \\frac{F}{u_{k}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k = \\frac{2.28 \\cdot 10^{3} \\text{N}}{\\text{mm}}\\end{equation}\\]\n\n\n\n\n7.2.2 Eigenkreisfrequenz\nAus der Systemsteifigkeit lässt sich leicht die Eigenkreisfrequenz bestimmen:\n\\[\n\\omega_n =\\sqrt{\\frac{k}{m}}\n\\tag{7.2}\\]\n\nomega_n = sp.sqrt(k/m_tot)\n\nrender.eq_display('omega_n', omega_n,\n                  'omega_n', omega_n.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{n} = \\frac{\\sqrt{\\pi} \\sqrt{\\frac{E \\oslash_{Diag}^{2}}{B m_{tot} \\left(1 + \\frac{H^{2}}{B^{2}}\\right)^{\\frac{3}{2}}}}}{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{21.4}{\\text{s}}\\end{equation}\\]\n\n\n\n\n7.2.3 Dynamischer Vergrösserungsfaktor\n\n7.2.3.1 Anregungsfunktion\nZur Bestimmung des dynamischen Vergrösserungsfaktor wird die stationäre Verformung benötigt. Diese lässt sich aus der Anfangskraft der Anregungsfunktion ermitteln. Dazu wird diese Funktion benötigt. Wir wissen die Drehzahl \\(n\\) und die Exzentrizität \\(e\\) sowie deren Masse \\(m_1\\).\n\nf = unit.convert_to(n.subs(params),unit.second)\nomega = 2*sp.pi*f\nparams['omega'] = omega.subs(params).simplify()\n\nrender.eq_display('f', 'n',\n                  'f', f.evalf(3),\n                  'omega', '2*pi*f',\n                  'omega', omega.evalf(3),\n                  )\n\n\\[\\begin{equation}f = n\\end{equation}\\]\n\n\n\\[\\begin{equation}f = \\frac{2.5}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega = 2 \\pi f\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega = \\frac{15.7}{\\text{s}}\\end{equation}\\]\n\n\nNun fehlt lediglich die Anfangskraft \\(F_0\\). Die Fliehkraft \\(F\\) der 2 gegenläufig rotierenden Massen bewirken eine addierende Fliehkraft in horizontaler Richtung zu:\n\\[\nF_0 = 2(m_1 \\cdot e \\cdot \\omega^2)\n\\tag{7.3}\\]\n\nF_0 = 2*(m_1*e*omega**2)\nparams['F_0'] = F_0.subs(params).simplify()\nrender.eq_display('F_0', F_0,\n                  'F_0', F_0.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}F_{0} = \\frac{50 \\pi^{2} e m_{1}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}F_{0} = 9.87 \\cdot 10^{3} \\text{N}\\end{equation}\\]\n\n\n\n\n7.2.3.2 Statische Deformation\nDie statische Deformation lässt sich nun leicht anhand der ermittelten Systemsteifigkeit herleiten.\n\nu_0 = F_0/k\n\nrender.eq_display(\n    'u_0', 'F_0/k',\n    'u_0', u_0.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{0} = \\frac{F_{0}}{k}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{0} = 4.33 \\text{mm}\\end{equation}\\]\n\n\n\n\n7.2.3.3 Vergrösserungsfaktor\n\nV_omega = 1/(sp.sqrt((1-(omega/omega_n)**2)**2 + (2*zeta*(omega/omega_n))**2))\n\nrender.eq_display('V(omega)', '1/(sqrt((1-(omega/omega_n)**2)**2 + (2*zeta_*(omega/omega_n))**2))',\n                  'V(omega)', V_omega.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = 2.18\\end{equation}\\]\n\n\n\n\n\n7.2.4 Stationäre Antwort\nEs handelt sich um einen ungedämpften Einmassenschwinger mit einer harmonischen Anregungsfunktion. Die Bewegungsgleichung ist die folgende:\n\\[\nmu''(t)+ ku(t) = F(t)\n\\tag{7.4}\\]\nDies ist eine inhomogene Differentialgleichung 2. Ordnung. Die Lösung dieser lässt sich in einen partikulären Anteil und in einen homogenen Anteil aufteilen. Der partikuläre Anteil entspricht der stationären Antwort. Der homogene Anteil nennt sich transienter Anteil. Wäre eine Dämpfung im System vorhanden, so startet der Schwungvorgang aus einer Kombination beider Teile. Aufgrund der Dämpfung verschwindet der stationäre Anteil und das System wird schlussendlich nur noch durch den transienten Anteil deformiert.\nAnhand des Vergrösserungsfaktor kann die stationäre dynamische Antwort des Systems mit der folgenden Beziehung ermittelt werden.\n\\[\nu_p = V(\\omega)u_0 \\cdot \\cos{(\\omega t)}\n\\tag{7.5}\\]\n\nu_p = V_omega * u_0 *sp.cos(omega *t)\n\nrender.eq_display('u_p', u_p.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{p} = 9.43 \\cos{\\left(\\frac{5 \\pi t}{\\text{s}} \\right)} \\text{mm}\\end{equation}\\]\n\n\n\n\n7.2.5 Gesamtantwort\nFür die Gesamtantwort wird nun noch der homogene Anteil benötigt. Dazu ist die folgende Differentialgleichung zu lösen.\n\\[\nmu''(t)+ ku(t) = 0\n\\tag{7.6}\\]\nAls Ansatzfunktion dient die folgende Gleichung:\n\\[\nu_h = A_1\\cos{(\\omega_n t)} + A_2 \\sin{(\\omega_n t)}\n\\tag{7.7}\\]\nDie Randbedingungen sind in der Aufgabenstellung definiert und sind die folgenden:\n\\(u(t=0)=0\\)\n\\(u'(t=0)=0\\)\nVorsicht, die Randbedingungen gelten für die gesamte Lösung:\n\\[\nu(t) = u_h(t) + u_p(t)\n\\tag{7.8}\\]\n\nA_1, A_2 = sp.symbols('A_1:3')\n\nu_h_ansatz = A_1 * sp.cos(omega_n*t)+A_2*sp.sin(omega_n*t)\nrandbedingung_1 = (u_h_ansatz+u_p).subs(t,0)\nrandbedingung_2 = sp.diff((u_h_ansatz+u_p),t).subs(t,0)\n\nA_solve = sp.solve([randbedingung_1, randbedingung_2], [A_1, A_2], dict=True)[0]\n\n\nu_h = u_h_ansatz.subs(A_solve)\n\n\nu_t = u_h+u_p\n\nu_t_plot = u_t.subs(params_plot).subs(unit.second, 1)\nu_p_plot = u_p.subs(params_plot).subs(unit.second, 1)\nu_h_plot = u_h.subs(params_plot).subs(unit.second, 1)\n\np_1 = sp.plot(u_h_plot, (t,0,6), adaptive=False, nb_of_points=500, \n        xlabel='$t [s]$',\n        ylabel='$u(t)$ [m]',\n        size=(5.9,3),show=False,label='Transienter Anteil', legend=True, line_color='0.5')\n\np_2 = sp.plot(u_p_plot, (t,0,6), adaptive=False, nb_of_points=500,show=False,label='Stationärer Anteil', line_color='0.8')\n\np_3 = sp.plot(u_t_plot, (t,0,6), adaptive=False, nb_of_points=500,show=False,label='Gesamtantwort')\n\n\np_1.append(p_2[0])\np_1.append(p_3[0])\n\np_1.show()\n\n\n\n\nAbbildung 7.4: Antworten des Systems ohne Dämpfung\n\n\n\n\n\n\n7.2.6 Festigkeitsnachweis\nAufgrund der maximalen Auslenkung, kann die maximale Normalkraft auf der Diagonalen bestimmt werden.\n\n7.2.6.1 Maximale Auslenkung\nAus dem Plot in Abbildung 7.4 ist die maximale Auslenkung ersichtlich. Die Ermittlung des Zeitpunkts bei einer maximalen Auslenkung wird hier numerisch gelöst.\n\nt_max_auslenkung = sp.nsolve(sp.diff(u_t_plot,t), t,(2.6,2.8))\n\nu_max = u_t_plot.subs(t,t_max_auslenkung)\n\n\nrender.eq_display('t_max', (t_max_auslenkung*unit.second).evalf(3),\n                  'u_max', (u_max*unit.m).evalf(3))\n\n\\[\\begin{equation}t_{max} = 2.8 \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{max} = 0.0188 \\text{m}\\end{equation}\\]\n\n\n\n\n7.2.6.2 Maximale Einwirkung\nAufgrund der maximalen Amplitude verlängert sich die Diagonale um \\(\\Delta l = u_{max}\\). Die Dehnung des Stabs ist somit die \\(\\frac{\\Delta l}{l_{Diag}}\\). Bei linear elastischem Materialverhalten gilt die folgende Beziehung:\n\\[\n\\sigma = \\varepsilon E\n\\tag{7.9}\\]\n\nepsilon = u_max*unit.m / sp.cos(alpha) / l_Diag\nsigma = epsilon*E\n\nNachweis = sigma / f_yd\n\nrender.eq_display('varepsilon', epsilon.subs(params).simplify().evalf(3),\n                  'sigma', unit.convert_to(sigma.subs(params).simplify().evalf(3), unit.mm**2),\n                  'f_yd', f_yd.subs(params),\n                  'Nachweis', 'sigma / f_yd',\n                  'Nachweis', Nachweis.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\varepsilon = 0.00314\\end{equation}\\]\n\n\n\\[\\begin{equation}\\sigma = \\frac{659.0 \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}f_{yd} = \\frac{338 \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}Nachweis = \\frac{\\sigma}{f_{yd}}\\end{equation}\\]\n\n\n\\[\\begin{equation}Nachweis = 1.95\\end{equation}\\]\n\n\nDie Diagonale würde plastifizieren, so dass die linearen Annahmen für die Berechnung der Systemantwort nicht angewendet werden dürfen."
  },
  {
    "objectID": "ems_05.html#aufgabenstellung",
    "href": "ems_05.html#aufgabenstellung",
    "title": "8  Beispiel: Gesamtantwort mit Dämpfung",
    "section": "8.1 Aufgabenstellung",
    "text": "8.1 Aufgabenstellung\nDas System in Abbildung 8.1 entspricht dem System in Abbildung 7.1. Ergänzt wurde dies mit einem Dämpfungselement.\n\n\n\nAbbildung 8.1: Statisches System\n\n\nGesucht:\n\nDynamischer Vergrösserungsfaktor \\(V(\\omega)\\)\nStationäre Amplitude\nFestigkeitsnachweis der Diagonalen\n\nGegeben:\n\nAlle Stäbe ausser Diagonalen \\(E\\cdot A = \\infty\\)\nAlle Stäbe S355\n\n\n\n\nAbbildung 8.2: Aufbau der Werkzeugmaschine\n\n\n\nm_tot, E, H, B, Diam, f_yd, m_1, n, e = sp.symbols('m_tot, E, H, B, \\oslash_Diag, f_yd, m_1, n, e')\n\nF_0, omega, t, zeta = sp.symbols('F_0, omega, t, zeta')\n\n\nparams = {              \n          m_tot:5000*unit.N*unit.second**2/unit.m, \n          E:210*10**3*unit.N/unit.mm**2,\n          H:4000*unit.mm,\n          B:6000*unit.mm,\n          Diam:12*unit.mm,\n          f_yd:338*unit.N/unit.mm**2,\n          m_1:200*unit.N*unit.second**2/unit.m,\n          n:150/unit.minute,\n          e:0.1*unit.m,\n          zeta:0.2,\n          }\n\nparams_plot = convert.param_value(params)\n\nrender.dict_to_table(params)\n\n\n\nTabelle 8.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(B = 6000 \\text{mm}\\)\n\\(E = \\frac{210000 \\text{N}}{\\text{mm}^{2}}\\)\n\n\n\\(H = 4000 \\text{mm}\\)\n\\(\\oslash_{Diag} = 12 \\text{mm}\\)\n\n\n\\(e = 0.1 \\text{m}\\)\n\\(f_{yd} = \\frac{338 \\text{N}}{\\text{mm}^{2}}\\)\n\n\n\\(m_{1} = \\frac{200 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(m_{tot} = \\frac{5000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\n\n\\(n = \\frac{150}{\\text{minute}}\\)\n\\(\\zeta = 0.2\\)"
  },
  {
    "objectID": "ems_05.html#musterlösung",
    "href": "ems_05.html#musterlösung",
    "title": "8  Beispiel: Gesamtantwort mit Dämpfung",
    "section": "8.2 Musterlösung",
    "text": "8.2 Musterlösung\n\nF_t = F_0 * sp.cos(omega*t)\n\n\n8.2.1 Systemsteifigkeit\nZur Ermittlung der Eigenkreisfrequenz wird die Steifigkeit des gesamten Systems benötigt.\n\n\n\nAbbildung 8.3: Verformungszustand des Systems für die Einheitskraft\n\n\nDas System wird mit einer Einheitskraft belastet. Aufgrund der Eigenschaften der Pendelstäbe (lediglich Normalkräfte) und deren unendlich grossen Dehnsteifigkeit, spielt lediglich die Verformung der Diagonalen eine Rolle. Dazu gilt, dass die Diagonalen nur Zugkräfte aufnehmen können. Das bedeutet, dass letztlich ein Stab aktiv ist für die beschrieben Situation in Abbildung 8.3.\nDazu muss die Normalkraft in der Diagonalen bestimmt werden.\n\nalpha = sp.atan(H/B)\n\nZ_Diag = 1000*unit.N /sp.cos(alpha)\n\nrender.eq_display('alpha', alpha,\n                  'alpha', alpha.subs(params).evalf(3),\n                  'Z_Diag', Z_Diag,\n                  'Z_Diag',Z_Diag.subs(params).evalf(3))\n\n\\[\\begin{equation}\\alpha = \\operatorname{atan}{\\left(\\frac{H}{B} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\alpha = 0.588\\end{equation}\\]\n\n\n\\[\\begin{equation}Z_{Diag} = 1000 \\sqrt{1 + \\frac{H^{2}}{B^{2}}} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Z_{Diag} = 1.2 \\cdot 10^{3} \\text{N}\\end{equation}\\]\n\n\nMittels der Arbeitsgleichung lässt sich die Verformung bestimmen. Für die Integration zweier Normalkraftverläufe gilt die folgende Beziehung:\n\\[\nu = \\frac{1}{EA_{Diag}}  \\int_{0}^{l_{Diag}} N_x\\bar{N_x} \\,dx\n\\tag{8.1}\\]\nLänge der Diagonalen:\n\nl_Diag = B /sp.cos(alpha)\nA_Diag = sp.pi * Diam**2 / 4\nu_for_k = 1/(E*A_Diag) * Z_Diag * Z_Diag/(1000*unit.N) * l_Diag\n\nk = 1000*unit.N / u_for_k\nrender.eq_display('l_Diag', l_Diag,\n                  'l_Diag', unit.convert_to(l_Diag.subs(params).evalf(3), unit.m),)\n\n\\[\\begin{equation}l_{Diag} = B \\sqrt{1 + \\frac{H^{2}}{B^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}l_{Diag} = 7.21 \\text{m}\\end{equation}\\]\n\n\nQuerschnittsfläche der Diagonalen:\n\nrender.eq_display('A_Diag', A_Diag,\n                  'A_Diag', A_Diag.subs(params).evalf(3))\n\n\\[\\begin{equation}A_{Diag} = \\frac{\\pi \\oslash_{Diag}^{2}}{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}A_{Diag} = 113.0 \\text{mm}^{2}\\end{equation}\\]\n\n\nDeformation der Diagonalen\n\nrender.eq_display(\n                  'u_k', u_for_k,\n                  'u_k', u_for_k.subs(params).evalf(3))\n\n\\[\\begin{equation}u_{k} = \\frac{4000 B \\left(1 + \\frac{H^{2}}{B^{2}}\\right)^{\\frac{3}{2}} \\text{N}}{\\pi E \\oslash_{Diag}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{k} = 0.439 \\text{mm}\\end{equation}\\]\n\n\nSteifigkeit des Systems:\n\nrender.eq_display('k', 'F/u_k',\n                  'k', k.subs(params).evalf(3))\n\n\\[\\begin{equation}k = \\frac{F}{u_{k}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k = \\frac{2.28 \\cdot 10^{3} \\text{N}}{\\text{mm}}\\end{equation}\\]\n\n\n\n\n8.2.2 Eigenkreisfrequenz\nAus der Systemsteifigkeit lässt sich leicht die Eigenkreisfrequenz bestimmen:\n\\[\n\\omega_n =\\sqrt{\\frac{k}{m}}\n\\tag{8.2}\\]\n\nomega_n = sp.sqrt(k/m_tot)\n\nrender.eq_display('omega_n', omega_n,\n                  'omega_n', omega_n.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{n} = \\frac{\\sqrt{\\pi} \\sqrt{\\frac{E \\oslash_{Diag}^{2}}{B m_{tot} \\left(1 + \\frac{H^{2}}{B^{2}}\\right)^{\\frac{3}{2}}}}}{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{21.4}{\\text{s}}\\end{equation}\\]\n\n\n\n\n8.2.3 Dynamischer Vergrösserungsfaktor\n\n8.2.3.1 Anregungsfunktion\nZur Bestimmung des dynamischen Vergrösserungsfaktor wird die stationäre Verformung benötigt. Diese lässt sich aus der Anfangskraft der Anregungsfunktion ermitteln. Dazu wird diese Funktion benötigt. Wir wissen die Drehzahl \\(n\\) und die Exzentrizität \\(e\\) sowie deren Masse \\(m_1\\).\n\nf = unit.convert_to(n.subs(params),unit.second)\nomega = 2*sp.pi*f\nparams['omega'] = omega.subs(params).simplify()\n\nrender.eq_display('f', 'n',\n                  'f', f.evalf(3),\n                  'omega', '2*pi*f',\n                  'omega', omega.evalf(3),\n                  )\n\n\\[\\begin{equation}f = n\\end{equation}\\]\n\n\n\\[\\begin{equation}f = \\frac{2.5}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega = 2 \\pi f\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega = \\frac{15.7}{\\text{s}}\\end{equation}\\]\n\n\nNun fehlt lediglich die Anfangskraft \\(F_0\\). Die Fliehkraft \\(F\\) der 2 gegenläufig rotierenden Massen bewirken eine addierende Fliehkraft in horizontaler Richtung zu:\n\\[\nF_0 = 2(m_1 \\cdot e \\cdot \\omega^2)\n\\tag{8.3}\\]\n\nF_0 = 2*(m_1*e*omega**2)\nparams['F_0'] = F_0.subs(params).simplify()\nrender.eq_display('F_0', F_0,\n                  'F_0', F_0.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}F_{0} = \\frac{50 \\pi^{2} e m_{1}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}F_{0} = 9.87 \\cdot 10^{3} \\text{N}\\end{equation}\\]\n\n\n\n\n8.2.3.2 Statische Deformation\nDie statische Deformation lässt sich nun leicht anhand der ermittelten Systemsteifigkeit herleiten.\n\nu_0 = F_0/k\n\nrender.eq_display('u_0', u_0.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{0} = 4.33 \\text{mm}\\end{equation}\\]\n\n\n\n\n8.2.3.3 Vergrösserungsfaktor\n\nV_omega = 1/(sp.sqrt((1-(omega/omega_n)**2)**2 + (2*zeta*(omega/omega_n))**2))\n\nrender.eq_display('V(omega)', '1/(sqrt((1-(omega/omega_n)**2)**2 + (2*zeta_*(omega/omega_n))**2))',\n                  'V(omega)', V_omega.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = 1.83\\end{equation}\\]\n\n\n\n\n\n8.2.4 Stationäre Antwort\nEs handelt sich um einen gedämpften Einmassenschwinger mit einer harmonischen Anregungsfunktion. Die Bewegungsgleichung ist die folgende:\n\\[\nmu''(t)+ cu'(t) + ku(t) = F(t)\n\\tag{8.4}\\]\nDies ist eine inhomogene Differentialgleichung 2. Ordnung. Die Lösung dieser lässt sich in einen partikulären Anteil und in einen homogenen Anteil aufteilen. Der partikuläre Anteil entspricht der stationären Antwort. Der homogene Anteil nennt sich transienter Anteil.\nAnhand des Vergrösserungsfaktor kann die stationäre dynamische Antwort des Systems mit der folgenden Beziehung ermittelt werden.\n\\[\nu_p = V(\\omega)u_0 \\cdot \\cos{(\\omega t)}\n\\tag{8.5}\\]\n\nu_p = V_omega * u_0 *sp.cos(omega *t)\n\nrender.eq_display('u_p', u_p.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{p} = 0.00793 \\cos{\\left(\\frac{5 \\pi t}{\\text{s}} \\right)} \\text{m}\\end{equation}\\]\n\n\n\n\n8.2.5 Gesamtantwort\nFür die Gesamtantwort wird nun noch der homogene Anteil benötigt. Dazu ist die folgende Differentialgleichung zu lösen.\n\\[\nmu''(t)+ cu'(t) + ku(t) = 0\n\\tag{8.6}\\]\nAls Ansatzfunktion dient die folgende Gleichung:\n\\[\nu_h = e^{-\\zeta \\omega_n t} (A_1\\cos{(\\omega_d t)} + A_2 \\sin{(\\omega_d t)})\n\\tag{8.7}\\]\nDie Randbedingungen sind in der Aufgabenstellung definiert und sind die folgenden:\n\\(u(t=0)=0\\)\n\\(u'(t=0)=0\\)\nVorsicht, die Randbedingungen gelten für die gesamte Lösung:\n\\[\nu(t) = u_h(t) + u_p(t)\n\\tag{8.8}\\]\n\n8.2.5.1 Gedämpfte Eigenkreisfrequenz\n\nomega_d = omega_n * sp.sqrt(1-zeta**2)\n\nrender.eq_display('omega_d', 'omega_n *sqrt(1-zeta_**2)',\n                  'omega_d', omega_d.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{d} = \\omega_{n} \\sqrt{1 - \\zeta_{}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{d} = \\frac{20.9}{\\text{s}}\\end{equation}\\]\n\n\n\nA_1, A_2 = sp.symbols('A_1:3')\n\nu_h_ansatz = sp.exp(-zeta*omega_n*t)*(A_1 * sp.cos(omega_d*t)+A_2*sp.sin(omega_d*t))\nrandbedingung_1 = (u_h_ansatz+u_p).subs(t,0)\nrandbedingung_2 = sp.diff((u_h_ansatz+u_p),t).subs(t,0)\n\nA_solve = sp.solve([randbedingung_1, randbedingung_2], [A_1, A_2], dict=True)[0]\n\n\nu_h = u_h_ansatz.subs(A_solve)\n\n\nu_t = u_h + u_p\n\nu_t_plot = u_t.subs(params_plot).subs(unit.second, 1)\nu_p_plot = u_p.subs(params_plot).subs(unit.second, 1)\nu_h_plot = u_h.subs(params_plot).subs(unit.second, 1)\n\np_1 = sp.plot(u_h_plot, (t,0,6), adaptive=False, nb_of_points=500, \n        xlabel='$t [s]$',\n        ylabel='$u(t)$ [m]',\n        size=(5.9,3),show=False,label='Transienter Anteil', legend=True, line_color='0.5')\n\np_2 = sp.plot(u_p_plot, (t,0,6), adaptive=False, nb_of_points=500,show=False,label='Stationärer Anteil', line_color='0.8')\n\np_3 = sp.plot(u_t_plot, (t,0,6), adaptive=False, nb_of_points=500,show=False,label='Gesamtantwort')\n\np_1.append(p_2[0])\np_1.append(p_3[0])\n\np_1.show()\n\n\n\n\nAbbildung 8.4: Gesamtantwort des Systems\n\n\n\n\n\n\n\n8.2.6 Festigkeitsnachweis\nAufgrund der maximalen Auslenkung kann die maximale Normalkraft auf der Diagonalen bestimmt werden.\n\n8.2.6.1 Maximale Auslenkung\nAus dem Plot in Abbildung 8.4 ist die maximale Auslenkung ersichtlich. Die Ermittlung des Zeitpunkts bei einer maximalen Auslenkung wird hier numerisch gelöst.\n\nt_max_auslenkung = sp.nsolve(sp.diff(u_t_plot,t), t,(0.3,0.5))\n\nu_max = u_t_plot.subs(t,t_max_auslenkung)\n\n\nrender.eq_display('t_max', (t_max_auslenkung*unit.second).evalf(2),\n                  'u_max', u_max.evalf(3)*unit.m)\n\n\\[\\begin{equation}t_{max} = 0.41 \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{max} = 0.00855 \\text{m}\\end{equation}\\]\n\n\n\n\n8.2.6.2 Maximale Einwirkung\nAufgrund der maximalen Amplitude verlängert sich die Diagonale um \\(\\Delta l=u_{max}\\). Die Dehnung des Stabs ist somit die \\(\\frac{\\Delta l}{l_{Diag}}\\). Bei linear elastischem Materialverhalten gilt die folgende Beziehung:\n\\[\n\\sigma = \\varepsilon E\n\\tag{8.9}\\]\n\nepsilon = u_max*unit.m / sp.cos(alpha) / l_Diag\nsigma = epsilon*E\n\nNachweis = sigma / f_yd\n\nrender.eq_display('varepsilon', epsilon.subs(params).simplify().evalf(3),\n                  'sigma', unit.convert_to(sigma.subs(params).simplify().evalf(3), unit.mm**2),\n                  'f_yd', f_yd.subs(params),\n                  'Nachweis', 'sigma / f_yd',\n                  'Nachweis', Nachweis.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\varepsilon = 0.00142\\end{equation}\\]\n\n\n\\[\\begin{equation}\\sigma = \\frac{299.0 \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}f_{yd} = \\frac{338 \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}Nachweis = \\frac{\\sigma}{f_{yd}}\\end{equation}\\]\n\n\n\\[\\begin{equation}Nachweis = 0.885\\end{equation}\\]\n\n\nDie Diagonale bleibt im elastischen Bereich, so dass die linearen Annahmen gültig sind. Der Festigkeitsnachweis für die Diagonale ist erfüllt. Im Weiteren wäre der Grenzzustand der Tragfähigkeit Ermüdung zu prüfen."
  },
  {
    "objectID": "ems_06.html#aufgabenstellung",
    "href": "ems_06.html#aufgabenstellung",
    "title": "9  Beispiel: Fourier-Transformation",
    "section": "9.1 Aufgabenstellung",
    "text": "9.1 Aufgabenstellung\nNachfolgend ist ein unterspannter Träger gezeigt, der durch eine periodische Rechteckanregung dynamisch beansprucht wird.\n\n\n\nAbbildung 9.1: Statisches System des unterspannten Trägers\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega_n\\)\nStationäre Amplitude der Verschiebung\nStationäre Amplitude der Beschleunigung\n\nGegeben:\n\nRechteckanregung in Abbildung 9.2\n\n\nomega, t, E, I_Balken, A_Fachwerk, m_, A, l, h, zeta = sp.symbols('omega, t, E, I_Balken, A_Fachwerk, m_, A, l, h, zeta')\n\n\nparams = {E: 200000 *unit.N/unit.mm**2,\n          I_Balken:2*10**8 *unit.mm**4,\n          A_Fachwerk:3000*unit.mm**2,\n          m_:1000*unit.N*unit.second**2/unit.m,\n          A:1*10**3*unit.N,\n          l:5*unit.m,\n          h:2*unit.m,\n          zeta:0.0,\n          }\n\n\nrender.dict_to_table(params)\n\n\n\nTabelle 9.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(A = 1000 \\text{N}\\)\n\\(A_{Fachwerk} = 3000 \\text{mm}^{2}\\)\n\n\n\\(E = \\frac{200000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(I_{Balken} = 200000000 \\text{mm}^{4}\\)\n\n\n\\(h = 2 \\text{m}\\)\n\\(l = 5 \\text{m}\\)\n\n\n\\(m_{} = \\frac{1000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(\\zeta = 0.0\\)\n\n\n\n\n\n\n\nx, t = sp.symbols(\"x t\")\n\n\nsignal_xt = sp.Piecewise((0,t&lt;=0),(1,t&lt;=0.5),(-1,t&lt;=1), (1,t&lt;=1.5), (-1,t&lt;=2), (0,t&gt;2))\n\np_1 = sp.plot(signal_xt, (t,0,2), \n        xlabel='$t/T$',\n        ylabel='$F(t) / A$',\n        size=(5.9,2),show=False)\n\np_1.show()\n\n\n\n\nAbbildung 9.2: Rechteckige Anregungsfunktion"
  },
  {
    "objectID": "ems_06.html#musterlösung",
    "href": "ems_06.html#musterlösung",
    "title": "9  Beispiel: Fourier-Transformation",
    "section": "9.2 Musterlösung",
    "text": "9.2 Musterlösung\n\n9.2.1 Erregerfunktion\nDie periodische Erregerfunktion wird mit einer Fourier-Reihenentwicklung approximiert um eine periodische, harmonische Funktion zu generieren.\nDie Reihenentwicklung folgt folgender Funktion:\n\\[\nF(t) = A_0 + \\sum_{n=1}^{\\infty}(a_n\\cdot \\cos{(n\\omega t)}+b_n \\cdot \\sin{(n\\omega t)})\n\\tag{9.1}\\]\nDie Aufgabenstellung fordert lediglich die ersten drei Teile der Reihe.\n\\[\nF(t) = A_0 + \\sum_{n=1}^{3}(a_n \\cdot \\cos{(n\\omega t)}+b_n \\cdot \\sin{(n\\omega t)})\n\\tag{9.2}\\]\nNach Bestimmung der Konstanten folgt die Gleichung zu:\n\\[\nF(t) = \\frac{4A}{\\pi} \\cdot [\\sin(\\omega t) + \\frac{1}{3}\\sin(3\\omega t) + \\frac{1}{5}\\sin(5 \\omega t)]\n\\tag{9.3}\\]\n\nf_Anregung = 1/unit.seconds\nomega = f_Anregung * 2*sp.pi\n\nF_t = 4*A/ sp.pi * (sp.sin(omega*t)+sp.Rational(1,3)*sp.sin(3*omega *t)+ sp.Rational(1,5)*sp.sin(5*omega*t))\n\n\nrender.eq_display('f_Anregung', f_Anregung,\n                  'omega', omega.subs(params).evalf(3),\n                  'F(t)', F_t)\n\n\\[\\begin{equation}f_{Anregung} = \\frac{1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega = \\frac{6.28}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}F{\\left(t \\right)} = \\frac{4 A \\left(\\sin{\\left(\\frac{2 \\pi t}{\\text{s}} \\right)} + \\frac{\\sin{\\left(\\frac{6 \\pi t}{\\text{s}} \\right)}}{3} + \\frac{\\sin{\\left(\\frac{10 \\pi t}{\\text{s}} \\right)}}{5}\\right)}{\\pi}\\end{equation}\\]\n\n\n\n\n#| label: fig-ems-fourier_anregung_fourier\n#| fig-cap: \"Anregungsfunktion mit Fourier-Reihe approximiert\"\nparams_plot = convert.param_value(params)\n\nF_t_plot = F_t.subs(params_plot).subs(unit.second, 1)\n\nplot_fourier = sp.plot(F_t_plot, (t,0,2), adaptive=False, nb_of_points=500,\n        xlabel='$t [s]$',\n        ylabel='$F(t)$ [N]',\n        size=(5.9,2))\n\n\n\n\n\n\n\n9.2.2 Systemsteifigkeit\nAnhand der Arbeitsgleichung wird die Deformation bestimmt und daraus die Steifigkeit des Systems. Auf die Bestimmung der Schnittgrössen wird nicht eingegangen. Es handelt sich um ein statisch unbestimmtes System.\n\n\n\nAbbildung 9.3: Schnittgrössen des unterspannten Balkens\n\n\n\n\n\nAbbildung 9.4: Virtuelle Schnittgrössen des unterspannten Balkens\n\n\nDa der Balken dehnstarr ist und die Unterspannung aus Pendelstäben zusammengesetzt ist, sind Anteile aus Normalkraft aus den Pendelstäben und lediglich Anteile aus Biegung im Balken für die Deformation zuständig.\n\nu_for_k_balken = 1/3 * 0.163*10**6*unit.N*unit.mm * 0.163 *unit.m* 2*l / (E*I_Balken) \nu_for_k_fachwerk = (1*-0.935*10**3*unit.N*-0.935 * h + 2*1.258*10**3*unit.N*1.258*sp.sqrt(h**2+l**2))/(E*A_Fachwerk)\n\nu_for_k = u_for_k_balken + u_for_k_fachwerk\nk = 1000*unit.N / u_for_k\n\nrender.eq_display('u_k', unit.convert_to(u_for_k.subs(params).simplify().evalf(3),unit.mm),\n                  'k', k.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{k} = 0.0335 \\text{mm}\\end{equation}\\]\n\n\n\\[\\begin{equation}k = \\frac{2.98 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n9.2.3 Eigenkreisfrequenz\nAus der Systemsteifigkeit lässt sich leicht die Eigenkreisfrequenz bestimmen:\n\\[\n\\omega_n =\\sqrt{\\frac{k}{m}}\n\\tag{9.4}\\]\n\nomega_n = sp.sqrt(k/m_)\n\nrender.eq_display('omega_n', omega_n.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{n} = \\frac{173.0}{\\text{s}}\\end{equation}\\]\n\n\n\n\n9.2.4 Stationäre Amplitude der Verschiebung\nDie statische Durchbiegung lässt sich anhand der Systemsteifigkeit und der Anfangskraft der Anregungsfunktion bestimmen. Mittels des Vergrösserungsfaktors lässt sich schlussendlich die stationäre maximale Amplitude bestimmen. Der Vergrösserungsfaktor ist abhängig von der Anregungsfrequenz, welche wir mit der Fourier-Reihenentwicklung approximiert haben. Wir haben folglich “3 verschiedene” Anregungsfrequenzen mit der entsprechenden Gewichtung.\n\nu_0 = 4*A/sp.pi /k\n\nV_omega = 1/(sp.sqrt((1-(omega/omega_n)**2)**2 + (2*zeta*(omega/omega_n))**2)) + 1/(sp.sqrt((1-(3*omega/omega_n)**2)**2 + (2*zeta*(3*omega/omega_n))**2))/3 + 1/(sp.sqrt((1-(5*omega/omega_n)**2)**2 + (2*zeta*(5*omega/omega_n))**2))/5\n\n\nrender.eq_display('V(omega)', '1/(sqrt((1-(omega/omega_n)**2)**2 + (2*zeta_*(omega/omega_n))**2)) + 1/(sqrt((1-(3*omega/omega_n)**2)**2 + (2*zeta_*(3*omega/omega_n))**2))/3 + 1/(sqrt((1-(5*omega/omega_n)**2)**2 + (2*zeta_*(5*omega/omega_n))**2))/5',\n                  'V(omega)', V_omega.subs(params).simplify().evalf(3))\n\nu_stat = u_0 * V_omega\n\nrender.eq_display('u_0', unit.convert_to(u_0.subs(params).simplify().evalf(3),\n unit.mm),\n 'u_stat', unit.convert_to(u_stat.subs(params).simplify().evalf(3), unit.mm))\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = \\frac{1}{5 \\sqrt{\\frac{100 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{25 \\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}} + \\frac{1}{3 \\sqrt{\\frac{36 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{9 \\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}} + \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = 1.55\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{0} = 0.0427 \\text{mm}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{stat} = 0.066 \\text{mm}\\end{equation}\\]\n\n\nDer Vergrösserungsfaktor ist erwartungsgemäss niedrig, da sich die Eigenkreisfrequenz deutlich von der Anregungsfrequenz abgrenzt.\n\n\n9.2.5 Stationäre Amplitude der Beschleunigung\nDie Beschleunigung lässt sich ebenfalls anhand des Vergrösserungsfaktors bestimmen. Dies Entspricht dem Vorgehen nach Michael Baur.\n\nV_a_omega = omega**2 / omega_n**2 * V_omega\n\nu_2_max =  4*A/sp.pi / m_ * V_a_omega\n\nrender.eq_display('V_a(omega)', V_a_omega.subs(params).simplify().evalf(3),'Derivative(u_max,t,2)', u_2_max.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V_{a}{\\left(\\omega \\right)} = 0.00205\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d t^{2}} u_{max} = \\frac{0.0026 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\nMeines Erachtens müsste der Vergrösserungsfaktor für die Beschleunigung ebenfalls mit sämtlichen, gewichteten Anregungsfrequenzen der approximierten Anregungsfunktion bestimmt werden.\n\nV_a_omega = ((omega**2 / omega_n**2)+1/3*(3*omega**2 / omega_n**2)+1/5*(5*omega**2 / omega_n**2))*V_omega\n\nu_2_max =  4*A/sp.pi / m_ * V_a_omega\n\nrender.eq_display('V_a(omega)', V_a_omega.subs(params).simplify().evalf(3),'Derivative(u_max,t,2)', u_2_max.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V_{a}{\\left(\\omega \\right)} = 0.00614\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d t^{2}} u_{max} = \\frac{0.00781 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]"
  },
  {
    "objectID": "ems_07.html#aufgabenstellung",
    "href": "ems_07.html#aufgabenstellung",
    "title": "10  Beispiel: Balken ohne Tilger{#sec-ems_untilg}",
    "section": "10.1 Aufgabenstellung",
    "text": "10.1 Aufgabenstellung\nEin einfacher Balken mit einer Einzelmasse, welcher in dieser Aufgabe ohne Tilger ausgestattet ist, ist in Abbildung 10.1 dargestellt. Die Masse erfährt eine dynamische Einwirkung durch die Funktion \\(F(t)\\). Das Beispiel wird in ?sec-tilger weitergeführt.\n\n\n\nAbbildung 10.1: Statisches System des Balkens ohne Tilger\n\n\nGesucht:\n\nMaximale dynamische Verformung mittels stationärer Lösung\nMaximale dynamische Beschleunigung mittels stationärer Lösung\n\nGegeben:\n\nE, I, M_H, zeta,  L, F_0, omega, delta_11, delta_12 = sp.symbols('E, I, M_H, zeta, L , F_0, omega, delta_11, delta_12')\n\nt = sp.symbols('t')\n\n\nparams = {E: 200*10**3 *unit.N/unit.mm**2,\n          I:2*10**8*unit.mm**4,\n          M_H:2000*unit.N*unit.second**2/unit.m,\n          L:5*unit.m,\n          F_0:0.8*10**3*unit.N,\n          omega:12.6/unit.second,\n          zeta:0.0         \n          }\n\nrender.dict_to_table(params)\n\n\n\nTabelle 10.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(E = \\frac{200000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(F_{0} = 800.0 \\text{N}\\)\n\n\n\\(I = 200000000 \\text{mm}^{4}\\)\n\\(L = 5 \\text{m}\\)\n\n\n\\(M_{H} = \\frac{2000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(\\omega = \\frac{12.6}{\\text{s}}\\)\n\n\n\\(\\zeta = 0.0\\)\n\n\n\n\n\n\n\n\\[\nF(t) = F_0 \\cdot \\sin(\\omega\\cdot t) = 0.8 \\text{kN} \\cdot (12.6 \\frac{\\text{rad}}{\\text{s}}\\cdot t)\n\\]"
  },
  {
    "objectID": "ems_07.html#musterlösung",
    "href": "ems_07.html#musterlösung",
    "title": "10  Beispiel: Balken ohne Tilger{#sec-ems_untilg}",
    "section": "10.2 Musterlösung",
    "text": "10.2 Musterlösung\n\nF_t = F_0 * sp.sin(omega*t)\n\n\n10.2.1 Steifigkeit \\(k\\)\nZuerst wird die Steifigkeit des Systems ermittelt, für einen Einmassenschwinger entspricht diese der Biegesteifigkeit des Balkens.\n\nk_H = 48 * (E*I) / (2*L)**3\n\n\nrender.eq_display('k_H', k_H,\n                  'k_H',k_H.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}k_{H} = \\frac{6 E I}{L^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{H} = \\frac{1.92 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n10.2.2 Eigenkreisfrequenz \\(\\omega\\)\nDie Eigenkreisfrequenz kann mit der bekannten Formel ermittelt werden:\n\nomega_n = sp.sqrt(k_H / M_H)\n\nrender.eq_display('omega_n', \"sqrt(k/m)\",\n                  'omega_n', omega_n,\n                  'omega_n', omega_n.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{n} = \\sqrt{\\frac{k}{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\sqrt{6} \\sqrt{\\frac{E I}{L^{3} M_{H}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{n} = \\frac{31.0}{\\text{s}}\\end{equation}\\]\n\n\n\n\n10.2.3 Vergrösserungsfaktor \\(V(\\omega)\\)\nDa lediglich die Stationäre Antwort von Interesse ist, kann mittels Vergrösserungsfaktor diese ermittelt werden. Der Verlauf entspricht der Anregungsfunktion. Die Amplitude definiert sich aus der statischen Deformation mit dem Vergrösserungsfaktor multipliziert.\n\nV_omega = 1/(sp.sqrt((1-(omega/omega_n)**2)**2 + (2*zeta*(omega/omega_n))**2))\n\nrender.eq_display('V(omega)', '1/(sqrt((1-(omega/omega_n)**2)**2 + (2*zeta_*(omega/omega_n))**2))',\n                  'V(omega)', V_omega.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{n}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{n}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V{\\left(\\omega \\right)} = 1.2\\end{equation}\\]\n\n\n\n\n10.2.4 Stationäre Lösung\n\n10.2.4.1 Statische Deformation\n\nu_0 = F_0 / k_H\n\nrender.eq_display('u_0', 'F_0 / k_H',\n                  'u_0', u_0,\n                  'u_0', unit.convert_to(u_0.subs(params).simplify().evalf(4), unit.mm))\n\n\\[\\begin{equation}u_{0} = \\frac{F_{0}}{k_{H}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{0} = \\frac{F_{0} L^{3}}{6 E I}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{0} = 0.4167 \\text{mm}\\end{equation}\\]\n\n\n\n\n10.2.4.2 Stationäre maximale Deformation\n\nu_stat = u_0 * V_omega\n\nrender.eq_display('u_stat', 'u_0 * V(omega)',\n                  'u_stat', u_stat,\n                  'u_stat', unit.convert_to(u_stat.subs(params).simplify().evalf(3), unit.mm))\n\n\\[\\begin{equation}u_{stat} = u_{0} V{\\left(\\omega \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{stat} = \\frac{F_{0} L^{3}}{6 E I \\sqrt{\\left(1 - \\frac{L^{3} M_{H} \\omega^{2}}{6 E I}\\right)^{2} + \\frac{2 L^{3} M_{H} \\omega^{2} \\zeta^{2}}{3 E I}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{stat} = 0.499 \\text{mm}\\end{equation}\\]\n\n\n\n\n10.2.4.3 Stationäre maximale Beschleunigung\n\nV_a_omega = omega**2 / omega_n**2 * V_omega\n\nu_2_stat =  F_0 / M_H * V_a_omega\n\nrender.eq_display('V_a(omega)', \"omega**2 / omega_n**2 * V_omega\",\n                  'V_a(omega)', V_a_omega.subs(params).simplify().evalf(3),\n                  'Derivative(u_stat,t,2)', u_2_stat.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V_{a}{\\left(\\omega \\right)} = \\frac{V_{\\omega} \\omega^{2}}{\\omega_{n}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{a}{\\left(\\omega \\right)} = 0.198\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d t^{2}} u_{stat} = \\frac{0.0793 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\nu_t = u_stat * sp.sin(omega*t)\n\nparams_plot = convert.param_value(params)\n\nu_t_plot = u_t.subs(params_plot).subs(unit.second, 1)*1000\n\np_1 = sp.plot(u_t_plot, (t,0,6), adaptive=False, nb_of_points=500, \n        xlabel='$t [s]$',\n        ylabel='$u(t)$ [mm]',\n        size=(5.9,3),show=False,  label='Stationärer Anteil', line_color='0.8')\n\n\np_1.show()\n\n\n\n\nAbbildung 10.2: Stationäre Antwort des Systems"
  },
  {
    "objectID": "mms_02.html#aufgabenstellung",
    "href": "mms_02.html#aufgabenstellung",
    "title": "11  Beispiel: Eigenvektoren mit direkt bestimmter Steifigkeitsmatrix{#sec-mms_steif}",
    "section": "11.1 Aufgabenstellung",
    "text": "11.1 Aufgabenstellung\nDas System in Abbildung 11.1 zeigt ein Rahmentragwerk, welches als Zweimassenschwinger modelliert werden kann.\n\n\n\nAbbildung 11.1: Statisches System des Rahmentragwerks\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega\\)\nEigenformen - Normierung auf \\[\\phi_1^T =\n\\begin{bmatrix}\n&  1\\\\\n\\end{bmatrix} \\] \\[\\phi_2^T =\n\\begin{bmatrix}\n&  1\\\\\n\\end{bmatrix}\\]\nSkizze der Eigenformen\n\nGegeben:\n\nDehnsteifigkeit aller Stäbe \\(E\\cdot A = \\infty\\)\n\n\nomega, t,  E,I, H = sp.symbols('omega, t,  E, I, H')\nm_1, m_2 = sp.symbols('m_1, m_2')\nk_1, k_2 = sp.symbols('k_1, k_2')\n\nomega_n = sp.symbols('omega_n')\n\n\nparams = {E: 30*10**3 *unit.N/unit.mm**2,\n          I:2*10**9*unit.mm**4,\n          m_1:2*20000*unit.N*unit.second**2/unit.m,\n          m_2:20000*unit.N*unit.second**2/unit.m,\n          H:3.2*unit.m,\n          }\n\n\nrender.dict_to_table(params)\n\n\n\nTabelle 11.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(E = \\frac{30000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(H = 3.2 \\text{m}\\)\n\n\n\\(I = 2000000000 \\text{mm}^{4}\\)\n\\(m_{1} = \\frac{40000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\n\n\\(m_{2} = \\frac{20000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)"
  },
  {
    "objectID": "mms_02.html#sec-mms_steif_ML",
    "href": "mms_02.html#sec-mms_steif_ML",
    "title": "11  Beispiel: Eigenvektoren mit direkt bestimmter Steifigkeitsmatrix{#sec-mms_steif}",
    "section": "11.2 Musterlösung",
    "text": "11.2 Musterlösung\n\n11.2.1 Eigenkreisfrequenzen\n\n11.2.1.1 Steifigkeitsmatrix \\(\\mathbf{K}\\)\nZur Bestimmung der Steifigkeitsmatrix ist das System an jedem Freiheitsgrad auszulenken, wie in Abbildung 11.2 dargestellt ist.\n\n\n\nAbbildung 11.2: Auslenkung der Freiheitsgrade zur Bestimmung der Steifigkeit\n\n\nWichtig dabei sind die Richtungen der Kräfte. Als Denkstütze gilt folgendes:\n\nDer Auslenkung um \\(u\\) wirkt die Federkraft entgegen, welche \\(k u\\) entspricht.\nZusätzlich wirkt die Trägheitskraft der Auslenkung entgegen, welche \\(m u''\\) entspricht.\nNach der Betrachtung des ausgelenkten Punkts, kann mittels Actio-Reactio-Prinzip das “Stockwerk” ins Gleichgewicht gebracht werden.\nVorzeichen sind gegen der Bewegungsrichtig positiv.\n\n\n\n11.2.1.2 Horizontale Steifigkeit\nFür entsprechende Anwendungsfälle gibt es fertige Lösungen zur Bestimmung der Steifigkeit. Gemäss Abbildung 11.1 ist die Stütze am Fuss- und Kopfpunkt eingespannt. Somit resultiert die Steifigkeit zu:\n\\[\nk_{Stuetze} = \\frac{12EI_{Stuetze}}{H^3}\n\\tag{11.1}\\]\nDiese gilt für eine einzelne Stütze. Eingesetzt in die Steifigkeitsmatrix:\n\n\nparams['k_1'] = 2*(12 * 2*E*I / H**3).subs(params).simplify().evalf(6)\nparams['k_2'] = 2*(12 * E*I / H**3).subs(params).simplify().evalf(6)\nK = sp.Matrix([[k_1 + k_2, -k_2],[-k_2, k_2]])\n\n\nrender.eq_display('k_1', 2*(12 * 2*E*I / H**3),\n                  'k_2', 2*(12 * E*I / H**3),\n                  sp.MatrixSymbol('K', 2,2), K,\n                  sp.MatrixSymbol('K', 2,2), K.subs(params),\n                  )\n\n\\[\\begin{equation}k_{1} = \\frac{48 E I}{H^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2} = \\frac{24 E I}{H^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}k_{1} + k_{2} & - k_{2}\\\\- k_{2} & k_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{1.31836 \\cdot 10^{8} \\text{N}}{\\text{m}} & - \\frac{4.39453 \\cdot 10^{7} \\text{N}}{\\text{m}}\\\\- \\frac{4.39453 \\cdot 10^{7} \\text{N}}{\\text{m}} & \\frac{4.39453 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n11.2.2 Eigenvektoren\n\n11.2.2.1 Massenmatrix \\(\\mathbf{M}\\)\nDie Massenmatrix folgt dem gleichen Aufbau wie die Steifigkeitsmatrix. Es gelten die gleichen Vorzeichenregelungen.\n\nM = sp.Matrix([[m_1, 0],[0, m_2]])\n\nrender.eq_display(sp.MatrixSymbol('M', 2,2), M,\n                  sp.MatrixSymbol('M', 2,2), M.subs(params))\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{1} & 0\\\\0 & m_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}\\frac{40000 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{20000 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n11.2.2.2 Eigenkreisfrequenzen\nBei einem Mehrmassenschwinger gibt es entsprechend den Freiheitsgraden Eigenkreisfrequenzen \\(\\omega_n\\). Diese lassen sich anhand folgender Gleichung bestimmen:\n\\[\\det{[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]=0}\\]\n\neq_omega = sp.det(K-omega_n**2*M)\n\nomega_n_solve = sp.solve(eq_omega, omega_n)\nomega_1 = omega_n_solve[1]\nomega_2 = omega_n_solve[3]\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{33.1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{66.3}{\\text{s}}\\end{equation}\\]\n\n\n\n\n11.2.2.3 Eigenvektoren \\(\\phi\\)\n\nphi_11, phi_21, phi_12, phi_22 = sp.symbols('phi_11, phi_21, phi_12, phi_22')\nparams['phi_21'] = 1\n\nphi_1 = sp.Matrix([[phi_11], [phi_21]])\n\nphi_11 = list(sp.solve((K-omega_1**2 *M)*phi_1, phi_11).values())[0]\n\nparams['phi_11'] = phi_11.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.simplify((K-omega_1**2 *M)*phi_1),sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_1', 2,1),sp.simplify(phi_1.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{- k_{2} m_{2} \\phi_{21} + \\frac{\\phi_{11} \\left(- k_{2} m_{1} + m_{2} \\left(k_{1} + k_{2}\\right) + \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{2}}\\\\\\frac{- k_{2} m_{1} \\phi_{11} + \\frac{\\phi_{21} \\left(k_{2} m_{1} - m_{2} \\left(k_{1} + k_{2}\\right) + \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{1}}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0.5\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nparams['phi_22'] = 1\n\nphi_2 = sp.Matrix([[phi_12], [phi_22]])\n\nphi_12 = list(sp.solve((K-omega_2**2 *M)*phi_2, phi_12).values())[0]\n\nparams['phi_12'] = phi_12.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.simplify((K-omega_2**2 *M)*phi_2),sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_2', 2,1),sp.simplify(phi_2.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{- k_{2} m_{2} \\phi_{22} + \\frac{\\phi_{12} \\left(- k_{2} m_{1} + m_{2} \\left(k_{1} + k_{2}\\right) - \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{2}}\\\\\\frac{- k_{2} m_{1} \\phi_{12} + \\frac{\\phi_{22} \\left(k_{2} m_{1} - m_{2} \\left(k_{1} + k_{2}\\right) - \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{1}}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2} = \\left[\\begin{matrix}-1.0\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n11.2.2.4 Orthogonalitätsbedingung\nZur Entkoppelung des Systems wird die Orthogonalität der Eigenvektoren kontrolliert. Siehe Kapitel 12.2.2.4 für eine ausführliche Erklärung.\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_2.T*M*phi_1).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*M*phi_2).subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{3.0 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{6.0 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\nFür die Steifigkeitsmatrix:\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_1.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_2.T*K*phi_2).subs(params)).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_2.T*K*phi_1).subs(params)).evalf(4),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_1.T*K*phi_2).subs(params)).evalf(4))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{3.3 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{2.64 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n11.2.3 Eigenformen\n\n\n\nAbbildung 11.3: Die beiden Eigenformen skizziert"
  },
  {
    "objectID": "mms_01.html#aufgabenstellung",
    "href": "mms_01.html#aufgabenstellung",
    "title": "12  Beispiel: Eigenvektoren und Nachgiebigkeitsmatrix",
    "section": "12.1 Aufgabenstellung",
    "text": "12.1 Aufgabenstellung\nDas System in Abbildung 12.1 zeigt einen Rahmen, welcher als Zweimassenschwinger modelliert werden kann.\n\n\n\nAbbildung 12.1: Statisches System des 2-Massenschwingers\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega\\)\nEigenformen - Normierung auf \\[\\phi_1^T =\n\\begin{bmatrix}\n1 &  \\\\\n\\end{bmatrix} \\] \\[\\phi_2^T =\n\\begin{bmatrix}\n& 1 \\\\\n\\end{bmatrix}\\]\nSkizze der Eigenformen\nKontrolle der Orthogonalitätsbedingung\n\nGegeben:\n\nDehnsteifigkeit aller Stäbe \\(E\\cdot A = \\infty\\)\n\n\nomega, t,  L, m_1, m_2, EI = sp.symbols('omega, t,  L, m_1, m_2, EI')\n\nomega_n = sp.symbols('omega_n')\n\n\nparams = {EI: 20*10**12 *unit.N*unit.mm**2,\n          m_1:1000*unit.N*unit.second**2/unit.m,\n          m_2:1000*unit.N*unit.second**2/unit.m,\n          L:4*unit.m,\n          }\n\n          \nrender.dict_to_table(params)\n\n\n\nTabelle 12.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(EI = 20000000000000 \\text{mm}^{2} \\text{N}\\)\n\\(L = 4 \\text{m}\\)\n\n\n\\(m_{1} = \\frac{1000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(m_{2} = \\frac{1000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)"
  },
  {
    "objectID": "mms_01.html#musterlösung",
    "href": "mms_01.html#musterlösung",
    "title": "12  Beispiel: Eigenvektoren und Nachgiebigkeitsmatrix",
    "section": "12.2 Musterlösung",
    "text": "12.2 Musterlösung\n\n12.2.1 Nachgiebigkeitsmatrix \\(\\mathbf{D}\\)\nDie Steifigkeitsmatrix lässt sich durch Invertierung der Nachgiebigkeitsmatrix beschreiben. Die Nachgiebigkeitsmatrix \\(\\mathbf{D}\\) beschreibt die Deformation an einem Massenpunkt. Die Einträge der \\(\\mathbf{D}\\) - Matrix beschreiben die Deformationen für unterschiedliche Laststellungen.\n\\[\n\\mathbf{K} = \\mathbf{D^{-1}}\n\\tag{12.1}\\]\n\n\n\nAbbildung 12.2: Balken mit 2 Einzelmassen\n\n\nFür einen 2-Massenschwinger, wie in Abbildung 12.2 , hat die Nachgiebigkeitsmatrix folgende Form:\n\\[\n\\mathbf{D} = \\frac{1}{EI}\\cdot \\begin{bmatrix}\n\\delta_{11} & \\delta_{12}\\\\\n\\delta_{21} & \\delta_{22}\n\\end{bmatrix}\n\\tag{12.2}\\]\nwobei gilt:\n\\(\\delta_{ab}\\) : \\(a\\) ist die Lastsituation, \\(b\\) ist die Masse.\n\n12.2.1.1 Anwendung\n\n\n\nAbbildung 12.3: Schnittgrössen für den ersten Lastfall zur Bestimmung der Deformation\n\n\n\\[\n\\delta_{ab} = \\frac{1}{EI}\\int_{0}^{L} M_a\\bar{M_b} \\,dx\n\\tag{12.3}\\]\nEs werden 2 Laststellungen betrachtet, jeweils an einem Massenpunkt. Dabei ist Beachtung der Einheit der Einwirkung zu schenken. Diese wird einheitslos angesetzt.\n\n\n\nAbbildung 12.4: Schnittgrössen für den zweiten Lastfall zur Bestimmung der Deformation\n\n\n\ndelta_11 = 1/(EI) * (sp.Rational(1,3) * -L*-L*1*L)* 2\ndelta_12 = 1/(EI) * ((sp.Rational(1,3) * -L*-L*1*L) + (sp.Rational(1,2) * -L*-L*1*L))\ndelta_21 = delta_12\ndelta_22 = 1/(EI) * ((sp.Rational(1,3) * -L*-L*1*L)* 2 + -L*-L*1*L)\n\nrender.eq_display('delta_11', delta_11,\n                  'delta_12', delta_12,\n                  'delta_21', delta_21,\n                  'delta_22', delta_22)\n\n\\[\\begin{equation}\\delta_{11} = \\frac{2 L^{3}}{3 EI}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{12} = \\frac{5 L^{3}}{6 EI}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{21} = \\frac{5 L^{3}}{6 EI}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{22} = \\frac{5 L^{3}}{3 EI}\\end{equation}\\]\n\n\n\nD = sp.Matrix([[delta_11, delta_12],[delta_21, delta_22]])\nK = D.inv()\nrender.eq_display(sp.MatrixSymbol('D', 2,2), D,\n                  sp.MatrixSymbol('K', 2,2), K)\n\n\\[\\begin{equation}\\mathbf{D} = \\left[\\begin{matrix}\\frac{2 L^{3}}{3 EI} & \\frac{5 L^{3}}{6 EI}\\\\\\frac{5 L^{3}}{6 EI} & \\frac{5 L^{3}}{3 EI}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{4 EI}{L^{3}} & - \\frac{2 EI}{L^{3}}\\\\- \\frac{2 EI}{L^{3}} & \\frac{8 EI}{5 L^{3}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n12.2.2 Eigenvektoren\nDie Bewegungsgleichung für einen ungedämpften, frei schwingenden Mehrmassenschwinger lässt sich folgender massen aufstellen:\n\\[\n\\mathbf{M u''(t) + K u(t)} = 0\n\\tag{12.4}\\]\nDie Modale Analyse entkoppelt die Gleichungen, um diese unabhängig voneinander zu lösen.\n\n12.2.2.1 Massenmatrix \\(\\mathbf{M}\\)\n\nM = sp.Matrix([[m_1,0],[0,m_2]])\n\nrender.eq_display(sp.MatrixSymbol('M',2,2), M)\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{1} & 0\\\\0 & m_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n12.2.2.2 Eigenkreisfrequenzen\nBei einem Mehrmassenschwinger gibt es entsprechend den Freiheitsgraden Eigenkreisfrequenzen \\(\\omega_n\\). Diese lassen sich anhand Gleichung 12.5 bestimmen:\n\\[\n\\det{[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]=0}\n\\tag{12.5}\\]\n\neq_omega = sp.det(K-omega_n**2*M)\n\nomega_n_solve = sp.solve(eq_omega, omega_n)\nomega_1 = omega_n_solve[1]\nomega_2 = omega_n_solve[3]\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{12.1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{40.0}{\\text{s}}\\end{equation}\\]\n\n\n\n\n12.2.2.3 Eigenvektoren \\(\\phi\\)\n\\[\n\\phi_n = \\begin{bmatrix}\n\\phi_{1n}\\\\\n\\phi_{2n}\n\\end{bmatrix}\n\\tag{12.6}\\]\n\\[\n[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]\\cdot \\begin{bmatrix}\n\\phi_{1n}\\\\\n\\phi_{2n}\n\\end{bmatrix}\n=0\n\\tag{12.7}\\]\nDazu ist die entsprechende Normierung aus der Aufgabenstellung zu berücksichtigen. Generell gilt, den Vektor auf den Maximalwert zu normieren, bzw. diesen auf 1 zu setzen.\n\nphi_11, phi_21, phi_12, phi_22 = sp.symbols('phi_11, phi_21, phi_12, phi_22')\nparams['phi_21'] = 1\n\nphi_1 = sp.Matrix([[phi_11], [phi_21]])\n\nphi_11 = list(sp.solve((K-omega_1**2 *M)*phi_1, phi_11).values())[0]\n\nparams['phi_11'] = phi_11.subs(params).simplify() \n\n\n\n\nrender.eq_display((K-omega_1**2 *M)*phi_1,sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_1', 2,1),sp.simplify(phi_1.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}- \\frac{2 EI \\phi_{21}}{L^{3}} + \\phi_{11} \\cdot \\left(\\frac{4 EI}{L^{3}} - m_{1} \\cdot \\left(\\frac{4 EI}{5 L^{3} m_{2}} + \\frac{2 EI}{L^{3} m_{1}} - \\frac{2 EI \\sqrt{4 m_{1}^{2} + 5 m_{1} m_{2} + 25 m_{2}^{2}}}{5 L^{3} m_{1} m_{2}}\\right)\\right)\\\\- \\frac{2 EI \\phi_{11}}{L^{3}} + \\phi_{21} \\cdot \\left(\\frac{8 EI}{5 L^{3}} - m_{2} \\cdot \\left(\\frac{4 EI}{5 L^{3} m_{2}} + \\frac{2 EI}{L^{3} m_{1}} - \\frac{2 EI \\sqrt{4 m_{1}^{2} + 5 m_{1} m_{2} + 25 m_{2}^{2}}}{5 L^{3} m_{1} m_{2}}\\right)\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0.566\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nparams['phi_12'] = 1\n\nphi_2 = sp.Matrix([[phi_12], [phi_22]])\n\nphi_22 = list(sp.solve((K-omega_2**2 *M)*phi_2, phi_22).values())[0]\n\nparams['phi_22'] = phi_22.subs(params).simplify() \n\n\n\n\nrender.eq_display((K-omega_2**2 *M)*phi_2,sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_2', 2,1),sp.simplify(phi_2.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}- \\frac{2 EI \\phi_{22}}{L^{3}} + \\phi_{12} \\cdot \\left(\\frac{4 EI}{L^{3}} - m_{1} \\cdot \\left(\\frac{4 EI}{5 L^{3} m_{2}} + \\frac{2 EI}{L^{3} m_{1}} + \\frac{2 EI \\sqrt{4 m_{1}^{2} + 5 m_{1} m_{2} + 25 m_{2}^{2}}}{5 L^{3} m_{1} m_{2}}\\right)\\right)\\\\- \\frac{2 EI \\phi_{12}}{L^{3}} + \\phi_{22} \\cdot \\left(\\frac{8 EI}{5 L^{3}} - m_{2} \\cdot \\left(\\frac{4 EI}{5 L^{3} m_{2}} + \\frac{2 EI}{L^{3} m_{1}} + \\frac{2 EI \\sqrt{4 m_{1}^{2} + 5 m_{1} m_{2} + 25 m_{2}^{2}}}{5 L^{3} m_{1} m_{2}}\\right)\\right)\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2} = \\left[\\begin{matrix}1.0\\\\-0.566\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n12.2.2.4 Orthogonalitätsbedingung\nUm eine modale Analyse des Systems durchzuführen, gilt es die Orthogonalität der Eigenvektoren zu gewährleisten. Die Modale Analyse wird in folgenden Beispielen, wie in ?sec-tilger, angewendet.\nDies gilt es für die Massenmatrix zu kontrollieren:\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_2.T*M*phi_1).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*M*phi_2).subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{1.32 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{1.32 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\nSowohl auch für die Steifigkeitsmatrix:\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_1.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_2.T*K*phi_2).subs(params)).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_2.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_1.T*K*phi_2).subs(params)).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{1.93 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{2.12 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\nDie Orthogonalitätsbedingung ist erfüllt!\nZur effektiven Entkoppelung der Gleichungen muss die Orthogonalitätsbedingung eingehalten sein. Durch die Orthogonalität der Vektoren \\(\\phi_1\\) und \\(\\phi_2\\) kann mittels einem Einmassenschwingers sämtliches Verhalten von \\(\\phi_1\\) beschrieben werden und mittels einem zweiten Einmassenschwinger sämtliches Verhalten von \\(\\phi_2\\). Ist die Orthogonalität nicht gegeben, so müsste der erste Einmassenschwinger Anteile aus \\(\\phi_1\\) und \\(\\phi_2\\) beschreiben.\n\nphi_1_x = [0,phi_1.subs(params)[0]]\nphi_1_y = [0,phi_1.subs(params)[1]]\n\nphi_2_x = [0,phi_2.subs(params)[0]]\nphi_2_y = [0,phi_2.subs(params)[1]]\n\n\n# Define the vector\nvector_phi_1 = np.array(phi_1.T.subs(params)).astype(np.float64)[0]\nvector_phi_2 = np.array(phi_2.T.subs(params)).astype(np.float64)[0]\n\n# Create a quiver plot\nfig, ax = plt.subplots()\nax.quiver(0, 0, vector_phi_1[0], vector_phi_1[1], angles='xy', scale_units='xy', scale=1, color='green', label='$\\phi_1$')\nax.quiver(0, 0, vector_phi_2[0], vector_phi_2[1], angles='xy', scale_units='xy', scale=1, color='orange', label='$\\phi_2$')\n\n# Set the axis limits\nax.set_xlim([-0.1, 1.1])\nax.set_ylim([-1.1, 1.1])\n\nax.set_aspect('equal')\nax.set_xlabel('X')\nax.set_ylabel('Y')\nplt.legend()\nplt.show()\n\n\n## Zweiter Plot\n\n# rotatet orthogonal vectors\nv1 = np.array([0,1])\nv2 = np.array([1,0])\n\n# Define the non-orthogonal vectors\nu1 = np.array([1., 0.5])\n\n# Create a quiver plot\nfig, ax = plt.subplots()\nax.quiver(0, 0, u1[0], u1[1], angles='xy', scale_units='xy', scale=1, color='red', label='$\\phi_n \\\\not \\\\perp \\phi_2$')\nax.quiver(0, 0, v2[0], v2[1], angles='xy', scale_units='xy', scale=1, color='orange', label='$\\phi_2$')\nax.quiver(v2[0], v2[1], 0, u1[1], angles='xy', scale_units='xy', scale=1, color='blue', label='$\\phi_{n,2}$')\n\n\n# Add lines to show the decomposition of the non-orthogonal vector\n\n\n\n\n# Set the axis limits\nax.set_xlim([-0.1, 1.1])\nax.set_ylim([-1.1, 1.1])\n\nax.set_aspect('equal')\nax.set_xlabel('X')\nax.set_ylabel('Y')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n(a) Erfüllte Orthogonalitätsbedingung\n\n\n\n\n\n\n\n(b) Nicht erfüllte Orthogonalitätsbedingung\n\n\n\n\nAbbildung 12.5: Visualisierung des Einflusses der Orthogonalität der Eigenvektoren\n\n\n\nWie in Abbildung 12.5 dargestellt, wird der rote Vektor \\(\\phi_n\\) durch den orangenen Vektor \\(\\phi_2\\) beschrieben, sowie durch seine \\(Y\\) Komponente \\(\\phi_{n,2}\\). Folglich steht \\(\\phi_n\\) nicht orthogonal auf \\(\\phi_2\\) und lässt sich nicht ohne \\(\\phi_2\\) beschreiben. Die Entkoppelung ist nicht möglich.\nNebenbei, dies lässt sich für einen zweidimensionalen Fall, sprich Zweimassenschwinger darstellen. Das Verfahren kann auf beliebig viele Dimensionen erweitert werden, die Darstellung dieser ist jedoch nicht mehr möglich.\n\n\n\n12.2.3 Eigenformen\n\n\n\nAbbildung 12.6: Die beiden Eigenform skizziert"
  },
  {
    "objectID": "mms_03.html#aufgabenstellung",
    "href": "mms_03.html#aufgabenstellung",
    "title": "13  Beispiel: Balken mit Tilger{#sec-tilger}",
    "section": "13.1 Aufgabenstellung",
    "text": "13.1 Aufgabenstellung\nDas Beispiel ist die Weiterführung der Aufgabe in ?sec-ems_untilg. Ein einfacher Balken mit einer Einzelmasse, welcher in dieser Aufgabe mit Tilger ausgestattet ist, ist in Abbildung 13.1 dargestellt. Die Masse erfährt eine dynamische Einwirkung durch die Funktion \\(F(t)\\).\n\n\n\nAbbildung 13.1: Statisches System des Balkens mit Tilger\n\n\nGesucht:\n\nNormierte Eigenform\nMaximale dynamische Verformung mittels stationärer Lösung\nMaximale dynamische Beschleunigung mittels stationärer Lösung\n\nGegeben:\n\nE, I, m_H, m_T, k_T, L, F_0, omega, delta_11, delta_12 = sp.symbols('E, I, m_H, m_T, k_T, L, F_0, omega, delta_11, delta_12')\n\nt = sp.symbols('t')\n\nk_T, k_H = sp.symbols('k_T, k_H')\n\nomega_n =sp.symbols('omega_n')\n\nphi_11, phi_21, phi_12, phi_22 = sp.symbols('phi_11, phi_21, phi_12, phi_22')\n\n\nparams = {E: 200*10**3 *unit.N/unit.mm**2,\n          I:2*10**8*unit.mm**4,\n          m_H:2000*unit.N*unit.second**2/unit.m,\n          m_T:150*unit.N*unit.second**2/unit.m,\n          k_T:90*10**3*unit.N/unit.m,\n          L:5*unit.m,\n          F_0:0.8*10**3*unit.N,\n          omega:12.6/unit.second,\n          phi_11:1,\n          phi_12:1,\n          zeta:0.0         \n          }\n\nrender.dict_to_table(params)\n\n\n\nTabelle 13.1: Parameter der Aufgabenstellung\n\n\n\n\n\n\n\\(E = \\frac{200000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(F_{0} = 800.0 \\text{N}\\)\n\n\n\\(I = 200000000 \\text{mm}^{4}\\)\n\\(L = 5 \\text{m}\\)\n\n\n\\(k_{T} = \\frac{90000 \\text{N}}{\\text{m}}\\)\n\\(m_{H} = \\frac{2000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\n\n\\(m_{T} = \\frac{150 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(\\omega = \\frac{12.6}{\\text{s}}\\)\n\n\n\\(\\phi_{11} = 1\\)\n\\(\\phi_{12} = 1\\)\n\n\n\\(\\zeta = 0.0\\)\n\n\n\n\n\n\n\n\\[\nF(t) = F_0 \\cdot \\sin(\\omega\\cdot t) = 0.8 \\text{kN} \\cdot (12.6 \\frac{\\text{rad}}{\\text{s}}\\cdot t)\n\\]"
  },
  {
    "objectID": "mms_03.html#musterlösung",
    "href": "mms_03.html#musterlösung",
    "title": "13  Beispiel: Balken mit Tilger{#sec-tilger}",
    "section": "13.2 Musterlösung",
    "text": "13.2 Musterlösung\n\nF_t = F_0 * sp.sin(omega*t)\n\n\n13.2.1 Bemerkung Tilgerauslegung\nDie Auslegung des Tilgers kann folgender massen geschehen:\n\nTilgermasse \\(5\\%\\) von der Masse des Hauptträgers.\nOptimale Frequenz bestimmen: \\[\nf_{T,opt} =\\frac{f_H}{1+\\frac{m_T}{m_H}}\n\\tag{13.1}\\]\nDaraus die optimale Steifigkeit bestimmen: \\[\nk_{T,opt} = (2 \\pi f_{T,opt})^2\n\\tag{13.2}\\]\n\n\n\n13.2.2 Steifigkeitsmatrix \\(\\mathbf{K}\\)\n\n\n\nAbbildung 13.2: Verformungen am ersten Freiheitsgrad\n\n\nWichtig dabei sind die Richtungen der Kräfte. Als Denkstütze gilt folgendes:\n\nDer Auslenkung um \\(u\\) wirkt die Federkraft entgegen, welche \\(k u\\) entspricht.\nZusätzlich wirkt die Trägheitskraft der Auslenkung entgegen, welche \\(m u''\\) entspricht.\nNach der Betrachtung des ausgelenkten Punkts, kann mittels Actio-Reactio-Prinzip das “Stockwerk” ins Gleichgewicht gebracht werden.\nVorzeichen sind gegen der Bewegungsrichtig positiv.\n\n\n\n\nAbbildung 13.3: Verformungen am zweiten Freiheitsgrad\n\n\n\n\nparams['k_H'] = (48 * E*I / (2*L)**3).subs(params).simplify()\nK = sp.Matrix([[k_H + k_T, -k_T],[-k_T, k_T]])\n\n\nrender.eq_display(sp.MatrixSymbol('K', 2,2), K,\n                  sp.MatrixSymbol('K', 2,2), K.subs(params),\n                  )\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}k_{H} + k_{T} & - k_{T}\\\\- k_{T} & k_{T}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{2010000 \\text{N}}{\\text{m}} & - \\frac{90000 \\text{N}}{\\text{m}}\\\\- \\frac{90000 \\text{N}}{\\text{m}} & \\frac{90000 \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n13.2.3 Eigenvektoren\n\n13.2.3.1 Massenmatrix \\(\\mathbf{M}\\)\nDie Massenmatrix folgt dem gleichen Aufbau der Steifigkeitsmatrix. Es gelten die gleichen Vorzeichenregelungen. Die Einträge beziehen sich auf Abbildung 13.3 und Abbildung 13.2.\n\nM = sp.Matrix([[m_H, 0],[0, m_T]])\n\nrender.eq_display(sp.MatrixSymbol('M', 2,2), M,\n                  sp.MatrixSymbol('M', 2,2), M.subs(params))\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{H} & 0\\\\0 & m_{T}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}\\frac{2000 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{150 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n13.2.3.2 Eigenkreisfrequenzen\nBei einem Mehrmassenschwinger gibt es entsprechend den Freiheitsgraden Eigenkreisfrequenzen \\(\\omega_n\\). Diese lassen sich anhand folgender Gleichung bestimmen:\n\\[\n\\det{[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]=0}\n\\tag{13.3}\\]\n\neq_omega = sp.det(K-omega_n**2*M)\n\nomega_n_solve = sp.solve(eq_omega, omega_n)\nomega_1 = omega_n_solve[1]\nomega_2 = omega_n_solve[3]\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{23.3}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{32.6}{\\text{s}}\\end{equation}\\]\n\n\n\n\n13.2.3.3 Eigenvektoren \\(\\mathbf{\\phi}\\)\n\\[\n\\phi_n = \\begin{bmatrix}\n\\phi_{1n}\\\\\n\\phi_{2n}\n\\end{bmatrix}\n\\tag{13.4}\\] \\[\n[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]\\cdot \\begin{bmatrix}\n\\phi_{1n}\\\\\n\\phi_{2n}\n\\end{bmatrix}\n=0 \\tag{13.5}\\]\nDazu ist die entsprechende Normierung aus der Aufgabenstellung zu berücksichtigen.\n\n\nphi_1 = sp.Matrix([[phi_11], [phi_21]])\n\nphi_21 = list(sp.solve((K-omega_1**2 *M)*phi_1, phi_21).values())[0]\n\nparams['phi_21'] = phi_21.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.simplify((K-omega_1**2 *M)*phi_1),sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_1', 2,1),sp.simplify(phi_1.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{- k_{T} m_{T} \\phi_{21} + \\frac{\\phi_{11} \\left(- k_{T} m_{H} + m_{T} \\left(k_{H} + k_{T}\\right) + \\sqrt{k_{H}^{2} m_{T}^{2} - 2 k_{H} k_{T} m_{H} m_{T} + 2 k_{H} k_{T} m_{T}^{2} + k_{T}^{2} m_{H}^{2} + 2 k_{T}^{2} m_{H} m_{T} + k_{T}^{2} m_{T}^{2}}\\right)}{2}}{m_{T}}\\\\\\frac{- k_{T} m_{H} \\phi_{11} + \\frac{\\phi_{21} \\left(k_{T} m_{H} - m_{T} \\left(k_{H} + k_{T}\\right) + \\sqrt{k_{H}^{2} m_{T}^{2} - 2 k_{H} k_{T} m_{H} m_{T} + 2 k_{H} k_{T} m_{T}^{2} + k_{T}^{2} m_{H}^{2} + 2 k_{T}^{2} m_{H} m_{T} + k_{T}^{2} m_{T}^{2}}\\right)}{2}}{m_{H}}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1} = \\left[\\begin{matrix}1.0\\\\10.3\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nphi_2 = sp.Matrix([[phi_12], [phi_22]])\n\nphi_22 = list(sp.solve((K-omega_2**2 *M)*phi_2, phi_22).values())[0]\n\nparams['phi_22'] = phi_22.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.simplify((K-omega_2**2 *M)*phi_2),sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_2', 2,1),sp.simplify(phi_2.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{- k_{T} m_{T} \\phi_{22} + \\frac{\\phi_{12} \\left(- k_{T} m_{H} + m_{T} \\left(k_{H} + k_{T}\\right) - \\sqrt{k_{H}^{2} m_{T}^{2} - 2 k_{H} k_{T} m_{H} m_{T} + 2 k_{H} k_{T} m_{T}^{2} + k_{T}^{2} m_{H}^{2} + 2 k_{T}^{2} m_{H} m_{T} + k_{T}^{2} m_{T}^{2}}\\right)}{2}}{m_{T}}\\\\\\frac{- k_{T} m_{H} \\phi_{12} + \\frac{\\phi_{22} \\left(k_{T} m_{H} - m_{T} \\left(k_{H} + k_{T}\\right) - \\sqrt{k_{H}^{2} m_{T}^{2} - 2 k_{H} k_{T} m_{H} m_{T} + 2 k_{H} k_{T} m_{T}^{2} + k_{T}^{2} m_{H}^{2} + 2 k_{T}^{2} m_{H} m_{T} + k_{T}^{2} m_{T}^{2}}\\right)}{2}}{m_{H}}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2} = \\left[\\begin{matrix}1.0\\\\-1.3\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n13.2.3.4 Orthogonalitätsbedingung\nZur Entkoppelung des Systems wird die Orthogonalität der Eigenvektoren kontrolliert. Siehe Kapitel 12.2.2.4 für eine ausführliche Erklärung.\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_2.T*M*phi_1)).subs(params).evalf(7),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*M*phi_2).subs(params).evalf(7))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{1.79 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{2.25 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{6.103516 \\cdot 10^{-5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{6.103516 \\cdot 10^{-5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\nEs ist eine kleine numerische Differenz zu erkennen welche nicht relevant sind.\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_1.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_2.T*K*phi_2).subs(params)).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_2.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_1.T*K*phi_2).subs(params)).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{9.7 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{2.39 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n13.2.4 Modale Analyse\nDie Bewegungsgleichung für einen ungedämpften, periodisch, harmonisch angeregten Mehrmassenschwinger lässt sich folgend beschreiben:\n\\[\n\\mathbf{M u''(t) + K u = F(t)}\n\\tag{13.6}\\]\nDie Matrix-Gleichung beschreibt ein System aus Differentialgleichungen. Die Modale Analyse zielt darauf ab, diese zu entkoppeln. Bezogen auf den Mehrmassenschwinger heisst eine Entkoppelung, dass diese in Einmassenschwinger aufgeteilt werden. Dies wird nun schrittweise durchgeführt.\n\n13.2.4.1 Modal- und Spektralmatrix\nMittels der Modal- und Spektralmatrix können die generalisierten Grössen ermittelt werden. Diese sind die Eigenschaften der einzelnen Einmassenschwinger. Die generalisierten Werte besitzen keine physikalische Bedeutung, sie sind abhängig von der Wahl der Eigenvektoren, welche bekanntlich von der Normierung abhängen.\nAnhand der Bewegungsgleichung können die generalisierten Grössen bestimmt werden, es gilt:\n\\[\\Phi^T M \\Phi u''(t) + \\Phi^T K \\Phi u(t) = \\Phi^T F(t)\\]\n\\[M^*u''(t) + K^* u(t) = F^* (t)\\]\nAlle \\(N\\)-Eigenwerte und alle \\(N\\)-Eigenvektoren können kompakt mit Matrizen ausgedrückt werden:\n\nPhi = sp.Matrix([[phi_1, phi_2]])\nOmega = sp.Matrix([[omega_1, 0],[0, omega_2]])\n\nrender.eq_display('Modalmatrix', 'Phi',\n                  sp.MatrixSymbol('Phi', 2, 2), Phi.subs(params).evalf(4),\n                  'Spektralmatrix', 'Omega^2',\n                  sp.MatrixSymbol('Omega^2', 2, 2), (Omega**2).subs(params).evalf(4))\n\n\\[\\begin{equation}Modalmatrix = \\Phi\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Phi} = \\left[\\begin{matrix}1.0 & 1.0\\\\10.3 & -1.295\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}Spektralmatrix = \\Omega^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Omega}^{2} = \\left[\\begin{matrix}\\frac{541.7}{\\text{s}^{2}} & 0\\\\0 & \\frac{1063.0}{\\text{s}^{2}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n13.2.4.2 Generalisierte Grössen\n\nM_star = Phi.T * M * Phi\nK_star = Phi.T * K * Phi\nF_t_matrix = sp.Matrix([[F_t],[0]])\nF_t_star = Phi.T * F_t_matrix\n\nrender.eq_display(sp.MatrixSymbol('M^\\star', 2,2),sp.simplify(M_star.subs(params)).evalf(5),\n                  sp.MatrixSymbol('K^\\star', 2,2),sp.simplify(K_star.subs(params)).evalf(5),\n                  sp.MatrixSymbol('F(t)', 2,1),sp.simplify(F_t_matrix.subs(params)).evalf(5),\n                  sp.MatrixSymbol('F(t)^\\star', 2,1),sp.simplify(F_t_star.subs(params)).evalf(5))\n\n\\[\\begin{equation}\\mathbf{M}^{\\star} = \\left[\\begin{matrix}\\frac{17898.0 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{2251.6 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K}^{\\star} = \\left[\\begin{matrix}\\frac{9.6959 \\cdot 10^{6} \\text{N}}{\\text{m}} & 0\\\\0 & \\frac{2.3941 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F(t)} = \\left[\\begin{matrix}800.0 \\sin{\\left(\\frac{12.6 t}{\\text{s}} \\right)} \\text{N}\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F(t)}^{\\star} = \\left[\\begin{matrix}800.0 \\sin{\\left(\\frac{12.6 t}{\\text{s}} \\right)} \\text{N}\\\\800.0 \\sin{\\left(\\frac{12.6 t}{\\text{s}} \\right)} \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n13.2.4.3 Kontrolle der modalen Transformation\n\nomega_1_kontrolle = sp.sqrt(K_star[0] / M_star[0])\nomega_2_kontrolle = sp.sqrt(K_star[3] / M_star[3])\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_1_modal', omega_1_kontrolle.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(4),\n                  'omega_2_modal', omega_2_kontrolle.subs(params).simplify().evalf(4))\n\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{23.3}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1 modal} = \\frac{23.3}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{32.61}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2 modal} = \\frac{32.61}{\\text{s}}\\end{equation}\\]\n\n\n\n\n13.2.4.4 Modale Höhen\nDie modalen Höhen bestimmen sich aus Gleichung 13.7:\n\\[\nH_n = \\frac{L_n^\\theta}{L_n}\n\\tag{13.7}\\]\n\\[\nL_n = \\phi_n^T \\cdot \\mathbf{M 1}\n\\tag{13.8}\\]\n\\[\nL_n^\\theta = \\sum_{j=1}^N H_j \\cdot m_j \\cdot \\phi_{jn}\n\\tag{13.9}\\]\nWie sind modale Höhen mit diesem Beispiel zu bestimmen?\n\n\n\n13.2.5 Stationäre Antwort\nDie stationäre Antwort wird mittels des Vergrösserungsfaktors bestimmt.\nDie entkoppelte Differentialgleichung ist nun die folgende:\n\\[\nm^\\star_1 q_1''(t) + k^\\star_1 q_1(t) = F^\\star_1(t) = F^\\star_1 \\sin(\\omega t)\n\\tag{13.10}\\]\n\\[\nm^\\star_2 q_2''(t) + k^\\star_2 q_2(t) = F^\\star_2(t) = F^\\star_2 \\sin(\\omega t)\n\\tag{13.11}\\]\nLösen lässt sich dies mit dem bekannten Ansatz:\n\\[\nq_n(t) = A_n \\sin(\\omega t) + B_n \\cos(\\omega)\n\\tag{13.12}\\]\nHier wird jedoch mit dem Vorgehen des Vergrösserungsfaktors verfahren:\n\n13.2.5.1 Verformung\n\nzeta = sp.symbols('zeta')\n\nV_1_omega = 1/(sp.sqrt((1-(omega/omega_1)**2)**2 + (2*zeta*(omega/omega_1))**2))\n\nq_1_stat = F_0 / K_star[0]\nq_1_max = q_1_stat*V_1_omega\n\nrender.eq_display('V_1(omega)', '1/(sqrt((1-(omega/omega_1)**2)**2 + (2*zeta_*(omega/omega_1))**2))',\n                  'V_1(omega)', V_1_omega.subs(params).simplify().evalf(3),\n                  'q_1_stat', unit.convert_to(q_1_stat.subs(params).simplify().evalf(3), unit.mm),\n                  'q_1_max', 'q_1_stat * V_1(omega)',\n                  'q_1_max', unit.convert_to(q_1_max.subs(params).simplify().evalf(3), unit.mm),)\n\n\\[\\begin{equation}V_{1}{\\left(\\omega \\right)} = \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{1}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{1}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{1}{\\left(\\omega \\right)} = 1.41\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{1 stat} = 0.0825 \\text{mm}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{1 max} = q_{1 stat} V_{1}{\\left(\\omega \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{1 max} = 0.117 \\text{mm}\\end{equation}\\]\n\n\n\n\nV_2_omega = 1/(sp.sqrt((1-(omega/omega_2)**2)**2 + (2*zeta*(omega/omega_2))**2))\n\nq_2_stat = F_0 / K_star[3]\nq_2_max = q_2_stat*V_2_omega\n\n\n\nrender.eq_display('V_2(omega)', '1/(sqrt((1-(omega/omega_2)**2)**2 + (2*zeta_*(omega/omega_2))**2))',\n                  'V_2(omega)', V_2_omega.subs(params).simplify().evalf(3),\n                  'q_2_stat', unit.convert_to(q_2_stat.subs(params).simplify().evalf(3), unit.mm),\n                  'q_2_max', 'q_2_stat * V_2(omega)',\n                  'q_2_max', unit.convert_to(q_2_max.subs(params).simplify().evalf(3), unit.mm))\n\n\\[\\begin{equation}V_{2}{\\left(\\omega \\right)} = \\frac{1}{\\sqrt{\\frac{4 \\omega^{2} \\zeta_{}^{2}}{\\omega_{2}^{2}} + \\left(- \\frac{\\omega^{2}}{\\omega_{2}^{2}} + 1\\right)^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{2}{\\left(\\omega \\right)} = 1.18\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 stat} = 0.334 \\text{mm}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 max} = q_{2 stat} V_{2}{\\left(\\omega \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 max} = 0.393 \\text{mm}\\end{equation}\\]\n\n\n\n13.2.5.1.1 Effektive Deformation\nDie effektiven Grössen resultieren durch Multiplikation mit dem Eigenvektor. Für die erste Eigenkreisfrequenz:\n\nu_1_stat = q_1_max*phi_1\nu_2_stat = q_2_max*phi_2\nu_stat = u_1_stat + u_2_stat\n\nrender.eq_display(\"u_1_stat\",\"q_1_max*phi_1\",\n'Matrix([[u_11stat],[u_21stat]])',unit.convert_to(u_1_stat.subs(params).evalf(3),unit.mm))\n\n\\[\\begin{equation}u_{1 stat} = \\phi_{1} q_{1 max}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\left[\\begin{matrix}u_{11stat}\\\\u_{21stat}\\end{matrix}\\right] = \\left[\\begin{matrix}0.117 \\text{mm}\\\\1.2 \\text{mm}\\end{matrix}\\right]\\end{equation}\\]\n\n\nSowie für die zweite Eigenkreisfrequenz:\n\nrender.eq_display(\"u_2_stat\",\"q_2_max*phi_2\",\n'Matrix([[u_12stat],[u_22stat]])',unit.convert_to(u_2_stat.subs(params).evalf(3),unit.mm))\n\n\\[\\begin{equation}u_{2 stat} = \\phi_{2} q_{2 max}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\left[\\begin{matrix}u_{12stat}\\\\u_{22stat}\\end{matrix}\\right] = \\left[\\begin{matrix}0.393 \\text{mm}\\\\- 0.509 \\text{mm}\\end{matrix}\\right]\\end{equation}\\]\n\n\nDurch Addition der beiden Verformungen: Sollte hier die SRSS-Regel verwendet werden?\n\nrender.eq_display(\"u_stat\" , \"u_1_stat + u_2_stat\",\n'Matrix([[u_1max],[u_2max]])',unit.convert_to(u_stat.subs(params).evalf(3),unit.mm))\n\n\\[\\begin{equation}u_{stat} = u_{1 stat} + u_{2 stat}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\left[\\begin{matrix}u_{1max}\\\\u_{2max}\\end{matrix}\\right] = \\left[\\begin{matrix}0.51 \\text{mm}\\\\0.693 \\text{mm}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n13.2.5.2 Beschleunigung\n\nV_a1_omega = omega**2 / omega_1**2 * V_1_omega\n\nq_2_1_max =  F_0 / M_star[0] * V_a1_omega\n\nrender.eq_display(\"V_a1_omega\" , \"omega**2 / omega_1**2 * V_1_omega\",\n'V_a1(omega)', V_a1_omega.subs(params).simplify().evalf(3),\n                  'Derivative(q_max,t,2)', q_2_1_max.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V_{a1 \\omega} = \\frac{V_{1 \\omega} \\omega^{2}}{\\omega_{1}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{a1}{\\left(\\omega \\right)} = 0.415\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d t^{2}} q_{max} = \\frac{0.0185 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\nV_a2_omega = omega**2 / omega_2**2 * V_2_omega\n\nq_2_2_max =  F_0 / M_star[3] * V_a2_omega\n\nrender.eq_display('V_a2(omega)', V_a2_omega.subs(params).simplify().evalf(3),'Derivative(q_max,t,2)', q_2_2_max.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}V_{a2}{\\left(\\omega \\right)} = 0.176\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d t^{2}} q_{max} = \\frac{0.0624 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n13.2.5.2.1 Effektive Beschleunigung\nGleiches Vorgehen wie bei der Deformation.\n\nu_2_1_stat = q_2_1_max*phi_1\nu_2_2_stat = q_2_2_max*phi_2\nu_2_stat = u_2_1_stat + u_2_2_stat\n\nrender.eq_display('Matrix([[Derivative(u_1max,t,2)],[Derivative(u_2max,t,2)]])',u_2_stat.subs(params).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{d^{2}}{d t^{2}} u_{1max}\\\\\\frac{d^{2}}{d t^{2}} u_{2max}\\end{matrix}\\right] = \\left[\\begin{matrix}\\frac{0.0809 \\text{m}}{\\text{s}^{2}}\\\\\\frac{0.11 \\text{m}}{\\text{s}^{2}}\\end{matrix}\\right]\\end{equation}\\]"
  },
  {
    "objectID": "mms_04.html#aufgabenstellung",
    "href": "mms_04.html#aufgabenstellung",
    "title": "14  Beispiel: Antwortspektrenverfahren an einem dreistöckigen Gebäude",
    "section": "14.1 Aufgabenstellung",
    "text": "14.1 Aufgabenstellung\n\n\n\nAbbildung 14.1: Statisches System des dreigeschossigen Gebäudes\n\n\nGesucht:\n\nBestimme die Steifigkeits- und Massenmatrix\nBestimme die Eigenkreisfrequenzen\nErmittle die daraus resultierenden Eigenvektoren\nFühre eine modale Analyse durch\n\nKontrolliere die Orthogonalität der transformierten Matrizen\nBestimme die Partizipationsfaktoren\n\nErmittle die Pseudobeschleunigung anhand des Antwortspektrums der SIA261:2020\nErmittle die daraus resultierende Deformationen (Überlagere mittels SRSS-Regel)\nZeichne die maximalen Schnittkraftverläufe\n\nGegeben:\n\nBaugrundklasse \\(E\\)\nErdbebenzone \\(Z2\\)\n\n\nm_1, m_2, m_3 = sp.symbols('m_1, m_2, m_3')\n\nEI_1, EI_2, EI_3, H_1, H_2, H_3 = sp.symbols(\"EI_1, EI_2, EI_3, H_1, H_2, H_3\")\n\n\nparams = {EI_1: 1.15*10**6 *unit.N*unit.m**2,\n          EI_2: 0.766666*10**6 *unit.N*unit.m**2,\n          EI_3: 1.15*10**6 *unit.N*unit.m**2,\n          m_1:6000*unit.N*unit.second**2/unit.m,\n          m_2:5000*unit.N*unit.second**2/unit.m,\n          m_3:4000*unit.N*unit.second**2/unit.m,\n          H_1:3.5*unit.m,\n          H_2:3.5*unit.m,\n          H_3:3.5*unit.m,\n          }\n\nparams_plot = convert.param_value(params)\nrender.dict_to_table(params)\n\n\n\nTabelle 14.1: Parameter der Aufgabe\n\n\n\n\n\n\n\\(EI_{1} = 1150000.0 \\text{m}^{2} \\text{N}\\)\n\\(EI_{2} = 766666.0 \\text{m}^{2} \\text{N}\\)\n\n\n\\(EI_{3} = 1150000.0 \\text{m}^{2} \\text{N}\\)\n\\(H_{1} = 3.5 \\text{m}\\)\n\n\n\\(H_{2} = 3.5 \\text{m}\\)\n\\(H_{3} = 3.5 \\text{m}\\)\n\n\n\\(m_{1} = \\frac{6000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(m_{2} = \\frac{5000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\n\n\\(m_{3} = \\frac{4000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)"
  },
  {
    "objectID": "mms_04.html#musterlösung",
    "href": "mms_04.html#musterlösung",
    "title": "14  Beispiel: Antwortspektrenverfahren an einem dreistöckigen Gebäude",
    "section": "14.2 Musterlösung",
    "text": "14.2 Musterlösung\n\n14.2.1 Massenmatrix \\(M\\)\n\n\n\nAbbildung 14.2: Auslenkung der Massen zur Ermittlung der Matrizen\n\n\n\nM = sp.Matrix([[m_1,0,0],[0,m_2,0],[0,0,m_3]])\n\nrender.eq_display(sp.MatrixSymbol('M', 3, 3), M,\n                  sp.MatrixSymbol('M', 3, 3), M.subs(params))\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{1} & 0 & 0\\\\0 & m_{2} & 0\\\\0 & 0 & m_{3}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}\\frac{6000 \\text{N} \\text{s}^{2}}{\\text{m}} & 0 & 0\\\\0 & \\frac{5000 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & 0 & \\frac{4000 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n14.2.2 Steifigkeitsmatrix \\(K\\)\n\n14.2.2.1 Steifigkeit der Stockwerke\n\nk_1 = 12 * EI_1 /H_1**3 * 2\nk_2 = 12 * EI_2 / H_2**3 * 3 \nk_3 = 12 * EI_3 / H_3**3 * 2 \n\nrender.eq_display(\"k_1\", k_1,\n'k_1', k_1.subs(params).simplify().evalf(3),\n\"k_2\", k_2,\n'k_2', k_2.subs(params).simplify().evalf(3),\n\"k_3\", k_3,\n'k_3', k_3.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}k_{1} = \\frac{24 EI_{1}}{H_{1}^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{1} = \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2} = \\frac{36 EI_{2}}{H_{2}^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2} = \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{3} = \\frac{24 EI_{3}}{H_{3}^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{3} = \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\nAbgefüllt in die Steifigkeitsmatrix\n\nK = sp.Matrix([[k_1 + k_2, -k_2, 0],[-k_2,k_2+k_3, -k_3], [0,-k_3, k_3]])\n\nrender.eq_display(sp.MatrixSymbol('K', 3, 3), \"Matrix([[k_1 + k_2, -k_2, 0],[-k_2,k_2+k_3, -k_3], [0,-k_3, k_3]])\",\nsp.MatrixSymbol('K', 3, 3), K,\n                  sp.MatrixSymbol('K', 3, 3), K.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}k_{1} + k_{2} & - k_{2} & 0\\\\- k_{2} & k_{2} + k_{3} & - k_{3}\\\\0 & - k_{3} & k_{3}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{24 EI_{1}}{H_{1}^{3}} + \\frac{36 EI_{2}}{H_{2}^{3}} & - \\frac{36 EI_{2}}{H_{2}^{3}} & 0\\\\- \\frac{36 EI_{2}}{H_{2}^{3}} & \\frac{36 EI_{2}}{H_{2}^{3}} + \\frac{24 EI_{3}}{H_{3}^{3}} & - \\frac{24 EI_{3}}{H_{3}^{3}}\\\\0 & - \\frac{24 EI_{3}}{H_{3}^{3}} & \\frac{24 EI_{3}}{H_{3}^{3}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{1.29 \\cdot 10^{6} \\text{N}}{\\text{m}} & - \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}} & 0\\\\- \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}} & \\frac{1.29 \\cdot 10^{6} \\text{N}}{\\text{m}} & - \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}}\\\\0 & - \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}} & \\frac{6.44 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n14.2.3 Eigenvektoren\n\n14.2.3.1 Eigenkreisfrequenzen\nBei einem Mehrmassenschwinger gibt es entsprechend den Freiheitsgraden Eigenkreisfrequenzen \\(\\omega_n\\). Diese lassen sich anhand folgender Gleichung bestimmen:\n\\[\n\\det{[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]=0}\n\\tag{14.1}\\]\n\nomega_n =sp.symbols('omega_n', real=True)\neq_omega = sp.det(K-omega_n**2*M)\nomega_n_solve= sp.solve([eq_omega.subs(params_plot).simplify(), omega_n&lt;=100, omega_n&gt;=0], omega_n, dict=True)\n\nomega_1 = omega_n_solve.args[0].rhs/unit.second\nomega_2 = omega_n_solve.args[1].rhs/unit.second\nomega_3 = omega_n_solve.args[2].rhs/unit.second\n\n\n\nrender.eq_display('omega_1', omega_1.evalf(3),\n                  'omega_2', omega_2.evalf(3),\n                  'omega_3', omega_3.evalf(3))\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{5.28}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{13.9}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{3} = \\frac{20.3}{\\text{s}}\\end{equation}\\]\n\n\n\nsp.plot(eq_omega.subs(params_plot).evalf(5).simplify(), (omega_n, 0,15),size=(5.9,2), show=False).show()\n\n\n\n\nAbbildung 14.3: Nullstellen der Gleichung 14.1\n\n\n\n\n\n\n14.2.3.2 Eigenvektoren \\(\\phi\\)\nDurch das Einsetzen der bestimmten Eigenkreisfrequenzen lassen sich die Eigenvektoren bestimmen. Die Einträge des Eigenvektors sind voneinander abhängig und lassen sich dem Entsprechen beliebig definieren. Grundsätzlich wird der maximale Eigenwert zu \\(1\\) gesetzt.\n\\[\n\\mathbf{K} - \\omega_n^2 \\mathbf{M} \\phi_n= 0\n\\tag{14.2}\\]\n\nphi_11, phi_21, phi_31 = sp.symbols('phi_11, phi_21, phi_31')\n\n# Matrix und Gleichung definiert\nphi_1 = sp.Matrix([[phi_11], [phi_21], [phi_31]])\nexpr = ((K-(omega_1*unit.second)**2 * M) * phi_1).subs(params_plot)\n\n# Startwerte\nparams['phi_11'] = 1\nparams['phi_21'] = sp.solve(expr[0].subs(params), phi_21)[0]\nparams['phi_31'] = sp.solve(expr[1].subs(params), phi_31)[0]\n\n# Normierung auf maximalwerte\nphi_max = max(abs(phi_11.subs(params)), abs(phi_21.subs(params)), abs(phi_31.subs(params)))\n\nparams['phi_11'] = (phi_11 / phi_max).subs(params)\nparams['phi_21'] = (phi_21 / phi_max).subs(params)\nparams['phi_31'] = (phi_31 / phi_max).subs(params)\n\n\nrender.eq_display(sp.MatrixSymbol('phi_1', 3,1), phi_1.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0.475\\\\0.827\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nphi_12, phi_22, phi_32 = sp.symbols('phi_12, phi_22, phi_32')\n\n# Matrix und Gleichung definiert\nphi_2 = sp.Matrix([[phi_12], [phi_22], [phi_32]])\nexpr = ((K-(omega_2*unit.second)**2 * M) * phi_2).subs(params_plot)\n\n# Startwerte\nparams['phi_12'] = 1\nparams['phi_22'] = sp.solve(expr[0].subs(params), phi_22)[0]\nparams['phi_32'] = sp.solve(expr[1].subs(params), phi_32)[0]\n\n# Normierung auf maximalwerte\nphi_max = max(abs(phi_12.subs(params)), abs(phi_22.subs(params)), abs(phi_32.subs(params)))\n\nparams['phi_12'] = (phi_12 / phi_max).subs(params)\nparams['phi_22'] = (phi_22 / phi_max).subs(params)\nparams['phi_32'] = (phi_32 / phi_max).subs(params)\n\n\nrender.eq_display(sp.MatrixSymbol('phi_2', 3,1), phi_2.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2} = \\left[\\begin{matrix}1.0\\\\0.188\\\\-0.908\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nphi_13, phi_23, phi_33 = sp.symbols('phi_13, phi_23, phi_33')\n\n# Matrix und Gleichung definiert\nphi_3 = sp.Matrix([[phi_13], [phi_23], [phi_33]])\nexpr = ((K-(omega_3*unit.second)**2 * M) * phi_3).subs(params_plot)\n\n# Startwerte\nparams['phi_13'] = 1\nparams['phi_23'] = sp.solve(expr[0].subs(params), phi_23)[0]\nparams['phi_33'] = sp.solve(expr[1].subs(params), phi_33)[0]\n\n# Normierung auf maximalwerte\nphi_max = max(abs(phi_13.subs(params)), abs(phi_23.subs(params)), abs(phi_33.subs(params)))\n\nparams['phi_13'] = (phi_13 / phi_max).subs(params)\nparams['phi_23'] = (phi_23 / phi_max).subs(params)\nparams['phi_33'] = (phi_33 / phi_max).subs(params)\n\n\nrender.eq_display(sp.MatrixSymbol('phi_3', 3,1), phi_3.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3} = \\left[\\begin{matrix}0.547\\\\-1.0\\\\0.644\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n14.2.4 Modale Analyse\nDie Modale Analyse zielt darauf ab, den Mehrmassenschwinger zu entkoppeln. Dazu wird in einem ersten Schritt die Orthogonalitätsbedingung kontrolliert. Diese muss erfüllt sein, um eine Entkoppelung durchzuführen. Siehe Kapitel 12.2.2.4 für eine ausführliche Erklärung.\n\n14.2.4.1 Orthogonalitätsbedingung\nAngewendet auf die Massenmatrix: Es zeigen sich kleine numerische Unreinheiten, welche vernachlässigt werden können.\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_2.T*M*phi_1).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_3',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_3.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*M*phi_2).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_3',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_3.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_3',2,1),(phi_1.T*M*phi_3).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_3',2,1),(phi_2.T*M*phi_3).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_3',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_3',2,1),(phi_3.T*M*phi_3).subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{8.77 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}- \\frac{1.82 \\cdot 10^{-12} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}- \\frac{5.0 \\cdot 10^{-12} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}- \\frac{1.82 \\cdot 10^{-12} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{9.47 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{1.91 \\cdot 10^{-11} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{3} = \\left[\\begin{matrix}- \\frac{5.0 \\cdot 10^{-12} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{3} = \\left[\\begin{matrix}\\frac{1.91 \\cdot 10^{-11} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3}^{T} \\mathbf{M} \\mathbf{\\phi}_{3} = \\left[\\begin{matrix}\\frac{8.45 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\nFür die Steifigkeitsmatrix:\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*K*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_2.T*K*phi_1).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_3',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_3.T*K*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*K*phi_2).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*K*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_3',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_3.T*K*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_3',2,1),(phi_1.T*K*phi_3).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_3',2,1),(phi_2.T*K*phi_3).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_3',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_3',2,1),(phi_3.T*K*phi_3).subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{2.44 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{1.88 \\cdot 10^{-9} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{6.26 \\cdot 10^{-10} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{1.88 \\cdot 10^{-9} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{1.84 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{4.83 \\cdot 10^{-9} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{3} = \\left[\\begin{matrix}\\frac{6.26 \\cdot 10^{-10} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{3} = \\left[\\begin{matrix}\\frac{4.83 \\cdot 10^{-9} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{3}^{T} \\mathbf{K} \\mathbf{\\phi}_{3} = \\left[\\begin{matrix}\\frac{3.47 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n14.2.4.2 Modal- und Spektralmatrix\nMittels der Modal- und Spektralmatrix lassen sich die generalisierten Grössen effizient ermitteln.\n\nPhi = sp.Matrix([[phi_1, phi_2, phi_3]])\nOmega = sp.Matrix([[omega_1, 0, 0],[0, omega_2, 0],[0, 0, omega_3]])\n\nrender.eq_display('Modalmatrix', 'Phi',\n                  sp.MatrixSymbol('Phi', 3, 3), Phi.subs(params).evalf(4),\n                  'Spektralmatrix', 'Omega^2',\n                  sp.MatrixSymbol('Omega^2', 3, 3), (Omega**2).subs(params).evalf(4))\n\n\\[\\begin{equation}Modalmatrix = \\Phi\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Phi} = \\left[\\begin{matrix}0.4752 & 1.0 & 0.5468\\\\0.827 & 0.1885 & -1.0\\\\1.0 & -0.9076 & 0.6441\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}Spektralmatrix = \\Omega^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Omega}^{2} = \\left[\\begin{matrix}\\frac{27.84}{\\text{s}^{2}} & 0 & 0\\\\0 & \\frac{194.4}{\\text{s}^{2}} & 0\\\\0 & 0 & \\frac{410.8}{\\text{s}^{2}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n14.2.4.3 Generalisierte Grössen\nZur Reduktion des Rechenaufwands werden die numerischen Unreinheiten zu Null gesetzt.\n\nM_star = Phi.T * M * Phi\nK_star = Phi.T * K * Phi\n\nM_star_clean = set_small_values_to_zero(M_star.subs(params).evalf(5), 0.1*unit.N *unit.second**2 / unit.m)\nK_star_clean = set_small_values_to_zero(K_star.subs(params).evalf(5), 0.1*unit.N  / unit.m)\n\nrender.eq_display(sp.MatrixSymbol('M^\\star', 3,3),sp.simplify(M_star_clean.subs(params)).evalf(5),\n                  sp.MatrixSymbol('K^\\star', 3,3),sp.simplify(K_star_clean.subs(params)).evalf(5))\n                 \n\n\\[\\begin{equation}\\mathbf{M}^{\\star} = \\left[\\begin{matrix}\\frac{8774.2 \\text{N} \\text{s}^{2}}{\\text{m}} & 0 & 0\\\\0 & \\frac{9472.3 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & 0 & \\frac{8452.9 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K}^{\\star} = \\left[\\begin{matrix}\\frac{2.4429 \\cdot 10^{5} \\text{N}}{\\text{m}} & 0 & 0\\\\0 & \\frac{1.841 \\cdot 10^{6} \\text{N}}{\\text{m}} & 0\\\\0 & 0 & \\frac{3.4725 \\cdot 10^{6} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n14.2.4.4 Modale Höhen\nDie modalen Höhen bestimmen sich aus Gleichung 14.3:\n\\[\nH_n = \\frac{L_n^\\theta}{L_n}\n\\tag{14.3}\\]\n\\[\nL_n = \\phi_n^T \\cdot \\mathbf{M 1}\n\\tag{14.4}\\]\n\\[\nL_n^\\theta = \\sum_{j=1}^N H_j \\cdot m_j \\cdot \\phi_{jn}\n\\tag{14.5}\\]\nAngewendet auf das Beispiel folgt:\n\none_vec = sp.ones(3,1)\n\n\nH_matrix = sp.Matrix([H_1, H_2, H_3])\nH_modal = (H_matrix.T*M*Phi).T.multiply_elementwise((M*Phi.T*one_vec).applyfunc(lambda x: x**-1))\n\n\nrender.eq_display(\n    sp.MatrixSymbol('H', 3,1), H_matrix,\n    sp.MatrixSymbol('H', 3,1), H_modal,\n    sp.MatrixSymbol('H', 3,1), H_modal.subs(params).evalf(3),\n\n)\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}H_{1}\\\\H_{2}\\\\H_{3}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}\\frac{H_{1} m_{1} \\phi_{11} + H_{2} m_{2} \\phi_{21} + H_{3} m_{3} \\phi_{31}}{m_{1} \\phi_{11} + m_{1} \\phi_{21} + m_{1} \\phi_{31}}\\\\\\frac{H_{1} m_{1} \\phi_{12} + H_{2} m_{2} \\phi_{22} + H_{3} m_{3} \\phi_{32}}{m_{2} \\phi_{12} + m_{2} \\phi_{22} + m_{2} \\phi_{32}}\\\\\\frac{H_{1} m_{1} \\phi_{13} + H_{2} m_{2} \\phi_{23} + H_{3} m_{3} \\phi_{33}}{m_{3} \\phi_{13} + m_{3} \\phi_{23} + m_{3} \\phi_{33}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}2.78 \\text{m}\\\\8.25 \\text{m}\\\\3.93 \\text{m}\\end{matrix}\\right]\\end{equation}\\]\n\n\nModalen Höhen kleiner als null sind zu vernachlässigen.\n\n\n14.2.4.5 Kontrolle der modalen Transformation\nDie Eigenkreisfrequenzen ändern sich durch die Transformation nicht.\n\nomega_1_kontrolle = sp.sqrt(K_star_clean[0] / M_star_clean[0])\nomega_2_kontrolle = sp.sqrt(K_star_clean[4] / M_star_clean[4])\nomega_3_kontrolle = sp.sqrt(K_star_clean[8] / M_star_clean[8])\n\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_1_modal', omega_1_kontrolle.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(4),\n                  'omega_2_modal', omega_2_kontrolle.subs(params).simplify().evalf(4),\n                  'omega_3', omega_3.subs(params).simplify().evalf(4),\n                  'omega_3_modal', omega_3_kontrolle.subs(params).simplify().evalf(4))\n\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{5.28}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1 modal} = \\frac{5.28}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{13.94}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2 modal} = \\frac{13.94}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{3} = \\frac{20.27}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{3 modal} = \\frac{20.27}{\\text{s}}\\end{equation}\\]\n\n\n\n\n14.2.4.6 Partizipationsfaktor \\(\\Gamma\\)\nDie Verteilung des Partizipationsfaktor gibt einen direkten Hinweis, welcher Eigenmode an der Gesamtanwort den grössten Einfluss (beteiligt bzw. partizipiert) hat.\n\\[\n\\Gamma_n = \\frac{\\Phi_n^T \\mathbf{M 1}}{\\Phi_n^T \\mathbf{M}\\Phi_n}\n\\tag{14.6}\\]\nIn allgemeiner Form lautet der Partizipationsfaktor:\n\\[\n\\Gamma_n = \\frac{\\Phi_n^T \\mathbf{M r^\\star}}{\\Phi_n^T \\mathbf{M}\\Phi_n}\n\\tag{14.7}\\]\n\\(\\mathbf{r^\\star}\\) beschreibt die Starrkörperverschiebung infolge der Erdbebenanregung \\(u_g\\) am Fusspunkt des Gesamtsystems.\n\\[\n\\mathbf{r^\\star} = \\begin{bmatrix}\nFHG_1 \\\\\nFHG_2\n\\end{bmatrix}=\n\\begin{bmatrix}\n\\cos(0) \\\\\n\\cos(0)\n\\end{bmatrix}=\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}= \\mathbf{1}\n\\tag{14.8}\\]\nDie Partizipationsmatrix lässt sich direkt durch folgende Gleichung ermitteln:\n\\[\n\\Gamma = M^{\\star-1} \\cdot \\Phi^T \\cdot M \\cdot 1\n\\tag{14.9}\\]\nGelöst mit Gleichung 14.9:\n\n\nGamma = M_star_clean**-1 * Phi.T * M*one_vec \n\nrender.eq_display(\n    sp.MatrixSymbol('Gamma',3,1), Gamma.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\Gamma} = \\left[\\begin{matrix}1.25\\\\0.35\\\\0.101\\end{matrix}\\right]\\end{equation}\\]\n\n\nGelöst mit Gleichung 14.7:\n\n\n\ngamma_1 = (phi_1.T*M*one_vec)[0]/(phi_1.T*M*phi_1)[0]\ngamma_2 = (phi_2.T*M*one_vec)[0]/(phi_2.T*M*phi_2)[0]\ngamma_3 = (phi_3.T*M*one_vec)[0]/(phi_3.T*M*phi_3)[0]\n\ngamma_sqr = sp.Matrix([[gamma_1**2],[gamma_2**2]])\nrender.eq_display('Gamma_1', gamma_1,\n                  'Gamma_1', gamma_1.subs(params).evalf(3),\n                  'Gamma_2', gamma_2,\n                  'Gamma_2', gamma_2.subs(params).evalf(3),\n                  'Gamma_3', gamma_3,\n                  'Gamma_3', gamma_3.subs(params).evalf(3))\n\n\\[\\begin{equation}\\Gamma_{1} = \\frac{m_{1} \\phi_{11} + m_{2} \\phi_{21} + m_{3} \\phi_{31}}{m_{1} \\phi_{11}^{2} + m_{2} \\phi_{21}^{2} + m_{3} \\phi_{31}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{1} = 1.25\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{2} = \\frac{m_{1} \\phi_{12} + m_{2} \\phi_{22} + m_{3} \\phi_{32}}{m_{1} \\phi_{12}^{2} + m_{2} \\phi_{22}^{2} + m_{3} \\phi_{32}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{2} = 0.35\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{3} = \\frac{m_{1} \\phi_{13} + m_{2} \\phi_{23} + m_{3} \\phi_{33}}{m_{1} \\phi_{13}^{2} + m_{2} \\phi_{23}^{2} + m_{3} \\phi_{33}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{3} = 0.101\\end{equation}\\]\n\n\n\nhoehe = list(H_modal.subs(params).evalf(3)/unit.m)\nhoehe = [np.float64(i).round(2) for i in hoehe]\n\nmasse = list(M_star_clean/unit.N/unit.second**2 * unit.m)\nmasse = [np.float64(i).round(2) for i in masse if i != 0]\n\nsteifigkeiten = list(K_star_clean/unit.N * unit.m)\nsteifigkeiten = [np.float64(i).round(2) for i in steifigkeiten if i != 0]\n\nomegas = list(Omega*unit.second)\nomegas = [np.float64(i).round(2) for i in omegas if i != 0]\n\ngammas = list(Gamma.subs(params).evalf(3))\ngammas = [np.float64(i).round(2) for i in gammas if i != 0]\n\n\nplot_einmassenschwinger(hoehe, masse, steifigkeiten, omegas, gammas)\n\n\n\n\nAbbildung 14.4: Darstellung der entkoppelten Einmassenschwinger\n\n\n\n\n\n\n\n14.2.5 Elastisches Antwortspektrum\nAus der Aufgabenstellung darf nach (Schweizerischer Ingenieur- und Architektenverein (SIA), 2020) Abs. 16.2.3.1 Kurve \\(E\\) gewählt werden.\n\na_gd = 1 *unit.m /unit.second**2\n\n\n14.2.5.1 Grundschwingzeit\nDie Grundschwingzeit kann anhand der bereits ermittelten Eigenkreisfrequenzen ermittelt werden.\n\\[\nT = \\frac{2 \\pi}{\\omega}\n\\tag{14.10}\\]\n\nT_1 = ((2*sp.pi)/omega_1)\nT_2 = ((2*sp.pi)/omega_2)\nT_3 = ((2*sp.pi)/omega_3)\n\nrender.eq_display('T_1', T_1.subs(params).evalf(3),\n                  'T_2', T_2.subs(params).evalf(3),\n                  'T_3', T_3.subs(params).evalf(3),\n                  )\n\n\\[\\begin{equation}T_{1} = 1.19 \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{2} = 0.451 \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{3} = 0.31 \\text{s}\\end{equation}\\]\n\n\n\n\n14.2.5.2 Elastisches Antwortspektrum\nEs wird für sämtliche Eigenperioden die Pseudobeschleunigung bestimmt. Siehe dazu Schweizerischer Ingenieur- und Architektenverein (SIA) (2020).\n\nS_e_1 = antwortspektrum(a_gd, T_1.subs(params).evalf(3), Baugrundklasse='D')\nrender.eq_display('S_e_1', S_e_1.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.7\\)\n\\(T_{B} = 0.1 \\text{s}\\)\n\n\n\\(T_{C} = 0.5 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = \\frac{2.5 S_{} T_{C} a_{gd} \\eta}{T}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 1} = \\frac{1.78 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\nS_e_2 = antwortspektrum(a_gd, T_2.subs(params).evalf(3), Baugrundklasse = 'D')\n\nrender.eq_display('S_e_2', S_e_2.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.7\\)\n\\(T_{B} = 0.1 \\text{s}\\)\n\n\n\\(T_{C} = 0.5 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = 2.5 S_{} a_{gd} \\eta\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 2} = \\frac{4.25 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\nS_e_3 = antwortspektrum(a_gd, T_3.subs(params).evalf(3), Baugrundklasse = 'D')\n\nrender.eq_display('S_e_3', S_e_3.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.7\\)\n\\(T_{B} = 0.1 \\text{s}\\)\n\n\n\\(T_{C} = 0.5 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = 2.5 S_{} a_{gd} \\eta\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 3} = \\frac{4.25 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n\n\n14.2.6 Maximale Deformation\nDie maximale Deformation resultiert aus der Beschleunigung \\(S_e\\) und der Eigenkreisfrequenz \\(\\omega_n^2\\). Für die Modalen EMS gilt es diese anhand der Partizipationsfaktoren zu gewichten. Zur effektiven Bestimmung der Auslenkung sind die Resultate der EMS mittels SRSS-Regel zu überlagern.\n\nq_1_max = Gamma[0] * S_e_1 / omega_1**2\nq_2_max = Gamma[1] * S_e_2 / omega_2**2\nq_3_max = Gamma[2] * S_e_3 / omega_3**2\n\nrender.eq_display(\n    'q_1_max',\"Gamma_1 * S_e_1 / omega_1**2\",\n    'q_1_max', q_1_max.subs(params).evalf(3),\n    'q_2_max',\"Gamma_2 * S_e_2 / omega_2**2\",\n    'q_2_max', q_2_max.subs(params).evalf(3),    \n    'q_3_max',\"Gamma_3 * S_e_3 / omega_3**2\",\n    'q_3_max', q_3_max.subs(params).evalf(3))\n\n\\[\\begin{equation}q_{1 max} = \\frac{\\Gamma_{1} S_{e 1}}{\\omega_{1}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{1 max} = 0.0803 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 max} = \\frac{\\Gamma_{2} S_{e 2}}{\\omega_{2}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 max} = 0.00765 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{3 max} = \\frac{\\Gamma_{3} S_{e 3}}{\\omega_{3}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{3 max} = 0.00105 \\text{m}\\end{equation}\\]\n\n\nUm die Entkoppelung rückzuführen, gilt es die erhaltenen Resultate zu überlagern. Dabei gibt es unterschiedliche Ansätze. Bei weit auseinander liegenden Eigenfrequenzen kann die SRSS-Überlagerung (Square-root of the sum of squares) verwendet werden.\n\\[\nu_{max} = \\sqrt{\\sum_{n=1}^2 (q_{n} \\cdot \\phi_n)^2}\n\\tag{14.11}\\]\n\nu_max = ((phi_1*q_1_max).applyfunc(lambda x: x**2)+(phi_2*q_2_max).applyfunc(lambda x: x**2)+(phi_3*q_3_max).applyfunc(lambda x: x**2)).applyfunc(sp.sqrt)\n\n\nrender.eq_display(sp.MatrixSymbol('u_max', 3,1), u_max.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{u}_{max} = \\left[\\begin{matrix}0.0389 \\text{m}\\\\0.0664 \\text{m}\\\\0.0806 \\text{m}\\end{matrix}\\right]\\end{equation}\\]\n\n\nStephan, wieso multiplizierst du die SRSS- Überlagerung nochmals mit \\(phi_1\\)\n\n\n\nFrage\n\n\n\n\n14.2.7 Maximale Schnittkräfte\n\n14.2.7.1 Querkräfte\nDie Einwirkungen resultieren aus der Masse multipliziert mit der Beschleunigung aus dem Antwortspektrum. Dazu sind in einem ersten Schritt die beiden entkoppelten EMS voneinander getrennt zu betrachten. Die Überlagerung erfolgt erst bei den ermittelten Querkräften.\n\\[\nm_1 = \\Gamma \\cdot M \\cdot \\phi_1\n\\tag{14.12}\\]\n\\[\nF_{1max} = m_1 \\cdot S_{e1}\n\\tag{14.13}\\]\nAus dem ersten EMS folgt:\n\nm_1_part = Gamma[0] * M * phi_1\nF_1_max = m_1_part* S_e_1\nV_1 = sp.Matrix([[F_1_max[0]+F_1_max[1]+F_1_max[2]],[F_1_max[1]+F_1_max[2]], [F_1_max[2]]])\n\nrender.eq_display(sp.MatrixSymbol('m_1', 3,1), m_1_part.subs(params).evalf(5),\n                  sp.MatrixSymbol('F_1_max', 3,1), F_1_max.subs(params).evalf(5),\n                  sp.MatrixSymbol('V_1', 3,1), V_1.subs(params).evalf(5))\n\n\\[\\begin{equation}\\mathbf{m}_{1} = \\left[\\begin{matrix}\\frac{3569.5 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\\\frac{5177.3 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\\\frac{5008.3 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F}_{1 max} = \\left[\\begin{matrix}6370.4 \\text{N}\\\\9239.7 \\text{N}\\\\8938.1 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{V}_{1} = \\left[\\begin{matrix}24548.0 \\text{N}\\\\18178.0 \\text{N}\\\\8938.1 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\nAus dem zweiten EMS folglich:\n\nm_2_part = Gamma[1] * M * phi_2\nF_2_max = m_2_part* S_e_2\nV_2 = sp.Matrix([[F_2_max[0]+F_2_max[1]+F_2_max[2]],[F_2_max[1]+F_2_max[2]], [F_2_max[2]]])\n\nrender.eq_display(sp.MatrixSymbol('m_2', 3,1), m_2_part.subs(params).evalf(5),\n                  sp.MatrixSymbol('F_2_max', 3,1), F_2_max.subs(params).evalf(5),\n                  sp.MatrixSymbol('V_2', 3,1), V_2.subs(params).evalf(5))\n\n\\[\\begin{equation}\\mathbf{m}_{2} = \\left[\\begin{matrix}\\frac{2098.0 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\\\frac{329.53 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\- \\frac{1269.4 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F}_{2 max} = \\left[\\begin{matrix}8916.4 \\text{N}\\\\1400.5 \\text{N}\\\\- 5394.8 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{V}_{2} = \\left[\\begin{matrix}4922.1 \\text{N}\\\\- 3994.4 \\text{N}\\\\- 5394.8 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\nAus dem dritten EMS folglich:\n\nm_3_part = Gamma[2] * M * phi_3\nF_3_max = m_3_part* S_e_3\nV_3 = sp.Matrix([[F_3_max[0]+F_3_max[1]+F_3_max[2]],[F_3_max[1]+F_3_max[2]], [F_3_max[2]]])\n\nrender.eq_display(sp.MatrixSymbol('m_3', 3,1), m_3_part.subs(params).evalf(5),\n                  sp.MatrixSymbol('F_3_max', 3,1), F_3_max.subs(params).evalf(5),\n                  sp.MatrixSymbol('V_3', 3,1), V_3.subs(params).evalf(5))\n\n\\[\\begin{equation}\\mathbf{m}_{3} = \\left[\\begin{matrix}\\frac{332.51 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\- \\frac{506.79 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\\\frac{261.12 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F}_{3 max} = \\left[\\begin{matrix}1413.2 \\text{N}\\\\- 2153.9 \\text{N}\\\\1109.8 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{V}_{3} = \\left[\\begin{matrix}369.07 \\text{N}\\\\- 1044.1 \\text{N}\\\\1109.8 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\nMaximale Querkraft aus Überlagerung beider EMS mittels SRSS-Regel.\n\\[\nV_{max} = \\sqrt{V_1^2 + V_2^2 + V_3^2}\n\\tag{14.14}\\]\n\nV_max = (V_1.applyfunc(lambda x: x**2)+V_2.applyfunc(lambda x: x**2)+V_3.applyfunc(lambda x: x**2)).applyfunc(sp.sqrt)\n\n\nrender.eq_display(sp.MatrixSymbol('V_max', 3,1), V_max.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{V}_{max} = \\left[\\begin{matrix}2.5 \\cdot 10^{4} \\text{N}\\\\1.86 \\cdot 10^{4} \\text{N}\\\\1.05 \\cdot 10^{4} \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n14.2.7.2 Biegemomente\nDie Biegemomente lassen sich abschliessend anhand der Querkräfte bestimmen.\n\n\n14.2.7.3 Normalkräfte\nDie Normalkräfte resultieren aus den Punktmassen.\n\n# Querkraft\nV_x = sp.Piecewise((V_max[0].subs(params)/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))), (V_max[1].subs(params)/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))), (V_max[2].subs(params)/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n# Biegemoment\nC_1 = sp.symbols('C_1')\nM_x = sp.integrate(-V_x, x) + C_1\nC_1_solve = sp.solve(M_x.subs(x, (H_1+H_2+H_3).subs(params_plot)), C_1)[0]\nM_x = M_x.subs(C_1, C_1_solve)\n\n# Normalkraft\ng = 10*unit.m/unit.second**2\nN_x = sp.Piecewise(((m_1+m_2+m_3).subs(params)*g/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))),((m_3+m_2).subs(params)*g/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))),((m_3).subs(params)*g/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n\n# Numerische Daten generieren\nx_array = np.linspace(-0.01, float((H_1+H_2+H_3+.01).subs(params_plot)), 1000)\nV_x_lamb = sp.lambdify(x, V_x)\nV_x_array = V_x_lamb(x_array)\n\nM_x_lamb = sp.lambdify(x,M_x)\nM_x_array = M_x_lamb(x_array)\n\nN_x_lamb = sp.lambdify(x,N_x)\nN_x_array = N_x_lamb(x_array)\n\n# Figure und Axes erstellen\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n\n# Ersten Plot erstellen\n\nax1.plot(V_x_array/1000, x_array)\nax1.set_title('$V(x)$')\n\n## Horizontale Linien\nax1.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.set_xlabel('$[kN]$')\nax1.set_ylabel('$[m]$')\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n# Zweiten Plot erstellen\n\nax2.plot(M_x_array/1000, x_array, color='orange')\nax2.set_title('$M(x)$')\n\n## Horizontale Linien\nax2.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.set_xlabel('$[kNm]$')\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Dritten Plot erstellen\n\nax3.plot(N_x_array/1000, x_array, color='green')\nax3.set_title('$N(x)$')\nax3.set_xlabel('$[kN]$')\n\n\n## Horizontale Linien\nax3.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax3.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\n\nax3.axvline(0,linestyle='dashed', color='black')\n\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\nAbbildung 14.5: Maximale Schnittgrössen\n\n\n\n\n\n\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2020). Norm SIA 261:2020 Einwirkungen auf Tragwerke  (136. S.)."
  },
  {
    "objectID": "mms_05.html#aufgabenstellung",
    "href": "mms_05.html#aufgabenstellung",
    "title": "15  Beispiel: Antwortspektrenverfahren an einem Rahmen",
    "section": "15.1 Aufgabenstellung",
    "text": "15.1 Aufgabenstellung\nDies ist eine Weiterführung des bereits bekannten Rahmentragwerks aus ?sec-mms_steif.\n\n\n\nAbbildung 15.1: Statisches System des Rahmentragwerks\n\n\nGesucht:\n\nEigenkreisfrequenz \\(\\omega\\)\nEigenformen - Normierung auf \\[\\phi_1^T =\n\\begin{bmatrix}\n&  1\\\\\n\\end{bmatrix} \\] \\[\\phi_2^T =\n\\begin{bmatrix}\n&  1\\\\\n\\end{bmatrix}\\]\nSkizze der Eigenformen\nStatische Ersatzkräfte mit elastischem Antwortspektrum aus (Schweizerischer Ingenieur- und Architektenverein (SIA), 2020) Abs. 16.2.3 auf Stockwerksebene. Überlagerung mit der SRSS-Methode.\n\nGegeben:\n\nDehnsteifigkeit aller Stäbe \\(E\\cdot A = \\infty\\)\nBaugrundklasse B\nErdbebenzone Z2\n\n\nomega, t,  l, m_1, m_2, E,I, H = sp.symbols('omega, t,  l, m_1, m_2, E, I, H')\n\nomega_n = sp.symbols('omega_n')\n\n\nparams = {E: 30*10**3 *unit.N/unit.mm**2,\n          I:2*10**9*unit.mm**4,\n          m_1:2*20000*unit.N*unit.second**2/unit.m,\n          m_2:20000*unit.N*unit.second**2/unit.m,\n          H:3.2*unit.m,\n          \n          }\n\nparams_plot = convert.param_value(params)\nrender.dict_to_table(params)\n\n\n\nTabelle 15.1: Verwendete Parameter\n\n\n\n\n\n\n\\(E = \\frac{30000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(H = 3.2 \\text{m}\\)\n\n\n\\(I = 2000000000 \\text{mm}^{4}\\)\n\\(m_{1} = \\frac{40000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\n\n\\(m_{2} = \\frac{20000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)"
  },
  {
    "objectID": "mms_05.html#musterlösung",
    "href": "mms_05.html#musterlösung",
    "title": "15  Beispiel: Antwortspektrenverfahren an einem Rahmen",
    "section": "15.2 Musterlösung",
    "text": "15.2 Musterlösung\nDie Lösung deckt sich mit Kapitel 11.2 bis zu den ermittelten Eigenformen.\n\n15.2.1 Steifigkeitsmatrix \\(\\mathbf{K}\\)\n\n15.2.1.1 Horizontale Steifigkeit\n\nk_1, k_2 = sp.symbols('k_1, k_2')\n\nparams['k_1'] = 2*(12 * 2*E*I / H**3).subs(params).simplify().evalf(6)\nparams['k_2'] = 2*(12 * E*I / H**3).subs(params).simplify().evalf(6)\nK = sp.Matrix([[k_1 + k_2, -k_2],[-k_2, k_2]])\n\n\nrender.eq_display(sp.MatrixSymbol('K', 2,2), K,\n                  sp.MatrixSymbol('K', 2,2), K.subs(params),\n                  )\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}k_{1} + k_{2} & - k_{2}\\\\- k_{2} & k_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{1.31836 \\cdot 10^{8} \\text{N}}{\\text{m}} & - \\frac{4.39453 \\cdot 10^{7} \\text{N}}{\\text{m}}\\\\- \\frac{4.39453 \\cdot 10^{7} \\text{N}}{\\text{m}} & \\frac{4.39453 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n15.2.2 Eigenvektoren\n\n15.2.2.1 Massenmatrix \\(\\mathbf{M}\\)\n\nm_1, m_2 = sp.symbols('m_1, m_2')\nM = sp.Matrix([[m_1, 0],[0, m_2]])\n\nrender.eq_display(sp.MatrixSymbol('M', 2,2), M,\n                  sp.MatrixSymbol('M', 2,2), M.subs(params))\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{1} & 0\\\\0 & m_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}\\frac{40000 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{20000 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.2.2 Eigenkreisfrequenzen\n\neq_omega = sp.det(K-omega_n**2*M)\n\nomega_n_solve = sp.solve(eq_omega, omega_n)\nomega_1 = omega_n_solve[1]\nomega_2 = omega_n_solve[3]\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{33.1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{66.3}{\\text{s}}\\end{equation}\\]\n\n\n\n\n15.2.2.3 Eigenvektoren \\(\\phi\\)\n\nphi_11, phi_21, phi_12, phi_22 = sp.symbols('phi_11, phi_21, phi_12, phi_22')\nparams['phi_21'] = 1\n\nphi_1 = sp.Matrix([[phi_11], [phi_21]])\n\nphi_11 = list(sp.solve((K-omega_1**2 *M)*phi_1, phi_11).values())[0]\n\nparams['phi_11'] = phi_11.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.simplify((K-omega_1**2 *M)*phi_1),sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_1', 2,1),sp.simplify(phi_1.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{- k_{2} m_{2} \\phi_{21} + \\frac{\\phi_{11} \\left(- k_{2} m_{1} + m_{2} \\left(k_{1} + k_{2}\\right) + \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{2}}\\\\\\frac{- k_{2} m_{1} \\phi_{11} + \\frac{\\phi_{21} \\left(k_{2} m_{1} - m_{2} \\left(k_{1} + k_{2}\\right) + \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{1}}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0.5\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nparams['phi_22'] = 1\n\nphi_2 = sp.Matrix([[phi_12], [phi_22]])\n\nphi_12 = list(sp.solve((K-omega_2**2 *M)*phi_2, phi_12).values())[0]\n\nparams['phi_12'] = phi_12.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.simplify((K-omega_2**2 *M)*phi_2),sp.Matrix([[0],[0]]),\n                  sp.MatrixSymbol('phi_2', 2,1),sp.simplify(phi_2.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\left[\\begin{matrix}\\frac{- k_{2} m_{2} \\phi_{22} + \\frac{\\phi_{12} \\left(- k_{2} m_{1} + m_{2} \\left(k_{1} + k_{2}\\right) - \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{2}}\\\\\\frac{- k_{2} m_{1} \\phi_{12} + \\frac{\\phi_{22} \\left(k_{2} m_{1} - m_{2} \\left(k_{1} + k_{2}\\right) - \\sqrt{k_{1}^{2} m_{2}^{2} - 2 k_{1} k_{2} m_{1} m_{2} + 2 k_{1} k_{2} m_{2}^{2} + k_{2}^{2} m_{1}^{2} + 2 k_{2}^{2} m_{1} m_{2} + k_{2}^{2} m_{2}^{2}}\\right)}{2}}{m_{1}}\\end{matrix}\\right] = \\left[\\begin{matrix}0\\\\0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2} = \\left[\\begin{matrix}-1.0\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.2.4 Orthogonalitätsbedingung\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_2.T*M*phi_1).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*M*phi_2).subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{3.0 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{6.0 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\nFür die Steifigkeitsmatrix:\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_1.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_2.T*K*phi_2).subs(params)).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_2.T*K*phi_1).subs(params)).evalf(4),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_1.T*K*phi_2).subs(params)).evalf(4))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{3.3 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{2.64 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.2.5 Eigenformen\n\n\n\nAbbildung 15.2: Die beiden Eigenformen skizziert\n\n\n\n\n\n15.2.3 Modale Analyse\nDie Bewegungsgleichung für einen ungedämpften, frei schwingenden Mehrmassenschwinger lässt sich folgend beschreiben:\n\\[\n\\mathbf{M u''(t) + K u = 0}\n\\tag{15.1}\\]\nDie Matrix-Gleichung beschreibt ein System aus Differentialgleichungen. Die Modale Analyse zielt darauf ab, diese zu entkoppeln. Bezogen auf den Mehrmassenschwinger heisst eine Entkoppelung, dass diese in Einmassenschwinger aufgeteilt werden. Dies wird nun schrittweise durchgeführt.\n\n15.2.3.1 Modal- und Spektralmatrix\nMittels der Modal- und Spektralmatrix können die generalisierten Grössen ermittelt werden. Diese sind die Eigenschaften der einzelnen Einmassenschwinger. Die generalisierten Werte besitzen keine physikalische Bedeutung, sie sind abhängig von der Wahl der Eigenvektoren, welche bekanntlich von der Normierung abhängen.\nAnhand der Bewegungsgleichung können die generalisierten Grössen bestimmt werden, es gilt:\n\\[\n\\Phi^T\\mathbf{ M} \\Phi \\mathbf{u''(t)} + \\Phi^T \\mathbf{K} \\Phi \\mathbf{u(t)} = 0\n\\tag{15.2}\\]\n\\[\n\\mathbf{M^*u''(t) + K^* u(t) = 0}\n\\tag{15.3}\\]\nAlle \\(N\\)-Eigenwerte und alle \\(N\\)-Eigenvektoren können kompakt mit Matrizen ausgedrückt werden:\n\nPhi = sp.Matrix([[phi_1, phi_2]])\nOmega = sp.Matrix([[omega_1, 0],[0, omega_2]])\n\nrender.eq_display('Modalmatrix', 'Phi',\n                  sp.MatrixSymbol('Phi', 2, 2), Phi.subs(params).evalf(4),\n                  'Spektralmatrix', 'Omega^2',\n                  sp.MatrixSymbol('Omega^2', 2, 2), (Omega**2).subs(params).evalf(4))\n\n\\[\\begin{equation}Modalmatrix = \\Phi\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Phi} = \\left[\\begin{matrix}0.5 & -1.0\\\\1.0 & 1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}Spektralmatrix = \\Omega^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Omega}^{2} = \\left[\\begin{matrix}\\frac{1099.0}{\\text{s}^{2}} & 0\\\\0 & \\frac{4395.0}{\\text{s}^{2}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.3.2 Generalisierte Grössen\n\nM_star = Phi.T * M * Phi\nK_star = Phi.T * K * Phi\n\n\nrender.eq_display(sp.MatrixSymbol('M^\\star', 2,2),sp.simplify(M_star.subs(params)).evalf(5),\n                  sp.MatrixSymbol('K^\\star', 2,2),sp.simplify(K_star.subs(params)).evalf(5))\n                 \n\n\\[\\begin{equation}\\mathbf{M}^{\\star} = \\left[\\begin{matrix}\\frac{30000.0 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{60000.0 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K}^{\\star} = \\left[\\begin{matrix}\\frac{3.2959 \\cdot 10^{7} \\text{N}}{\\text{m}} & 0\\\\0 & \\frac{2.6367 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.3.3 Kontrolle der modalen Transformation\nDurch die Transformation in generalisierte Grössen dürfen sich die Eigenkreisfrequenzen nicht ändern, da die entkoppelten EMS jeweils eine dieser beschreibt.\nDurch Einsetzen der modalen Grössen in Gleichung 15.4 kann mit den ermittelten Kreisfrequenzen kontrolliert werden.\n\\[\n\\omega_n = \\sqrt{\\frac{k}{m}}\n\\tag{15.4}\\]\n\nomega_1_kontrolle = sp.sqrt(K_star[0] / M_star[0])\nomega_2_kontrolle = sp.sqrt(K_star[3] / M_star[3])\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_1_modal', omega_1_kontrolle.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(4),\n                  'omega_2_modal', omega_2_kontrolle.subs(params).simplify().evalf(4))\n\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{33.1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1 modal} = \\frac{33.1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{66.29}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2 modal} = \\frac{66.29}{\\text{s}}\\end{equation}\\]\n\n\n\n\n15.2.3.4 Partizipationsfaktor \\(\\Gamma\\)\nDurch die modalen Grössen wissen wir wie die entkoppelten Einmassenschwinger definiert sind, bzw. welche Eigenschaften diese besitzen. Die Verteilung des Partizipationsfaktor gibt einen direkten Hinweis, welcher Eigenmode an der Gesamtanwort den grössten Einfluss (beteiligt bzw. partizipiert) hat.\n\\[\n\\Gamma_n = \\frac{\\Phi_n^T \\mathbf{M 1}}{\\Phi_n^T \\mathbf{M}\\Phi_n}\n\\tag{15.5}\\]\nIn allgemeiner Form lautet der Partizipationsfaktor:\n\\[\n\\Gamma_n = \\frac{\\Phi_n^T \\mathbf{M r^\\star}}{\\Phi_n^T \\mathbf{M}\\Phi_n}\n\\tag{15.6}\\]\n\\(\\mathbf{r^\\star}\\) beschreibt die Starrkörperverschiebung infolge der Erdbebenanregung \\(u_g\\) am Fusspunkt des Gesamtsystems.\n\\[\n\\mathbf{r^\\star} = \\begin{bmatrix}\nFHG_1 \\\\\nFHG_2\n\\end{bmatrix}=\n\\begin{bmatrix}\n\\cos(0) \\\\\n\\cos(0)\n\\end{bmatrix}=\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}= \\mathbf{1}\n\\tag{15.7}\\]\nDie Partizipationsmatrix lässt sich direkt durch folgende Gleichung ermitteln:\n\\[\n\\Gamma = M^{\\star-1} \\cdot \\Phi^T \\cdot M \\cdot 1\n\\tag{15.8}\\]\nGelöst mit Gleichung 15.8:\n\none_vec = sp.ones(2,1)\n\nGamma = M_star**-1 * Phi.T * M*one_vec \n\nrender.eq_display(\n    sp.MatrixSymbol('Gamma',2,1), Gamma.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\Gamma} = \\left[\\begin{matrix}1.33\\\\-0.333\\end{matrix}\\right]\\end{equation}\\]\n\n\nGelöst mit Gleichung 15.6:\n\ngamma_1 = (phi_1.T*M*one_vec)[0]/(phi_1.T*M*phi_1)[0]\ngamma_2 = (phi_2.T*M*one_vec)[0]/(phi_2.T*M*phi_2)[0]\ngamma_sqr = sp.Matrix([[gamma_1**2],[gamma_2**2]])\nrender.eq_display('Gamma_1', gamma_1,\n                  'Gamma_1', gamma_1.subs(params).evalf(3),\n                  'Gamma_2', gamma_2,\n                  'Gamma_2', gamma_2.subs(params).evalf(3),\n                  sp.MatrixSymbol('Gamma^2_n',2,1),gamma_sqr.subs(params).evalf(3))\n\n\\[\\begin{equation}\\Gamma_{1} = \\frac{m_{1} \\phi_{11} + m_{2} \\phi_{21}}{m_{1} \\phi_{11}^{2} + m_{2} \\phi_{21}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{1} = 1.33\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{2} = \\frac{m_{1} \\phi_{12} + m_{2} \\phi_{22}}{m_{1} \\phi_{12}^{2} + m_{2} \\phi_{22}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{2} = -0.333\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Gamma}^{2}_{n} = \\left[\\begin{matrix}1.78\\\\0.111\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.3.5 Effektive Modale Massen\nDurch Multiplikation der Modalen Massen mit dem Partizipationsfaktor resultieren die effektiven Modalen Massen.\n\nm_1_eff = gamma_1**2 * M_star[0]\nm_2_eff = gamma_2**2 * M_star[3]\n\nrender.eq_display('m_1eff', m_1_eff.subs(params).evalf(3),\n                  'm_2eff', m_2_eff.subs(params).evalf(3),\n                  'm_tot', (m_1_eff+m_2_eff).subs(params).evalf(3))\n\n\\[\\begin{equation}m_{1eff} = \\frac{5.33 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{2eff} = \\frac{6.67 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{tot} = \\frac{6.0 \\cdot 10^{4} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n15.2.3.6 Modale Höhen\n\none_vec = sp.ones(2,1)\n\n\nH_matrix = sp.Matrix([H, H])\nH_modal = (H_matrix.T*M*Phi).T.multiply_elementwise((Phi.T*M*one_vec).applyfunc(lambda x: x**-1))\n\n\nrender.eq_display(\n    sp.MatrixSymbol('H', 2,1), H_matrix,\n    sp.MatrixSymbol('H', 2,1), H_modal,\n    sp.MatrixSymbol('H', 2,1), H_modal.subs(params).evalf(3),\n\n)\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}H\\\\H\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}\\frac{H m_{1} \\phi_{11} + H m_{2} \\phi_{21}}{m_{1} \\phi_{11} + m_{2} \\phi_{21}}\\\\\\frac{H m_{1} \\phi_{12} + H m_{2} \\phi_{22}}{m_{1} \\phi_{12} + m_{2} \\phi_{22}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}3.2 \\text{m}\\\\3.2 \\text{m}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nhoehe = list(H_modal.subs(params).evalf(3)/unit.m)\nhoehe = [np.float64(i).round(2) for i in hoehe]\n\nmasse = list(M_star.subs(params)/unit.N/unit.second**2 * unit.m)\nmasse = [np.float64(i).round(2) for i in masse if i != 0]\n\nsteifigkeiten = list(K_star.subs(params)/unit.N * unit.m)\nsteifigkeiten = [np.float64(i).round(2) for i in steifigkeiten if i != 0]\n\nomegas = list(Omega.subs(params)*unit.second)\nomegas = [np.float64(i).round(2) for i in omegas if i != 0]\n\ngammas = list(Gamma.subs(params).evalf(3))\ngammas = [np.float64(i).round(2) for i in gammas if i != 0]\n\n\nplot_einmassenschwinger(hoehe, masse, steifigkeiten, omegas, gammas)\n\n\n\n\nAbbildung 15.3: Darstellung der entkoppelten Einmassenschwinger\n\n\n\n\n\n\n\n15.2.4 Elastisches Antwortspektrum\nDem Vorgehen nach (Schweizerischer Ingenieur- und Architektenverein (SIA), 2020) Abs. 16.2.3.1 entsprechend, werden folgende Parameter definiert:\n\nBaugrundklasse B\nErdbebenzone Z2\n\\(a_{gd} = 1.0 \\text{ M}/\\text{s}^2\\)\n\n\na_gd = 1*unit.m/unit.second**2\n\n\n15.2.4.1 Grundschwingzeit\nDie Grundschwingzeit kann anhand der bereits ermittelten Eigenkreisfrequenzen ermittelt werden.\n\nT_1 = (omega_1 /(2*sp.pi))**-1\nT_2 = (omega_2 /(2*sp.pi))**-1\n\nrender.eq_display('T_1', T_1.subs(params).evalf(3),\n                  'T_2', T_2.subs(params).evalf(3),\n                  )\n\n\\[\\begin{equation}T_{1} = 0.19 \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{2} = 0.0948 \\text{s}\\end{equation}\\]\n\n\n\n\n15.2.4.2 Elastisches Antwortspektrum\n\n\nS_e_1 = antwortspektrum(a_gd, T_1.subs(params).evalf(3), Baugrundklasse='B')\nrender.eq_display('S_e_1', S_e_1.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = 2.5 S_{} a_{gd} \\eta\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 1} = \\frac{3.0 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\nS_e_2 = antwortspektrum(a_gd, T_2.subs(params).evalf(3), Baugrundklasse='B')\n\nrender.eq_display('S_e_2', S_e_2.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = 2.5 S_{} a_{gd} \\eta\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 2} = \\frac{3.0 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n\n15.2.4.3 Einwirkungen\n\nf_11 = gamma_1*m_1_eff*phi_11*S_e_1\nf_21 = gamma_1*m_2_eff*phi_21*S_e_1\n\nf_12 = gamma_2*m_1_eff*phi_12*S_e_2\nf_22 = gamma_2*m_2_eff*phi_22*S_e_2\n\n\nf_jn = sp.Matrix([[f_11, f_12],[f_12,f_22]])\n\nrender.eq_display(\"f_11 \", \"gamma_1*m_1_eff*phi_11*S_e_1\",\n\"f_21\" , \"gamma_1*m_2_eff*phi_21*S_e_1\",\n\"f_12\" , \"gamma_2*m_1_eff*phi_12*S_e_2\",\n\"f_22\" , \"gamma_2*m_2_eff*phi_22*S_e_2\",\n\n\nsp.MatrixSymbol('f_jn', 2,2),f_jn.subs(params).evalf(3))\n\n\\[\\begin{equation}f_{11} = S_{e 1} \\gamma_{1} m_{1 eff} \\phi_{11}\\end{equation}\\]\n\n\n\\[\\begin{equation}f_{21} = S_{e 1} \\gamma_{1} m_{2 eff} \\phi_{21}\\end{equation}\\]\n\n\n\\[\\begin{equation}f_{12} = S_{e 2} \\gamma_{2} m_{1 eff} \\phi_{12}\\end{equation}\\]\n\n\n\\[\\begin{equation}f_{22} = S_{e 2} \\gamma_{2} m_{2 eff} \\phi_{22}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{f}_{jn} = \\left[\\begin{matrix}1.07 \\cdot 10^{5} \\text{N} & 5.33 \\cdot 10^{4} \\text{N}\\\\5.33 \\cdot 10^{4} \\text{N} & - 6.67 \\cdot 10^{3} \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n15.2.4.4 Deformation\n\nu_11 = gamma_1*phi_11*S_e_1/omega_1**2\nu_21 = gamma_1*phi_21*S_e_1/omega_1**2\nu_12 = gamma_2*phi_12*S_e_2/omega_2**2\nu_22 = gamma_2*phi_22*S_e_2/omega_2**2\n\n\nu_jn = sp.Matrix([[u_11, u_12],[u_12,u_22]])\n\nrender.eq_display(\n    \"u_11\" ,\" gamma_1*phi_11*S_e_1/omega_1**2\",\n    \"u_21\" , \"gamma_1*phi_21*S_e_1/omega_1**2\",\n    \"u_12\" , \"gamma_2*phi_12*S_e_2/omega_2**2\",\n    \"u_22\" ,\"gamma_2*phi_22*S_e_2/omega_2**2\",\n    sp.MatrixSymbol('u_jn', 2,2),unit.convert_to(u_jn.subs(params).evalf(3),unit.mm))\n\n\\[\\begin{equation}u_{11} = \\frac{S_{e 1} \\gamma_{1} \\phi_{11}}{\\omega_{1}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{21} = \\frac{S_{e 1} \\gamma_{1} \\phi_{21}}{\\omega_{1}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{12} = \\frac{S_{e 2} \\gamma_{2} \\phi_{12}}{\\omega_{2}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{22} = \\frac{S_{e 2} \\gamma_{2} \\phi_{22}}{\\omega_{2}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{u}_{jn} = \\left[\\begin{matrix}1.82 \\text{mm} & 0.228 \\text{mm}\\\\0.228 \\text{mm} & - 0.228 \\text{mm}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n15.2.5 Überlagerung der EMS\nUm die Entkoppelung rückzuführen, gilt es die erhaltenen Resultate zu überlagern. Dabei gibt es unterschiedliche Ansätze. Bei weit auseinander liegenden Eigenfrequenzen kann die SRSS-Überlagerung verwendet werden.\n\\[\nV_{b2max} = \\sqrt{\\sum_{n=1}^2 f_{j,n}^2}\n\\tag{15.9}\\]\n\nV_b1_max = sp.sqrt(f_11**2 + f_12**2)\nV_b2_max = sp.sqrt(f_21**2 + f_22**2)\n\nrender.eq_display(\"V_b1_max\" ,\"sqrt(f_11**2 + f_12**2)\",\n'V_b1max',V_b1_max.subs(params).evalf(3),\n\"V_b2_max\" , \"sqrt(f_21**2 + f_22**2)\",\n'V_b2max', V_b2_max.subs(params).evalf(3))\n\n\\[\\begin{equation}V_{b1 max} = \\sqrt{f_{11}^{2} + f_{12}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{b1max} = 1.19 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{b2 max} = \\sqrt{f_{21}^{2} + f_{22}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}V_{b2max} = 2.75 \\cdot 10^{4} \\text{N}\\end{equation}\\]\n\n\nDeformationen:\n\\[\nu_{bn} = \\sqrt{\\sum_{n=1}^2 u_{j,n}^2}\n\\tag{15.10}\\]\n\nu_b1 = sp.sqrt(u_11**2 + u_12**2)\nu_b2 = sp.sqrt(u_21**2 + u_22**2)\n\nrender.eq_display(\n\"u_b1\" , \"sqrt(u_11**2 + u_12**2)\",\n'u_b1',unit.convert_to(u_b1.subs(params).evalf(3), unit.mm),\n\"u_b2\", \"sqrt(u_21**2 + u_22**2)\",\n'u_b2', unit.convert_to(u_b2.subs(params).evalf(3),unit.mm))\n\n\\[\\begin{equation}u_{b1} = \\sqrt{u_{11}^{2} + u_{12}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{b1} = 1.83 \\text{mm}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{b2} = \\sqrt{u_{21}^{2} + u_{22}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{b2} = 3.65 \\text{mm}\\end{equation}\\]\n\n\n\n# Querkraft\nV_x = sp.Piecewise((V_b1_max.subs(params)/unit.N, ((x&gt;0)&(x&lt;=H.subs(params_plot)))), (V_b2_max.subs(params)/unit.N, ((x&gt;=H.subs(params_plot))&(x&lt;=(H+H).subs(params_plot)))), (0,True))\n\n# Biegemoment\nC_1 = sp.symbols('C_1')\nM_x = sp.integrate(-V_x, x) + C_1\nC_1_solve = sp.solve(M_x.subs(x, (H+H).subs(params_plot)), C_1)[0]\nM_x = M_x.subs(C_1, C_1_solve)\n\n# Normalkraft\ng = 10*unit.m/unit.second**2\nN_x = sp.Piecewise(((m_1+m_2).subs(params)*g/unit.N, ((x&gt;0)&(x&lt;=H.subs(params_plot)))),(m_1.subs(params)*g/unit.N, ((x&gt;=H.subs(params_plot))&(x&lt;=(H+H).subs(params_plot)))), (0,True))\n\n\n\n# Numerische Daten generieren\n\nx_array = np.linspace(-0.01, float((H+H+0.01).subs(params_plot)), 1000)\n\n\n\nV_x_lamb = sp.lambdify(x, V_x)\nV_x_array = V_x_lamb(x_array)\n\nM_x_lamb = sp.lambdify(x,M_x)\nM_x_array = M_x_lamb(x_array)\n\nN_x_lamb = sp.lambdify(x,N_x)\nN_x_array = N_x_lamb(x_array)\n\n# Figure und Axes erstellen\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n\n# Ersten Plot erstellen\n\nax1.plot(V_x_array/1000, x_array)\nax1.set_title('$V(x)$')\n\n## Horizontale Linien\nax1.axhline(H.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H+H).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.set_xlabel('$[kN]$')\nax1.set_ylabel('$[m]$')\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n# Zweiten Plot erstellen\n\nax2.plot(M_x_array/1000, x_array, color='orange')\nax2.set_title('$M(x)$')\n\n## Horizontale Linien\nax2.axhline(H.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H+H).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.set_xlabel('$[kNm]$')\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Dritten Plot erstellen\n\nax3.plot(N_x_array/1000, x_array, color='green')\nax3.set_title('$N(x)$')\nax3.set_xlabel('$[kN]$')\n\n\n## Horizontale Linien\nax3.axhline(H.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax3.axhline((H+H).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\n\nax3.axvline(0,linestyle='dashed', color='black')\n\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\n\n\nAbbildung 15.4: Maximale Schnittgrössen\n\n\n\n\n\n\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2020). Norm SIA 261:2020 Einwirkungen auf Tragwerke  (136. S.)."
  },
  {
    "objectID": "mms_06.html#aufgabenstellung",
    "href": "mms_06.html#aufgabenstellung",
    "title": "16  Beispiel: Antwortspektrenverfahren an einem zweistöckigen Gebäude",
    "section": "16.1 Aufgabenstellung",
    "text": "16.1 Aufgabenstellung\n\n\n\nAbbildung 16.1: Statisches System des zweistöckigen Gebäudes\n\n\nGesucht:\n\nEigenfrequenzen \\(\\omega_n\\)\nDarstellung der Eigenformen\nModal- und Spektralmatrix\nMaximale Gesamtverformung mittels SRSS-Kombinationsregel aus dem Antwortspektrum der Pseudobeschleunigung.\nResultierende Schnittgrössen\n\nGegeben:\n\nBaugrundklasse \\(E\\)\nErdbebenzone \\(Z2\\)\n\n\nparams = {'EI_ac': 5.5*10**5 *unit.N*unit.m**2,\n'EI_d': 2.5*10**5 *unit.N*unit.m**2,\n          'm_1':2100*unit.N*unit.second**2/unit.m,\n          'm_2':4800*unit.N*unit.second**2/unit.m,\n          'H_1':3.81*unit.m,\n          'H_2':3*unit.m,\n          }\n\nparams_plot = convert.param_value(params)\nrender.dict_to_table(params)\n\n\n\nTabelle 16.1: Verwendete Parameter\n\n\n\n\n\n\n\\(EI_{ac} = 550000.0 \\text{m}^{2} \\text{N}\\)\n\\(EI_{d} = 250000.0 \\text{m}^{2} \\text{N}\\)\n\n\n\\(H_{1} = 3.81 \\text{m}\\)\n\\(H_{2} = 3 \\text{m}\\)\n\n\n\\(m_{1} = \\frac{2100 \\text{N} \\text{s}^{2}}{\\text{m}}\\)\n\\(m_{2} = \\frac{4800 \\text{N} \\text{s}^{2}}{\\text{m}}\\)"
  },
  {
    "objectID": "mms_06.html#musterlösung",
    "href": "mms_06.html#musterlösung",
    "title": "16  Beispiel: Antwortspektrenverfahren an einem zweistöckigen Gebäude",
    "section": "16.2 Musterlösung",
    "text": "16.2 Musterlösung\n\n16.2.1 Massenmatrix \\(M\\)\n\n\n\nAbbildung 16.2: Auslenkung der Massen zur Ermittlung der Matrizen\n\n\n\nm_1, m_2 = sp.symbols('m_1, m_2')\n\n\nM = sp.Matrix([[m_1,0],[0,m_2]])\n\nrender.eq_display(sp.MatrixSymbol('M', 2, 2), M,\n                  sp.MatrixSymbol('M', 2, 2), M.subs(params))\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{1} & 0\\\\0 & m_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}\\frac{2100 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{4800 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.2 Steifigkeitsmatrix \\(K\\)\n\n16.2.2.1 Steifigkeit der Stockwerke\nDie Steifigkeit des Systems in Abbildung 16.1 entspricht der Geschosssteifigkeit. Dazu sind die Steifigkeiten der Stützen zu addieren.\n\nEI_ac, EI_d, H_1, H_2 = sp.symbols(\"EI_ac, EI_d, H_1, H_2\")\n\n\nk_1 = 12 * EI_ac /H_1**3 * 2\nk_2 = 12*EI_ac / H_2**3 + 12*EI_d / H_2**3\n\nrender.eq_display(\"k_1\", k_1,\n'k_1', k_1.subs(params).simplify().evalf(3),\n\"k_2\", k_2,\n'k_2', k_2.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}k_{1} = \\frac{24 EI_{ac}}{H_{1}^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{1} = \\frac{2.39 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2} = \\frac{12 EI_{ac}}{H_{2}^{3}} + \\frac{12 EI_{d}}{H_{2}^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2} = \\frac{3.56 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\nAbgefüllt in die Steifigkeitsmatrix\n\nK = sp.Matrix([[k_1 + k_2, -k_2],[-k_2, k_2]])\n\nrender.eq_display(sp.MatrixSymbol('K', 2, 2), \"Matrix([[k_1 + k_2, -k_2],[-k_2, k_2]])\",\nsp.MatrixSymbol('K', 2, 2), K,\n                  sp.MatrixSymbol('K', 2, 2), K.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}k_{1} + k_{2} & - k_{2}\\\\- k_{2} & k_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{12 EI_{ac}}{H_{2}^{3}} + \\frac{24 EI_{ac}}{H_{1}^{3}} + \\frac{12 EI_{d}}{H_{2}^{3}} & - \\frac{12 EI_{ac}}{H_{2}^{3}} - \\frac{12 EI_{d}}{H_{2}^{3}}\\\\- \\frac{12 EI_{ac}}{H_{2}^{3}} - \\frac{12 EI_{d}}{H_{2}^{3}} & \\frac{12 EI_{ac}}{H_{2}^{3}} + \\frac{12 EI_{d}}{H_{2}^{3}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K} = \\left[\\begin{matrix}\\frac{5.94 \\cdot 10^{5} \\text{N}}{\\text{m}} & - \\frac{3.56 \\cdot 10^{5} \\text{N}}{\\text{m}}\\\\- \\frac{3.56 \\cdot 10^{5} \\text{N}}{\\text{m}} & \\frac{3.56 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n16.2.3 Eigenvektoren\n\n16.2.3.1 Eigenkreisfrequenzen\nBei einem Mehrmassenschwinger gibt es entsprechend den Freiheitsgraden Eigenkreisfrequenzen \\(\\omega_n\\). Diese lassen sich anhand folgender Gleichung bestimmen:\n\\[\n\\det{[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]=0}\n\\tag{16.1}\\]\n\nomega_n =sp.symbols('omega_n')\neq_omega = sp.det(K-omega_n**2*M)\n\nomega_n_solve = sp.solve(eq_omega, omega_n)\nomega_1 = omega_n_solve[1]\nomega_2 = omega_n_solve[3]\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{5.04}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{18.2}{\\text{s}}\\end{equation}\\]\n\n\n\n\n16.2.3.2 Eigenvektoren \\(\\phi\\)\nDurch das Einsetzen der bestimmten Eigenkreisfrequenzen lassen sich die Eigenvektoren bestimmen. Die Einträge des Eigenvektors sind voneinander abhängig und lassen sich dem Entsprechen beliebig definieren. Grundsätzlich wird der maximale Eigenwert zu \\(1\\) gesetzt.\n\\[\n\\mathbf{K} - \\omega_n^2 \\mathbf{M} \\phi_n= 0\n\\tag{16.2}\\]\n\nphi_11, phi_21 = sp.symbols('phi_11, phi_21')\nparams['phi_11'] = 1 \n\n\nphi_1 = sp.Matrix([[phi_11], [phi_21]])\nphi_21 = list(sp.solve((K-omega_1**2 *M)*phi_1, phi_21).values())[0]\n\n\nparams['phi_21'] = phi_21.subs(params).simplify() \nparams['phi_11'] = 1/phi_21.subs(params).simplify() \nparams['phi_21'] = 1\n\n\nrender.eq_display(sp.MatrixSymbol('phi_1', 2,1),sp.simplify(phi_1.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1} = \\left[\\begin{matrix}0.657\\\\1.0\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nphi_12, phi_22 = sp.symbols('phi_12, phi_22')\nparams['phi_12'] = 1\n\nphi_2 = sp.Matrix([[phi_12], [phi_22]])\n\nphi_22 = list(sp.solve((K-omega_2**2 *M)*phi_2, phi_22).values())[0]\n\nparams['phi_22'] = phi_22.subs(params).simplify() \n\n\n\n\nrender.eq_display(sp.MatrixSymbol('phi_2', 2,1),sp.simplify(phi_2.subs(params)).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2} = \\left[\\begin{matrix}1.0\\\\-0.288\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.3.3 Darstellung der Eigenvektoren\nDie Darstellung der Eigenvektoren besteht aus der Biegedeformation mit den Eigenvektoren entsprechenden Kopfauslenkungen. Für den Fall einer beidseitigen Einspannung und einer Verschiebung an den Knoten, entspricht die Deformation der Gleichung 16.3.\n\\[\nw(x) = \\Delta_A + (\\Delta_B- \\Delta_A)(3\\xi^2 - 2 \\xi^3)\n\\tag{16.3}\\]\nmit \\[\n\\xi = \\frac{x}{l}\n\\tag{16.4}\\]\nwobei \\(x\\) die Laufvariable ist und \\(l\\) die Stablänge, oder in diesem Fall die Stockwerkshöhe.\nFür den ersten Eigenvektor\n\nDelta_A, Delta_B, zeta = sp.symbols('Delta_A, Delta_B, zeta')\n\n\n\n#Ansatzfunktion für Teil 1 der Funktion\nzeta = x/l\nw_ansatz = Delta_A + (Delta_B-Delta_A)*(3*zeta**2 - 2*zeta**3)\nrender.eq_display('w(x)', w_ansatz)\n\nw_1_x = w_ansatz.subs(Delta_A, 0).subs(Delta_B, phi_11.subs(params)).subs(l,H_1.subs(params_plot))\n\n\n\n\n#Ansatzfunktion für Teil 2 der Funktion\nzeta = (x-H_1.subs(params_plot))/l\nw_ansatz = Delta_A + (Delta_B-Delta_A)*(3*zeta**2 - 2*zeta**3)\nrender.eq_display('w(x)', w_ansatz.evalf(2))\n\nw_2_x = w_ansatz.subs(Delta_A, phi_11.subs(params)).subs(Delta_B, phi_21.subs(params)).subs(l,H_2.subs(params_plot))\n\n\n\n#Zusammengestellt\nw_eigenform_1 = sp.Eq(w,sp.Piecewise((w_1_x, x&lt;=H_1.subs(params_plot)),(w_2_x, x&gt;=H_1.subs(params_plot))))\nrender.eq_display(w_eigenform_1.lhs, w_eigenform_1.rhs.evalf(2))\n\n\\[\\begin{equation}w{\\left(x \\right)} = \\Delta_{A} + \\left(- \\Delta_{A} + \\Delta_{B}\\right) \\left(\\frac{3 x^{2}}{l^{2}} - \\frac{2 x^{3}}{l^{3}}\\right)\\end{equation}\\]\n\n\n\\[\\begin{equation}w{\\left(x \\right)} = \\Delta_{A} + \\left(- \\Delta_{A} + \\Delta_{B}\\right) \\left(\\frac{44.0 \\left(0.26 x - 1.0\\right)^{2}}{l^{2}} - \\frac{1.1 \\cdot 10^{2} \\left(0.26 x - 1.0\\right)^{3}}{l^{3}}\\right)\\end{equation}\\]\n\n\n\\[\\begin{equation}w = \\begin{cases} - 0.024 x^{3} + 0.14 x^{2} & \\text{for}\\: x \\leq 3.81 \\\\- 1.4 \\left(0.26 x - 1.0\\right)^{3} + 1.7 \\left(0.26 x - 1.0\\right)^{2} + 0.66 & \\text{for}\\: x \\geq 3.81 \\end{cases}\\end{equation}\\]\n\n\nFür den zweiten Eigenvektor. (Es bedingt eine Verschiebung der Laufvariable \\(x\\) um die \\(H_1\\))\n\nDelta_A, Delta_B, zeta = sp.symbols('Delta_A, Delta_B, zeta')\n\n\n\n#Ansatzfunktion für Teil 1 der Funktion\nzeta = x/l\nw_ansatz = Delta_A + (Delta_B-Delta_A)*(3*zeta**2 - 2*zeta**3)\nrender.eq_display('w(x)', w_ansatz)\n\nw_12_x = w_ansatz.subs(Delta_A, 0).subs(Delta_B, phi_12.subs(params)).subs(l,H_1.subs(params_plot))\n\n\n\n\n#Ansatzfunktion für Teil 2 der Funktion\nzeta = (x-H_1.subs(params_plot))/l\nw_ansatz = Delta_A + (Delta_B-Delta_A)*(3*zeta**2 - 2*zeta**3)\nrender.eq_display('w(x)', w_ansatz.evalf(2))\n\nw_22_x = w_ansatz.subs(Delta_A, phi_12.subs(params)).subs(Delta_B, phi_22.subs(params)).subs(l,H_2.subs(params_plot))\n\n\n\n#Zusammengestellt\nw_eigenform_2 = sp.Eq(w,sp.Piecewise((w_12_x, x&lt;=H_1.subs(params_plot)),(w_22_x, x&gt;=H_1.subs(params_plot))))\nrender.eq_display(w_eigenform_2.lhs, w_eigenform_2.rhs.evalf(2))\n\n\\[\\begin{equation}w{\\left(x \\right)} = \\Delta_{A} + \\left(- \\Delta_{A} + \\Delta_{B}\\right) \\left(\\frac{3 x^{2}}{l^{2}} - \\frac{2 x^{3}}{l^{3}}\\right)\\end{equation}\\]\n\n\n\\[\\begin{equation}w{\\left(x \\right)} = \\Delta_{A} + \\left(- \\Delta_{A} + \\Delta_{B}\\right) \\left(\\frac{44.0 \\left(0.26 x - 1.0\\right)^{2}}{l^{2}} - \\frac{1.1 \\cdot 10^{2} \\left(0.26 x - 1.0\\right)^{3}}{l^{3}}\\right)\\end{equation}\\]\n\n\n\\[\\begin{equation}w = \\begin{cases} - 0.036 x^{3} + 0.21 x^{2} & \\text{for}\\: x \\leq 3.81 \\\\5.3 \\left(0.26 x - 1.0\\right)^{3} - 6.2 \\left(0.26 x - 1.0\\right)^{2} + 1.0 & \\text{for}\\: x \\geq 3.81 \\end{cases}\\end{equation}\\]\n\n\n\n#Numerische Daten generieren\nw_eigenform_1_lamb = sp.lambdify(x, w_eigenform_1.rhs)\nw_eigenform_2_lamb = sp.lambdify(x, w_eigenform_2.rhs)\n\nx_array = np.linspace(0, float((H_1+H_2).subs(params_plot)), 1000)\n\nw_1_array = w_eigenform_1_lamb(x_array)\nw_2_array = w_eigenform_2_lamb(x_array)\n\n\n# Figure und Axes erstellen\nfig, (ax1, ax2) = plt.subplots(1, 2)\n\n# Ersten Plot erstellen\n\nax1.plot(w_1_array, x_array)\nax1.set_title('$\\phi_1$')\n\n## Horizontale Linien\nax1.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.axvline(phi_21.subs(params),linestyle='dashed', color='gray',linewidth=1)\nax1.axvline(phi_11.subs(params),linestyle='dashed', color='gray',linewidth=1)\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n\n\n# Zweiten Plot erstellen\n\nax2.plot(w_2_array, x_array)\nax2.set_title('$\\phi_2$')\n\n## Horizontale Linien\nax2.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.axvline(phi_22.subs(params),linestyle='dashed', color='gray',linewidth=1)\nax2.axvline(phi_12.subs(params),linestyle='dashed', color='gray',linewidth=1)\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\n\n\nAbbildung 16.3: Deformation des Mehrmassenschwingers anhand der Eigenvektoren\n\n\n\n\n\n\n\n16.2.4 Modale Analyse\nDie Modale Analyse zielt darauf ab, den Mehrmassenschwinger zu entkoppeln. Dazu wird in einem ersten Schritt die Orthogonalitätsbedingung kontrolliert. Diese muss erfüllt sein, um eine Entkoppelung durchzuführen. Siehe Kapitel 12.2.2.4 für eine ausführliche Erklärung.\n\n16.2.4.1 Orthogonalitätsbedingung\nAngewendet auf die Massenmatrix: Es zeigen sich kleine numerische Unreinheiten, welche vernachlässigt werden können.\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_1.T*M*phi_1).subs(params).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_2.T*M*phi_2).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_1',2,1),(phi_2.T*M*phi_1).subs(params).evalf(3),\n\n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('M', 2,2)*sp.MatrixSymbol('phi_2',2,1),(phi_1.T*M*phi_2).subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{5.71 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{2.5 \\cdot 10^{3} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{M} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{1.59 \\cdot 10^{-12} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{M} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{1.59 \\cdot 10^{-12} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\nFür die Steifigkeitsmatrix:\n\nrender.eq_display(sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_1.T*K*phi_1).subs(params)).evalf(3),\n                  \n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_2.T*K*phi_2).subs(params)).evalf(3),\n\n                  sp.MatrixSymbol('phi_2',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_1',2,1),sp.simplify((phi_2.T*K*phi_1).subs(params)).evalf(4),\n                  \n                  sp.MatrixSymbol('phi_1',2,1).T*sp.MatrixSymbol('K', 2,2)*sp.MatrixSymbol('phi_2',2,1),sp.simplify((phi_1.T*K*phi_2).subs(params)).evalf(4))\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{1.45 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{8.28 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{2}^{T} \\mathbf{K} \\mathbf{\\phi}_{1} = \\left[\\begin{matrix}\\frac{9.459 \\cdot 10^{-11} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\phi}_{1}^{T} \\mathbf{K} \\mathbf{\\phi}_{2} = \\left[\\begin{matrix}\\frac{9.459 \\cdot 10^{-11} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.4.2 Modal- und Spektralmatrix\nMittels der Modal- und Spektralmatrix lassen sich die generalisierten Grössen effizient ermitteln.\n\nPhi = sp.Matrix([[phi_1, phi_2]])\nOmega = sp.Matrix([[omega_1, 0],[0, omega_2]])\n\nrender.eq_display('Modalmatrix', 'Phi',\n                  sp.MatrixSymbol('Phi', 2, 2), Phi.subs(params).evalf(4),\n                  'Spektralmatrix', 'Omega^2',\n                  sp.MatrixSymbol('Omega^2', 2, 2), (Omega**2).subs(params).evalf(4))\n\n\\[\\begin{equation}Modalmatrix = \\Phi\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Phi} = \\left[\\begin{matrix}0.6573 & 1.0\\\\1.0 & -0.2876\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}Spektralmatrix = \\Omega^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Omega}^{2} = \\left[\\begin{matrix}\\frac{25.38}{\\text{s}^{2}} & 0\\\\0 & \\frac{331.7}{\\text{s}^{2}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.4.3 Generalisierte Grössen\n\nM_star = Phi.T * M * Phi\nK_star = Phi.T * K * Phi\n\n\nM_star_clean = set_small_values_to_zero(M_star.subs(params).evalf(5), 0.1*unit.N *unit.second**2 / unit.m)\nK_star_clean = set_small_values_to_zero(K_star.subs(params).evalf(5), 0.1*unit.N  / unit.m)\n\nrender.eq_display(sp.MatrixSymbol('M^\\star', 2,2),sp.simplify(M_star_clean.subs(params)).evalf(5),\n                  sp.MatrixSymbol('K^\\star', 2,2),sp.simplify(K_star_clean.subs(params)).evalf(5))\n                 \n\n\\[\\begin{equation}\\mathbf{M}^{\\star} = \\left[\\begin{matrix}\\frac{5707.3 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & \\frac{2497.0 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K}^{\\star} = \\left[\\begin{matrix}\\frac{1.4487 \\cdot 10^{5} \\text{N}}{\\text{m}} & 0\\\\0 & \\frac{8.2813 \\cdot 10^{5} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.4.4 Modale Höhen\nDie modalen Höhen bestimmen sich aus Gleichung 16.5:\n\\[\nH_n = \\frac{L_n^\\theta}{L_n}\n\\tag{16.5}\\]\n\\[\nL_n = \\phi_n^T \\cdot \\mathbf{M 1}\n\\tag{16.6}\\]\n\\[\nL_n^\\theta = \\sum_{j=1}^N H_j \\cdot m_j \\cdot \\phi_{jn}\n\\tag{16.7}\\]\nAngewendet auf das Beispiel folgt:\n\none_vec = sp.ones(2,1)\n\n\nH_matrix = sp.Matrix([H_1, H_2])\nH_modal = (H_matrix.T*M*Phi).T.multiply_elementwise((M*Phi.T*one_vec).applyfunc(lambda x: x**-1))\n\n\nrender.eq_display(\n    sp.MatrixSymbol('H', 2,1), H_matrix,\n    sp.MatrixSymbol('H', 2,1), H_modal,\n    sp.MatrixSymbol('H', 2,1), H_modal.subs(params).evalf(3),\n\n)\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}H_{1}\\\\H_{2}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}\\frac{H_{1} m_{1} \\phi_{11} + H_{2} m_{2} \\phi_{21}}{m_{1} \\phi_{11} + m_{1} \\phi_{21}}\\\\\\frac{H_{1} m_{1} \\phi_{12} + H_{2} m_{2} \\phi_{22}}{m_{2} \\phi_{12} + m_{2} \\phi_{22}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{H} = \\left[\\begin{matrix}5.65 \\text{m}\\\\1.13 \\text{m}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.4.5 Kontrolle der modalen Transformation\nDie Eigenkreisfrequenzen ändern sich durch die Transformation nicht.\n\nomega_1_kontrolle = sp.sqrt(K_star[0] / M_star[0])\nomega_2_kontrolle = sp.sqrt(K_star[3] / M_star[3])\n\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3),\n                  'omega_1_modal', omega_1_kontrolle.subs(params).simplify().evalf(3),\n                  'omega_2', omega_2.subs(params).simplify().evalf(4),\n                  'omega_2_modal', omega_2_kontrolle.subs(params).simplify().evalf(4))\n\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{5.04}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1 modal} = \\frac{5.04}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2} = \\frac{18.21}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2 modal} = \\frac{18.21}{\\text{s}}\\end{equation}\\]\n\n\n\n\n16.2.4.6 Partizipationsfaktor \\(\\Gamma\\)\nDie Verteilung des Partizipationsfaktor gibt einen direkten Hinweis, welcher Eigenmode an der Gesamtanwort den grössten Einfluss (beteiligt bzw. partizipiert) hat.\n\\[\n\\Gamma_n = \\frac{\\Phi_n^T \\mathbf{M 1}}{\\Phi_n^T \\mathbf{M}\\Phi_n}\n\\tag{16.8}\\]\nIn allgemeiner Form lautet der Partizipationsfaktor:\n\\[\n\\Gamma_n = \\frac{\\Phi_n^T \\mathbf{M r^\\star}}{\\Phi_n^T \\mathbf{M}\\Phi_n}\n\\tag{16.9}\\]\n\\(\\mathbf{r^\\star}\\) beschreibt die Starrkörperverschiebung infolge der Erdbebenanregung \\(u_g\\) am Fusspunkt des Gesamtsystems.\n\\[\n\\mathbf{r^\\star} = \\begin{bmatrix}\nFHG_1 \\\\\nFHG_2\n\\end{bmatrix}=\n\\begin{bmatrix}\n\\cos(0) \\\\\n\\cos(0)\n\\end{bmatrix}=\n\\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}= \\mathbf{1}\n\\tag{16.10}\\]\nDie Partizipationsmatrix lässt sich direkt durch folgende Gleichung ermitteln:\n\\[\n\\Gamma = M^{\\star-1} \\cdot \\Phi^T \\cdot M \\cdot 1\n\\tag{16.11}\\]\nGelöst mit Gleichung 16.11:\n\none_vec = sp.ones(2,1)\n\nGamma = M_star**-1 * Phi.T * M*one_vec \n\nrender.eq_display(\n    sp.MatrixSymbol('Gamma',2,1), Gamma.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{\\Gamma} = \\left[\\begin{matrix}1.08\\\\0.288\\end{matrix}\\right]\\end{equation}\\]\n\n\nGelöst mit Gleichung 16.9:\n\n\n\ngamma_1 = (phi_1.T*M*one_vec)[0]/(phi_1.T*M*phi_1)[0]\ngamma_2 = (phi_2.T*M*one_vec)[0]/(phi_2.T*M*phi_2)[0]\ngamma_sqr = sp.Matrix([[gamma_1**2],[gamma_2**2]])\nrender.eq_display('Gamma_1', gamma_1,\n                  'Gamma_1', gamma_1.subs(params).evalf(3),\n                  'Gamma_2', gamma_2,\n                  'Gamma_2', gamma_2.subs(params).evalf(3),\n                  sp.MatrixSymbol('Gamma^2_n',2,1),gamma_sqr.subs(params).evalf(3))\n\n\\[\\begin{equation}\\Gamma_{1} = \\frac{m_{1} \\phi_{11} + m_{2} \\phi_{21}}{m_{1} \\phi_{11}^{2} + m_{2} \\phi_{21}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{1} = 1.08\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{2} = \\frac{m_{1} \\phi_{12} + m_{2} \\phi_{22}}{m_{1} \\phi_{12}^{2} + m_{2} \\phi_{22}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Gamma_{2} = 0.288\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Gamma}^{2}_{n} = \\left[\\begin{matrix}1.17\\\\0.0831\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nhoehe = list(H_modal.subs(params).evalf(3)/unit.m)\nhoehe = [np.float64(i).round(2) for i in hoehe]\n\nmasse = list(M_star_clean/unit.N/unit.second**2 * unit.m)\nmasse = [np.float64(i).round(2) for i in masse if i != 0]\n\nsteifigkeiten = list(K_star_clean/unit.N * unit.m)\nsteifigkeiten = [np.float64(i).round(2) for i in steifigkeiten if i != 0]\n\nomegas = list(Omega.subs(params)*unit.second)\nomegas = [np.float64(i).round(2) for i in omegas if i != 0]\n\ngammas = list(Gamma.subs(params).evalf(3))\ngammas = [np.float64(i).round(2) for i in gammas if i != 0]\n\n\nplot_einmassenschwinger(hoehe, masse, steifigkeiten, omegas, gammas)\n\n\n\n\nAbbildung 16.4: Darstellung der entkoppelten Einmassenschwinger\n\n\n\n\n\n\n\n16.2.5 Elastisches Antwortspektrum\nAus der Aufgabenstellung darf nach (Schweizerischer Ingenieur- und Architektenverein (SIA), 2020) Abs. 16.2.3.1 Kurve \\(E\\) gewählt werden.\n\na_gd = 1 *unit.m /unit.second**2\n\n\n16.2.5.1 Grundschwingzeit\nDie Grundschwingzeit kann anhand der bereits ermittelten Eigenkreisfrequenzen ermittelt werden.\n\nT_1 = (omega_1 /(2*sp.pi))**-1\nT_2 = (omega_2 /(2*sp.pi))**-1\n\nrender.eq_display('T_1', T_1.subs(params).evalf(3),\n                  'T_2', T_2.subs(params).evalf(3),\n                  )\n\n\\[\\begin{equation}T_{1} = 1.25 \\text{s}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{2} = 0.345 \\text{s}\\end{equation}\\]\n\n\n\n\n16.2.5.2 Elastisches Antwortspektrum\n\n\nS_e_1 = antwortspektrum(a_gd, T_1.subs(params).evalf(3), Baugrundklasse='E')\nrender.eq_display('S_e_1', S_e_1.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.7\\)\n\\(T_{B} = 0.09 \\text{s}\\)\n\n\n\\(T_{C} = 0.25 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = \\frac{2.5 S_{} T_{C} a_{gd} \\eta}{T}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 1} = \\frac{0.852 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\nS_e_2 = antwortspektrum(a_gd, T_2.subs(params).evalf(3), Baugrundklasse = 'E')\n\nrender.eq_display('S_e_2', S_e_2.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.7\\)\n\\(T_{B} = 0.09 \\text{s}\\)\n\n\n\\(T_{C} = 0.25 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = \\frac{2.5 S_{} T_{C} a_{gd} \\eta}{T}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e 2} = \\frac{3.08 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n\n\n16.2.6 Maximale Deformation\nDie maximale Deformation resultiert aus der Beschleunigung \\(S_e\\) und der Eigenkreisfrequenz \\(\\omega_n^2\\). Für die Modalen EMS gilt es diese anhand der Partizipationsfaktoren zu gewichten. Zur effektiven Bestimmung der Auslenkung sind die Resultate der EMS mittels SRSS-Regel zu überlagern.\n\nq_1_max = Gamma[0] * S_e_1 / omega_1**2\nq_2_max = Gamma[1] * S_e_2 / omega_2**2\n\nrender.eq_display('q_1_max',\"Gamma_1 * S_e_1 / omega_1**2\",\n'q_1_max', q_1_max.subs(params).evalf(3),\n'q_2_max',\"Gamma_2 * S_e_2 / omega_2**2\",\n'q_2_max', q_2_max.subs(params).evalf(3))\n\n\\[\\begin{equation}q_{1 max} = \\frac{\\Gamma_{1} S_{e 1}}{\\omega_{1}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{1 max} = 0.0364 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 max} = \\frac{\\Gamma_{2} S_{e 2}}{\\omega_{2}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}q_{2 max} = 0.00268 \\text{m}\\end{equation}\\]\n\n\nUm die Entkoppelung rückzuführen, gilt es die erhaltenen Resultate zu überlagern. Dabei gibt es unterschiedliche Ansätze. Bei weit auseinander liegenden Eigenfrequenzen kann die SRSS-Überlagerung verwendet werden.\n\\[\nu_{max} = \\sqrt{\\sum_{n=1}^2 (q_{n} \\cdot \\phi_n)^2}\n\\tag{16.12}\\]\n\nu_max = ((phi_1*q_1_max).applyfunc(lambda x: x**2)+(phi_2*q_2_max).applyfunc(lambda x: x**2)).applyfunc(sp.sqrt)\n\n\nrender.eq_display(sp.MatrixSymbol('u_max', 2,1), u_max.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{u}_{max} = \\left[\\begin{matrix}0.024 \\text{m}\\\\0.0364 \\text{m}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\nDelta_A, Delta_B, zeta = sp.symbols('Delta_A, Delta_B, zeta')\n\n\n\n#Ansatzfunktion für Teil 1 der Funktion\nzeta = x/l\nw_ansatz = Delta_A + (Delta_B-Delta_A)*(3*zeta**2 - 2*zeta**3)\n\nw_1_x = w_ansatz.subs(Delta_A, 0).subs(Delta_B, u_max[0].subs(params)/unit.m).subs(l,H_1.subs(params_plot))\n\n\n\n\n#Ansatzfunktion für Teil 2 der Funktion\nzeta = (x-H_1.subs(params_plot))/l\nw_ansatz = Delta_A + (Delta_B-Delta_A)*(3*zeta**2 - 2*zeta**3)\n\nw_2_x = w_ansatz.subs(Delta_A, u_max[0].subs(params)/unit.m).subs(Delta_B, u_max[1].subs(params)/unit.m).subs(l,H_2.subs(params_plot))\n\n\n\n#Zusammengestellt\nw_eigenform_1 = sp.Eq(w,sp.Piecewise((w_1_x, x&lt;=H_1.subs(params_plot)),(w_2_x, x&gt;=H_1.subs(params_plot))))\n\n\n#Numerische Daten generieren\nw_eigenform_1_lamb = sp.lambdify(x, w_eigenform_1.rhs)\n\nx_array = np.linspace(0, float((H_1+H_2).subs(params_plot)), 1000)\n\nw_1_array = w_eigenform_1_lamb(x_array)\n\n\n\n# Ersten Plot erstellen\n\nplt.plot(w_1_array, x_array)\n\n## Horizontale Linien\nplt.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nplt.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nplt.axvline(u_max[1].subs(params)/unit.m,linestyle='dashed', color='gray',linewidth=1)\nplt.axvline(u_max[0].subs(params)/unit.m,linestyle='dashed', color='gray',linewidth=1)\n\nplt.axvline(0,linestyle='dashed', color='black')\nplt.xlabel('$u$ [m]')\nplt.ylabel('$H$ [m]')\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\n\n\nAbbildung 16.5: Maximale Deformation des Mehrmassenschwingers\n\n\n\n\n\n\n16.2.7 Maximale Schnittkräfte\n\n16.2.7.1 Querkräfte\nDie Einwirkungen resultieren aus der Masse multipliziert mit der Beschleunigung aus dem Antwortspektrum. Dazu sind in einem ersten Schritt die beiden entkoppelten EMS voneinander getrennt zu betrachten. Die Überlagerung erfolgt erst bei den ermittelten Querkräften.\n\\[\nm_1 = \\Gamma \\cdot M \\cdot \\phi_1\n\\tag{16.13}\\]\n\\[\nF_{1max} = m_1 \\cdot S_{e1}\n\\tag{16.14}\\]\nAus dem ersten EMS folgt:\n\nM_1 = Gamma[0] * M * phi_1\nF_1_max = M_1* S_e_1\nV_1 = sp.Matrix([[F_1_max[0]+F_1_max[1]],[F_1_max[1]]])\n\nrender.eq_display(sp.MatrixSymbol('M_1', 2,1), M_1.subs(params).evalf(5),\n                  sp.MatrixSymbol('F_1_max', 2,1), F_1_max.subs(params).evalf(5),\n                  sp.MatrixSymbol('V_1', 2,1), V_1.subs(params).evalf(5))\n\n\\[\\begin{equation}\\mathbf{M}_{1} = \\left[\\begin{matrix}\\frac{1494.8 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\\\frac{5197.8 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F}_{1 max} = \\left[\\begin{matrix}1273.7 \\text{N}\\\\4429.2 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{V}_{1} = \\left[\\begin{matrix}5702.9 \\text{N}\\\\4429.2 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\nAus dem zweiten EMS folglich:\n\nM_2 = Gamma[1] * M * phi_2\nF_2_max = M_2* S_e_2\nV_2 = sp.Matrix([[F_2_max[0]+F_2_max[1]],[F_2_max[1]]])\n\nrender.eq_display(sp.MatrixSymbol('M_2', 2,1), M_2.subs(params).evalf(5),\n                  sp.MatrixSymbol('F_2_max', 2,1), F_2_max.subs(params).evalf(5),\n                  sp.MatrixSymbol('V_2', 2,1), V_2.subs(params).evalf(5))\n\n\\[\\begin{equation}\\mathbf{M}_{2} = \\left[\\begin{matrix}\\frac{605.23 \\text{N} \\text{s}^{2}}{\\text{m}}\\\\- \\frac{397.83 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F}_{2 max} = \\left[\\begin{matrix}1864.2 \\text{N}\\\\- 1225.4 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{V}_{2} = \\left[\\begin{matrix}638.82 \\text{N}\\\\- 1225.4 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\nMaximale Querkraft aus Überlagerung beider EMS mittels SRSS-Regel.\n\\[\nV_{max} = \\sqrt{V_1^2 + V_2^2 }\n\\tag{16.15}\\]\n\nV_max = (V_1.applyfunc(lambda x: x**2)+V_2.applyfunc(lambda x: x**2)).applyfunc(sp.sqrt)\n\n\nrender.eq_display(sp.MatrixSymbol('V_max', 2,1), V_max.subs(params).evalf(3))\n\n\\[\\begin{equation}\\mathbf{V}_{max} = \\left[\\begin{matrix}5.74 \\cdot 10^{3} \\text{N}\\\\4.6 \\cdot 10^{3} \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n16.2.7.2 Biegemomente\nDie Biegemomente lassen sich abschliessend anhand der Querkräfte bestimmen.\n\n\n16.2.7.3 Normalkräfte\nDie Normalkräfte resultieren aus den Punktmassen.\n\n# Querkraft\nV_x = sp.Piecewise((V_max[0].subs(params)/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))), (V_max[1].subs(params)/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))), (0,True))\n\n# Biegemoment\nC_1 = sp.symbols('C_1')\nM_x = sp.integrate(-V_x, x) + C_1\nC_1_solve = sp.solve(M_x.subs(x, (H_1+H_2).subs(params_plot)), C_1)[0]\nM_x = M_x.subs(C_1, C_1_solve)\n\n# Normalkraft\ng = 10*unit.m/unit.second**2\nN_x = sp.Piecewise(((m_1+m_2).subs(params)*g/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))),(m_1.subs(params)*g/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))), (0,True))\n\n\n\n# Numerische Daten generieren\nV_x_lamb = sp.lambdify(x, V_x)\nV_x_array = V_x_lamb(x_array)\n\nM_x_lamb = sp.lambdify(x,M_x)\nM_x_array = M_x_lamb(x_array)\n\nN_x_lamb = sp.lambdify(x,N_x)\nN_x_array = N_x_lamb(x_array)\n\n# Figure und Axes erstellen\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n\n# Ersten Plot erstellen\n\nax1.plot(V_x_array/1000, x_array)\nax1.set_title('$V(x)$')\n\n## Horizontale Linien\nax1.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.set_xlabel('$[kN]$')\nax1.set_ylabel('$[m]$')\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n# Zweiten Plot erstellen\n\nax2.plot(M_x_array/1000, x_array, color='orange')\nax2.set_title('$M(x)$')\n\n## Horizontale Linien\nax2.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.set_xlabel('$[kNm]$')\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Dritten Plot erstellen\n\nax3.plot(N_x_array/1000, x_array, color='green')\nax3.set_title('$N(x)$')\nax3.set_xlabel('$[kN]$')\n\n\n## Horizontale Linien\nax3.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax3.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\n\nax3.axvline(0,linestyle='dashed', color='black')\n\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\n\n\nAbbildung 16.6: Maximale Schnittgrössen\n\n\n\n\n\n\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2020). Norm SIA 261:2020 Einwirkungen auf Tragwerke  (136. S.)."
  },
  {
    "objectID": "ekv_01.html#aufgabenstellung",
    "href": "ekv_01.html#aufgabenstellung",
    "title": "17  Beispiel: Unsymmetrisch angeordnete Wandscheiben",
    "section": "17.1 Aufgabenstellung",
    "text": "17.1 Aufgabenstellung\nIn Abbildung 17.1 ist ein unsymmetrischer Gebäudegrundriss dargestellt. Dieser wird durch vier Stahlbeton-Wandscheiben ausgesteift.\n\n\n\nAbbildung 17.1: Grundriss des Gebäudes\n\n\nDas Untergeschoss gilt als steifer Kasten, folglich ist der Einspannungshorizont der Wandscheiben Oberkante UG. Es findet eine gewisse Einspannung der Wandscheiben in die Bodenplatte statt, je nach Ausbildung der Fundation. Diese kann man z.B. mit einer elastischen Einspannung (Drehfeder) modellieren. Die elastische Einspannung liegt im Bereich von 20% einer Volleinspannung. Im Beispiel wird diese als gelenkige Lagerung angenommen.\n\n\n\nAbbildung 17.2: Ansicht der Wand 3 des Gebäudes\n\n\nDie Modellierung in Abbildung 17.3 trifft folgende Annahmen:\n\nDie Decken sind gelenkig an die Tragwände angeschlossen\nDie Deckenscheiben wirken in ihrer Ebene als starre Scheiben\nDie Wandscheiben bzw. Tragwände sind in den Kellerkasten eingespannt, so dass die Modellierung als Kragarm gerechtfertigt ist\nDie Massen der Decken werden im Aufriss als Punktmassen am Kragarm abgebildet (Dabei werden die Massen der Wände pro Geschoss je zur Hälfte der Geschossmassen zugeordnet)\nDie Stützen tragen lediglich zum vertikalen Lastabtrag bei. Deren Steifigkeit kann vernachlässigt werden\n\n\n\n\nAbbildung 17.3: Modellierung als Mehrmassenschwinger\n\n\nGesucht:\n\nSchubmittelpunkt\nErste Eigenperiode\nErsatzkräfte durch das Ersatzkraftverfahren auf charakteristischem Niveau\n\nGegeben:\n\nBaugrundklasse \\(B\\)\nErdbebenzone \\(Z2\\)\nDecken und Wände sind alle \\(d\\) stark\nSämtliche Decken gelten als Büroflächen (Lastermittlung - vereinfacht auch die Dachfläche)\nReduktion der Biegesteifigkeit \\(\\gamma_{EI}\\) zur Berücksichtigung der Rissbildung\n\n\nE, d, L_y, L_x, L_w1, L_w2, L_w3, L_w4 = sp.symbols('E, d, L_y, L_x, L_w1, L_w2, L_w3, L_w4')\n\n\nrho_c, gamma_f, q,q_auflast_k, q_nutzlast_k = sp.symbols('rho_c, gamma_f, q, q_auflast_k, q_nutzlast_k')\nH_1, H_2, H_3 = sp.symbols(\"H_1, H_2, H_3\")\nm_1, m_2, m_3 = sp.symbols('m_1, m_2, m_3')\n\nomega_n =sp.symbols('omega_n', real=True)\n\ngamma_EI = sp.symbols('gamma_EI')\n\n\n\nparams = {\n    'E':30000 *unit.N/unit.mm**2,\n    'd':0.3*unit.m,\n    'L_y':5*unit.m, \n    'L_x':4*unit.m,\n    'L_w1':4*unit.m,\n    'L_w2':3*unit.m,\n    'L_w3':5*unit.m,\n    'L_w4':3*unit.m,\n    'q': 2.0,\n    'gamma_f': 1.0,\n    'q_nutzlast_k': 2*10**3*unit.N/unit.m**2,\n    'q_auflast_k': 1*10**3*unit.N/unit.m**2,\n    'H_1':4*unit.m,\n    'H_2':4*unit.m,\n    'H_3':4*unit.m,\n    'rho_c':25000*unit.N / unit.m**3,\n    'g':10 *unit.m/unit.second**2,\n    'gamma_EI':1.0,\n    \n\n}\nparams_plot = convert.param_value(params)\nrender.dict_to_table(params)\n\n\n\nTabelle 17.1: Verwendete Parameter der Aufgabe\n\n\n\n\n\n\n\\(E = \\frac{30000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(H_{1} = 4 \\text{m}\\)\n\n\n\\(H_{2} = 4 \\text{m}\\)\n\\(H_{3} = 4 \\text{m}\\)\n\n\n\\(L_{w1} = 4 \\text{m}\\)\n\\(L_{w2} = 3 \\text{m}\\)\n\n\n\\(L_{w3} = 5 \\text{m}\\)\n\\(L_{w4} = 3 \\text{m}\\)\n\n\n\\(L_{x} = 4 \\text{m}\\)\n\\(L_{y} = 5 \\text{m}\\)\n\n\n\\(d = 0.3 \\text{m}\\)\n\\(g = \\frac{10 \\text{m}}{\\text{s}^{2}}\\)\n\n\n\\(\\gamma_{EI} = 1.0\\)\n\\(\\gamma_{f} = 1.0\\)\n\n\n\\(q = 2.0\\)\n\\(q_{auflast k} = \\frac{1000 \\text{N}}{\\text{m}^{2}}\\)\n\n\n\\(q_{nutzlast k} = \\frac{2000 \\text{N}}{\\text{m}^{2}}\\)\n\\(\\rho_{c} = \\frac{25000 \\text{N}}{\\text{m}^{3}}\\)"
  },
  {
    "objectID": "ekv_01.html#musterlösung",
    "href": "ekv_01.html#musterlösung",
    "title": "17  Beispiel: Unsymmetrisch angeordnete Wandscheiben",
    "section": "17.2 Musterlösung",
    "text": "17.2 Musterlösung\n\n17.2.1 Schubmittelpunkt\nFür die Berechnung des Schubmittelpunktes C wird zunächst angenommen, dass sich die Wandscheiben parallel in y- bzw. z-Richtungen verschieben. Es findet somit keine Verdrehung statt. Die gleiche Verschiebung wird durch die starre Deckenscheibe gewährleistet. Die Wandscheiben können als Biegestäbe (Kragarme) mit der Biegesteifigkeit EI in die jeweilige y- bzw. z-Richtung betrachtet werden. Jede Wandscheibe erfährt bei einer parallelen Verschiebung der starren Deckenscheibe in die jeweilige Richtung die gleiche Kopfverformung (parallel geschaltete Federn).\n\n17.2.1.1 Abstand vom Koordinatennullpunkt\n\nx_i = np.array([\n       -L_x,\n       sp.Rational(1.5)*L_x - L_w2/2,\n       -sp.Rational(1.5)*L_x,\n       sp.Rational(2.5)*L_x\n])\nx_dict = {f'x{i+1}': x_i[i].subs(params).evalf(3) for i in range(len(x_i))}\nrender.dict_to_table(x_dict)\n\n\n\n\n\n\n\n\n\\(x_{1} = - 4.0 \\text{m}\\)\n\\(x_{2} = 4.5 \\text{m}\\)\n\n\n\\(x_{3} = - 6.0 \\text{m}\\)\n\\(x_{4} = 10.0 \\text{m}\\)\n\n\n\n\n\n\ny_i = np.array([\n    sp.Rational(1.5)*L_y,\n    -sp.Rational(1.5)*L_y,\n    0*L_y,\n    sp.Rational(1.5)*L_y - L_w4/2      \n])\ny_dict = {f'y{i+1}': y_i[i].subs(params).evalf(3) for i in range(len(y_i))}\nrender.dict_to_table(y_dict)\n\n\n\n\n\n\n\n\n\\(y_{1} = 7.5 \\text{m}\\)\n\\(y_{2} = - 7.5 \\text{m}\\)\n\n\n\\(y_{3} = 0\\)\n\\(y_{4} = 6.0 \\text{m}\\)\n\n\n\n\n\n\n\n17.2.1.2 Wandlängen\nWandlängen in \\(X\\)-Richtung\n\nL_x_i = np.array([\n    L_w1, \n    L_w2,\n    d,\n    d\n])\nl_x_dict = {f'L_x{i+1}': L_x_i[i].subs(params).evalf(3) for i in range(len(L_x_i))}\nrender.dict_to_table(l_x_dict)\n\n\n\n\n\n\n\n\n\\(L_{x1} = 4.0 \\text{m}\\)\n\\(L_{x2} = 3.0 \\text{m}\\)\n\n\n\\(L_{x3} = 0.3 \\text{m}\\)\n\\(L_{x4} = 0.3 \\text{m}\\)\n\n\n\n\n\nWandlängen in \\(Y\\)-Richtung\n\nL_y_i = np.array([\n    d,\n    d,\n    L_w3,\n    L_w4\n])\nl_y_dict = {f'L_y{i+1}': L_y_i[i].subs(params).evalf(3) for i in range(len(L_y_i))}\nrender.dict_to_table(l_y_dict)\n\n\n\n\n\n\n\n\n\\(L_{y1} = 0.3 \\text{m}\\)\n\\(L_{y2} = 0.3 \\text{m}\\)\n\n\n\\(L_{y3} = 5.0 \\text{m}\\)\n\\(L_{y4} = 3.0 \\text{m}\\)\n\n\n\n\n\n\n\n17.2.1.3 Trägheitsmoment\nLediglich die Eigenträgheitsmomente sind beschrieben.\n\\[\nI_{xi} = \\frac{L_{yi}^3 \\cdot L_{xi} }{12}\n\\tag{17.1}\\]\n\nI_x_i = L_y_i**3 * L_x_i / 12 \n\n\nI_x_dict = {f'I_x{i+1}': I_x_i[i].subs(params).evalf(3) for i in range(len(I_x_i))}\nrender.dict_to_table(I_x_dict)\n\n\n\n\n\n\n\n\n\\(I_{x1} = 0.009 \\text{m}^{4}\\)\n\\(I_{x2} = 0.00675 \\text{m}^{4}\\)\n\n\n\\(I_{x3} = 3.13 \\text{m}^{4}\\)\n\\(I_{x4} = 0.675 \\text{m}^{4}\\)\n\n\n\n\n\n\\[\nI_{yi} = \\frac{L_{xi}^3 \\cdot L_{yi} }{12}\n\\tag{17.2}\\]\n\nI_y_i = L_x_i**3 * L_y_i / 12 \n\nI_y_dict = {f'I_y{i+1}': I_y_i[i].subs(params).evalf(3) for i in range(len(I_y_i))}\nrender.dict_to_table(I_y_dict)\n\n\n\n\n\n\n\n\n\\(I_{y1} = 1.6 \\text{m}^{4}\\)\n\\(I_{y2} = 0.675 \\text{m}^{4}\\)\n\n\n\\(I_{y3} = 0.0112 \\text{m}^{4}\\)\n\\(I_{y4} = 0.00675 \\text{m}^{4}\\)\n\n\n\n\n\n\\[\nI_{k,ersatz} = \\sum_{i=1}^{N_{Waende}} I_{ki}\n\\tag{17.3}\\]\nAngewendet auf die Aufgabe:\n\nI_x_ersatz = np.sum(I_x_i)\nI_y_ersatz = np.sum(I_y_i)\n\nrender.eq_display('I_x_ersatz', I_x_ersatz.subs(params),\n                  'I_y_ersatz', I_y_ersatz.subs(params))\n\n\\[\\begin{equation}I_{x ersatz} = 3.81575 \\text{m}^{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}I_{y ersatz} = 2.293 \\text{m}^{4}\\end{equation}\\]\n\n\nMultipliziert mit dem Elastizitätsmodul zur Bestimmung der Biegesteifigkeit:\n\nEI_x = E*I_x_ersatz\nEI_y = E*I_y_ersatz\n\nrender.eq_display('EI_x_ersatz', EI_x.subs(params).simplify(),\n                  'EI_y_ersatz', EI_y.subs(params).simplify())\n\n\\[\\begin{equation}EI_{x ersatz} = 114472500000.0 \\text{m}^{2} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}EI_{y ersatz} = 68790000000.0 \\text{m}^{2} \\text{N}\\end{equation}\\]\n\n\n\n\n17.2.1.4 Abstände des Schubmittelpunkts zum Massenschwerpunkt\n\\[\ny_c = \\frac{\\sum_{i=1}^n EI_{y,i}y_i}{\\sum_{i=1}^n EI_{y,i}}\n\\tag{17.4}\\]\n\\[\nx_c = \\frac{\\sum_{i=1}^n EI_{x,i}x_i}{\\sum_{i=1}^n EI_{x,i}}\n\\tag{17.5}\\]\nAngewendet auf die Aufgabe:\n\nx_i_0 = np.array([\n       sp.Rational(1.5)*L_x,\n       sp.Rational(4)*L_x - L_w2/2,\n       L_x,\n       sp.Rational(5)*L_x\n])\n\ny_i_0 = np.array([\n    sp.Rational(3)*L_y,\n    0*L_y,\n    sp.Rational(1.5)*L_y,\n    sp.Rational(3)*L_y-L_w4/2      \n])\ny_c = np.sum(E*I_y_i*y_i) / np.sum(E*I_y_i)\nx_c = np.sum(E*I_x_i*x_i) / np.sum(E*I_x_i)\n\nrender.eq_display('y_c', y_c.subs(params).evalf(3),\n                  'x_c', x_c.subs(params).evalf(3))\n\n\\[\\begin{equation}y_{c} = 3.04 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}x_{c} = - 3.15 \\text{m}\\end{equation}\\]\n\n\n\nimport svgutils.compose as sc\nfrom IPython.display import SVG\n\n\n\n##Wandschwerpunkte\nx_i_plot = [x.subs(params)/unit.m for x in x_i]\ny_i_plot = [y.subs(params)/unit.m for y in y_i]\n\n\n##Plattenrand\nplatte_x = [-sp.Rational(2.5)*L_x, sp.Rational(2.5)*L_x,\n            sp.Rational(2.5)*L_x, -sp.Rational(2.5)*L_x,\n            -sp.Rational(2.5)*L_x]\nplatte_y = [-sp.Rational(1.5)*L_y, -sp.Rational(1.5)*L_y,\n            sp.Rational(1.5)*L_y, sp.Rational(1.5)*L_y,\n            -sp.Rational(1.5)*L_y]\n\nplatte_x_plot = [x.subs(params)/unit.m for x in platte_x]\nplatte_y_plot = [y.subs(params)/unit.m for y in platte_y]\n\n\n##Schubmittelpunkt\nx_c_plot = x_c.subs(params).evalf(3)/unit.m\ny_c_plot = y_c.subs(params).evalf(3)/unit.m\n\n\n\n\n# Erstellen Sie den Plot mit angepasster Größe und gleichem Seitenverhältnis der Achsen\nfig, ax = plt.subplots(1, figsize=(4.5,4.5))\nax.set_aspect('equal')\nax.scatter(x_i_plot, y_i_plot, color='red', marker='+')\nax.scatter(x_c_plot, y_c_plot, color='red', marker='o')\nax.annotate(f'$S$ (x = {x_c_plot}; y = {y_c_plot})', xy = [x_c_plot*1, y_c_plot*1.2])\nax.axis('off')\nfig.savefig('bilder/cover.svg', transparent=True)\nplt.close(fig)\n\n# Hier beginnt die Montage mit svgutils und angepasster SVG-Größe\nsc.Figure(\"425.197\", \"269.291\",\n    sc.Panel(sc.SVG(\"bilder/aufgabe_ekv_gebaeude_GR.svg\").scale(1)),\n    sc.Panel(sc.SVG(\"bilder/cover.svg\")).move(74,-29)\n).save(\"bilder/compose.svg\")\n\nSVG('bilder/compose.svg')\n\n\n\n\nAbbildung 17.4: Grundriss mit Schubmittelpunkt\n\n\n\n\n\n\n\n17.2.2 Massenmatrix \\(M\\)\n\n\n\nAbbildung 17.5: Auslenkung der Massen zur Ermittlung der Matrizen\n\n\n\n\n17.2.3 Lastermittlung\nGemäss Schweizerischer Ingenieur- und Architektenverein (SIA) (2020) Ziff. 16.5.2.3 sind ständige und quasiständige Lasten anzusetzen. Bei der Lastermittlung werden die Gewichtskräfte aus Eigenmassen und Auflasten ermittelt. Dazu werden pro Stockwerk die Gewichtskräfte der Wände definiert. Eine Punktmasse erhält jeweils die Hälfte der darunter- und darüber liegenden Wände. Für die Decke über 2.OG bleibt folglich nur eine Hälfte der Wände.\n\n\n\n\nA_decke = 5*L_x* 3 * L_y\nG_decke = A_decke * rho_c* d\nG_waende_stock = (L_w1 +L_w2+L_w3+L_w4)*H_1 * rho_c * d\nQ_auflast_k = q_auflast_k * A_decke\nQ_nutzlast_k = q_nutzlast_k * A_decke\npsi_2 = 0.3\n\nparams['m_3'] = ((G_decke + Q_auflast_k+ G_waende_stock/2+psi_2 * Q_nutzlast_k)/g).subs(params)\nparams['m_2'] = ((G_decke + Q_auflast_k+ G_waende_stock+psi_2 * Q_nutzlast_k)/g).subs(params)\nparams['m_1'] = ((G_decke + Q_auflast_k+ G_waende_stock+psi_2 * Q_nutzlast_k)/g).subs(params)\n\nrender.eq_display('A_Decke', A_decke.subs(params).evalf(3),\n                  'G_Decke_k', G_decke.subs(params).evalf(3),\n                  'G_Waende_k', G_waende_stock.subs(params).evalf(3),\n                  'Q_auflast_k', Q_auflast_k.subs(params).evalf(3),\n                  'Q_nutzlast_k', Q_nutzlast_k.subs(params).evalf(3),\n                  'psi_2', psi_2,\n                  )\n\n\n\\[\\begin{equation}A_{Decke} = 300.0 \\text{m}^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{Decke k} = 2.25 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{Waende k} = 4.5 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Q_{auflast k} = 3.0 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Q_{nutzlast k} = 6.0 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\psi_{2} = 0.3\\end{equation}\\]\n\n\nDaraus lassen sich die Punktmassen bestimmen:\n\nrender.eq_display('m_1', \"(G_decke + Q_auflast_k+ G_Waende_k+psi_2 * Q_nutzlast_k)/g\",\n                 'm_1', m_1.subs(params).evalf(3),\n                 'm_2', \"(G_decke + Q_auflast_k+ G_Waende_k+psi_2 * Q_nutzlast_k)/g\",\n                 'm_2', m_2.subs(params).evalf(3),\n                 'm_3', \"(G_decke + Q_auflast_k+ G_Waende_k/2+psi_2 * Q_nutzlast_k)/g\",\n                 'm_3', m_3.subs(params).evalf(3))\n\n\\[\\begin{equation}m_{1} = \\frac{G_{Waende k} + G_{decke} + Q_{auflast k} + Q_{nutzlast k} \\psi_{2}}{g}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{1} = \\frac{3.18 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{2} = \\frac{G_{Waende k} + G_{decke} + Q_{auflast k} + Q_{nutzlast k} \\psi_{2}}{g}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{2} = \\frac{3.18 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{3} = \\frac{\\frac{G_{Waende k}}{2} + G_{decke} + Q_{auflast k} + Q_{nutzlast k} \\psi_{2}}{g}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{3} = \\frac{2.95 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\n17.2.3.1 X-Richtung\n\nM_x = sp.Matrix([[m_1,0,0],[0,m_2,0],[0,0,m_3]])\n\nrender.eq_display(sp.MatrixSymbol('M_x', 3, 3), M_x,\n                  sp.MatrixSymbol('M_x', 3, 3), M_x.subs(params))\n\n\\[\\begin{equation}\\mathbf{M}_{x} = \\left[\\begin{matrix}m_{1} & 0 & 0\\\\0 & m_{2} & 0\\\\0 & 0 & m_{3}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M}_{x} = \\left[\\begin{matrix}\\frac{318000.0 \\text{N} \\text{s}^{2}}{\\text{m}} & 0 & 0\\\\0 & \\frac{318000.0 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & 0 & \\frac{295500.0 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n17.2.3.2 Y-Richtung\n\nM_y = sp.Matrix([[m_1,0,0],[0,m_2,0],[0,0,m_3]])\n\nrender.eq_display(sp.MatrixSymbol('M_y', 3, 3), M_y,\n                  sp.MatrixSymbol('M_y', 3, 3), M_y.subs(params))\n\n\\[\\begin{equation}\\mathbf{M}_{y} = \\left[\\begin{matrix}m_{1} & 0 & 0\\\\0 & m_{2} & 0\\\\0 & 0 & m_{3}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M}_{y} = \\left[\\begin{matrix}\\frac{318000.0 \\text{N} \\text{s}^{2}}{\\text{m}} & 0 & 0\\\\0 & \\frac{318000.0 \\text{N} \\text{s}^{2}}{\\text{m}} & 0\\\\0 & 0 & \\frac{295500.0 \\text{N} \\text{s}^{2}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n17.2.4 Steifigkeitsmatrix \\(K\\)\n\n17.2.4.1 X-Richtung\nAufgrund der gelenkigen Verbindung zwischen Platten und Wände gilt für die Ersatzsteifigkeit:\n\\[\nk = \\frac{3EI}{H^3}\n\\tag{17.6}\\]\nDie Biegesteifigkeit \\(EI\\) wird um den Faktor \\(\\gamma_{EI}\\) reduziert zur Berücksichtigung der Rissbildung. Zusätzlich gilt, die Ersatzsteifigkeit in X-Richtung entspricht \\(EI_y\\). Dazu wird für \\(H\\) die entsprechende Höhe ab Einspannhorizont eingesetzt.\n\nparams[H] = (H_1+H_2+H_3).subs(params)\nk_1_x = 3 * EI_y*gamma_EI / (H_1)**3\nk_2_x = 3 * EI_y*gamma_EI / (H_1+H_2)**3 \nk_3_x = 3 * EI_y*gamma_EI / (H_1+H_2+H_3)**3\n\nrender.eq_display(\n'k_1_x', '3 * EI_y*gamma_EI / (H_1)**3',\n'k_1_x', k_1_x.subs(params).simplify().evalf(3),\n'k_2_x', '3 * EI_y*gamma_EI / (H_1+H_2)**3',\n'k_2_x', k_2_x.subs(params).simplify().evalf(3),\n'k_3_x', '3 * EI_y*gamma_EI / (H_1+H_2+H_3)**3', \n'k_3_x', k_3_x.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}k_{1 x} = \\frac{3 EI_{y} \\gamma_{EI}}{H_{1}^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{1 x} = \\frac{3.22 \\cdot 10^{9} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2 x} = \\frac{3 EI_{y} \\gamma_{EI}}{\\left(H_{1} + H_{2}\\right)^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2 x} = \\frac{4.03 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{3 x} = \\frac{3 EI_{y} \\gamma_{EI}}{\\left(H_{1} + H_{2} + H_{3}\\right)^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{3 x} = \\frac{1.19 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\nAbgefüllt in die Steifigkeitsmatrix\n\nK_x = sp.Matrix([[k_1_x + k_2_x, -k_2_x, 0],[-k_2_x,k_2_x+k_3_x, -k_3_x], [0,-k_3_x, k_3_x]])\n\nrender.eq_display(\n    sp.MatrixSymbol('K_x', 3, 3), \"Matrix([[k_1_x + k_2_x, -k_2_x, 0],[-k_2_x,k_2_x+k_3_x, -k_3_x], [0,-k_3_x, k_3_x]])\",\n    sp.MatrixSymbol('K_x', 3, 3), sp.simplify(K_x.subs(params)).evalf(3)\n)\n\n\\[\\begin{equation}\\mathbf{K}_{x} = \\left[\\begin{matrix}k_{1 x} + k_{2 x} & - k_{2 x} & 0\\\\- k_{2 x} & k_{2 x} + k_{3 x} & - k_{3 x}\\\\0 & - k_{3 x} & k_{3 x}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K}_{x} = \\left[\\begin{matrix}\\frac{3.63 \\cdot 10^{9} \\text{N}}{\\text{m}} & - \\frac{4.03 \\cdot 10^{8} \\text{N}}{\\text{m}} & 0\\\\- \\frac{4.03 \\cdot 10^{8} \\text{N}}{\\text{m}} & \\frac{5.23 \\cdot 10^{8} \\text{N}}{\\text{m}} & - \\frac{1.19 \\cdot 10^{8} \\text{N}}{\\text{m}}\\\\0 & - \\frac{1.19 \\cdot 10^{8} \\text{N}}{\\text{m}} & \\frac{1.19 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n17.2.4.2 Y-Richtung\n\nk_1_y = 3 * EI_x*gamma_EI / H_1**3\nk_2_y = 3 * EI_x*gamma_EI / (H_1+H_2)**3\nk_3_y = 3 * EI_x*gamma_EI / (H_1+H_2+H_3)**3\n\nrender.eq_display(\n'k_1_y', k_1_y.subs(params).simplify().evalf(3),\n'k_2_y', k_2_y.subs(params).simplify().evalf(3),\n'k_3_y', k_3_y.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}k_{1 y} = \\frac{5.37 \\cdot 10^{9} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{2 y} = \\frac{6.71 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{3 y} = \\frac{1.99 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\nAbgefüllt in die Steifigkeitsmatrix\n\nK_y = sp.Matrix([[k_1_y + k_2_y, -k_2_y, 0],[-k_2_y,k_2_y+k_3_y, -k_3_y], [0,-k_3_y, k_3_y]])\n\nrender.eq_display(\n    sp.MatrixSymbol('K_y', 3, 3), \"Matrix([[k_1_y + k_2_y, -k_2_y, 0],[-k_2_y,k_2_y+k_3_y, -k_3_y], [0,-k_3_y, k_3_y]])\",\n    sp.MatrixSymbol('K_y', 3, 3), sp.simplify(K_y.subs(params)).evalf(3)\n)\n\n\\[\\begin{equation}\\mathbf{K}_{y} = \\left[\\begin{matrix}k_{1 y} + k_{2 y} & - k_{2 y} & 0\\\\- k_{2 y} & k_{2 y} + k_{3 y} & - k_{3 y}\\\\0 & - k_{3 y} & k_{3 y}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{K}_{y} = \\left[\\begin{matrix}\\frac{6.04 \\cdot 10^{9} \\text{N}}{\\text{m}} & - \\frac{6.71 \\cdot 10^{8} \\text{N}}{\\text{m}} & 0\\\\- \\frac{6.71 \\cdot 10^{8} \\text{N}}{\\text{m}} & \\frac{8.7 \\cdot 10^{8} \\text{N}}{\\text{m}} & - \\frac{1.99 \\cdot 10^{8} \\text{N}}{\\text{m}}\\\\0 & - \\frac{1.99 \\cdot 10^{8} \\text{N}}{\\text{m}} & \\frac{1.99 \\cdot 10^{8} \\text{N}}{\\text{m}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n\n\n17.2.5 Eigenkreisfrequenzen\nBei einem Mehrmassenschwinger gibt es entsprechend den Freiheitsgraden Eigenkreisfrequenzen \\(\\omega_n\\). Diese lassen sich anhand folgender Gleichung bestimmen:\n\\[\n\\det{[\\mathbf{K}-\\omega_n^2 \\mathbf{M}]=0}\n\\tag{17.7}\\]\n\n17.2.5.1 X-Richtung\n\nparams_plot = convert.param_value(params)\n\neq_omega = sp.det((K_x-omega_n**2*M_x).subs(params_plot))\nomega_n_solve= sp.solve([eq_omega.subs(params_plot).simplify(), omega_n&lt;=5000, omega_n&gt;=0], omega_n, dict=True)\n\nomega_1_x = omega_n_solve.args[0].rhs/unit.second\nomega_2_x = omega_n_solve.args[1].rhs/unit.second\nomega_3_x = omega_n_solve.args[2].rhs/unit.second\n\n\n\nrender.eq_display('omega_1_x', omega_1_x.evalf(3),\n                  'omega_2_x', omega_2_x.evalf(3),\n                  'omega_3_x', omega_3_x.evalf(3))\n\n\n\\[\\begin{equation}\\omega_{1 x} = \\frac{16.7}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2 x} = \\frac{40.1}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{3 x} = \\frac{108.0}{\\text{s}}\\end{equation}\\]\n\n\n\nsp.plot(eq_omega.subs(params_plot).evalf(5).simplify(),(omega_n, 0, max([omega_1_x,omega_2_x,omega_3_x])*unit.second*1.01),size=(5.9,2), show=False).show()\n\n\n\n\nAbbildung 17.6: Nullstellen der Gleichung 17.7 in X-Richtung\n\n\n\n\n\n\n17.2.5.2 Y-Richtung\n\neq_omega =  sp.det((K_y-omega_n**2*M_y).subs(params_plot))\nomega_n_solve= sp.solve([eq_omega.subs(params_plot).simplify(), omega_n&lt;=5000, omega_n&gt;=0], omega_n, dict=True)\n\nomega_1_y = omega_n_solve.args[0].rhs/unit.second\nomega_2_y = omega_n_solve.args[1].rhs/unit.second\nomega_3_y = omega_n_solve.args[2].rhs/unit.second\n\n\n\nrender.eq_display('omega_1_y', omega_1_y.evalf(3),\n                  'omega_2_y', omega_2_y.evalf(3),\n                  'omega_3_y', omega_3_y.evalf(3))\n\n\n\\[\\begin{equation}\\omega_{1 y} = \\frac{21.6}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{2 y} = \\frac{51.7}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{3 y} = \\frac{139.0}{\\text{s}}\\end{equation}\\]\n\n\n\nsp.plot(eq_omega.subs(params_plot).evalf(5).simplify(),(omega_n, 0, max([omega_1_y,omega_2_y,omega_3_y])*unit.second*1.01),size=(5.9,2), show=False).show()\n\n\n\n\nAbbildung 17.7: Nullstellen der Gleichung 17.7 in Y-Richtung\n\n\n\n\n\n\n\n17.2.6 Eigenperioden\nDie Eigenperioden lassen sich aus den Eigenkreisfrequenzen bestimmen. Das Ersatzkraftverfahren betrachtet lediglich die Grundfrequenz. Weitere Schwingformen werden vernachlässigt. Aus diesem Grund sind in Schweizerischer Ingenieur- und Architektenverein (SIA) (2020) Abs. 16.5.2 Einschränkungen bei der Anwendung des Ersatzkraftverfahrens aufgelistet. Ziel dieser Einschränkungen ist es, dass lediglich Bauwerke untersucht werden, welche massgeblich in der Grundfrequenz schwingen.\n\\[\nT = \\frac{2\\pi}{\\omega_1}\n\\tag{17.8}\\]\n\n17.2.6.1 X-Richtung\nNach Schweizerischer Ingenieur- und Architektenverein (SIA) (2020) 16.5.2.3\n\nT_1_x_approx = 2*sp.sqrt(58.2/1000)*unit.second\nrender.eq_display('T_1_x_approx', T_1_x_approx.subs(params).evalf(3))\n\n\\[\\begin{equation}T_{1 x approx} = 0.482 \\text{s}\\end{equation}\\]\n\n\nDurch die ermittelte Grundfrequenz\n\nT_1_x = (2*sp.pi) / omega_1_x\nrender.eq_display('T_1_x', T_1_x.subs(params).evalf(3))\n\n\\[\\begin{equation}T_{1 x} = 0.376 \\text{s}\\end{equation}\\]\n\n\n\n\n17.2.6.2 Y-Richtung\nNach Schweizerischer Ingenieur- und Architektenverein (SIA) (2020) 16.5.2.3\n\nT_1_y_approx = 2*sp.sqrt(34.9/1000)*unit.second\nrender.eq_display('T_1_y_approx', T_1_y_approx.subs(params).evalf(3))\n\n\\[\\begin{equation}T_{1 y approx} = 0.374 \\text{s}\\end{equation}\\]\n\n\nDurch die ermittelte Grundfrequenz\n\nT_1_y = (2*sp.pi) / omega_1_y\n\nrender.eq_display('T_1_y', T_1_y.subs(params).evalf(3))\n\n\\[\\begin{equation}T_{1 y} = 0.291 \\text{s}\\end{equation}\\]\n\n\n\n\n\n17.2.7 Pseudobeschleunigung\nEs wird für die Eigenperioden die Pseudobeschleunigung bestimmt. Siehe dazu Schweizerischer Ingenieur- und Architektenverein (SIA) (2020).\n\na_gd = 1.0 *unit.m/unit.second**2\n\nrender.eq_display('a_gd', a_gd)\n\n\\[\\begin{equation}a_{gd} = \\frac{1.0 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n17.2.7.1 X-Richtung\n\nS_e_x = antwortspektrum(a_gd, T_1_x.subs(params).evalf(3), Baugrundklasse='B')\nrender.eq_display('S_e_x', S_e_x.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = \\frac{2.5 S_{} T_{C} a_{gd} \\eta}{T}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e x} = \\frac{2.8 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n\n17.2.7.2 Y-Richtung\n\nS_e_y = antwortspektrum(a_gd, T_1_y.subs(params).evalf(3), Baugrundklasse='B')\nrender.eq_display('S_e_y', S_e_y.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(\\eta = 1\\)\n\n\n\n\n\n\n\\[\\begin{equation}S_{e} = 2.5 S_{} a_{gd} \\eta\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{e y} = \\frac{3.0 \\text{m}}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\n\n\n17.2.8 Bemessungsspektrum\n\n17.2.8.1 X-Richtung\n\nS_d_x = bemessungsspektrum(a_gd, T_1_x.subs(params).evalf(3), params['q'], params['gamma_f'],Baugrundklasse='B')\nrender.eq_display('S_d_x', S_d_x.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(a_{gd} = \\frac{1.0 \\text{m}}{\\text{s}^{2}}\\)\n\\(g = \\frac{10.0 \\text{m}}{\\text{s}^{2}}\\)\n\n\n\\(\\gamma_{f} = 1.0\\)\n\\(q = 2.0\\)\n\n\n\n\n\n\\[\\begin{equation}S_{d} = \\frac{2.5 S_{} T_{C} a_{gd} \\gamma_{f}}{T g q}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{d x} = 0.14\\end{equation}\\]\n\n\n\n\n17.2.8.2 Y-Richtung\n\nS_d_y = bemessungsspektrum(a_gd, T_1_y.subs(params).evalf(3), params['q'], params['gamma_f'],Baugrundklasse='B')\nrender.eq_display('S_d_y', S_d_y.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(a_{gd} = \\frac{1.0 \\text{m}}{\\text{s}^{2}}\\)\n\\(g = \\frac{10.0 \\text{m}}{\\text{s}^{2}}\\)\n\n\n\\(\\gamma_{f} = 1.0\\)\n\\(q = 2.0\\)\n\n\n\n\n\n\\[\\begin{equation}S_{d} = \\frac{2.5 S_{} a_{gd} \\gamma_{f}}{g q}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{d y} = 0.15\\end{equation}\\]\n\n\n\n\n\n17.2.9 Stockwerkquerkraft\nDie Stockwerksquerkraft resultiert nach Norm aus Gleichung 17.9. Es wird lediglich die Nutzlast berücksichtigt. Zusätzlich ist zwischen beiden Richtungen zu unterscheiden.\n\\[\nF_d = S_d \\cdot \\sum_{j=1} (G_k + \\psi_2 \\cdot Q_k)_j\n\\tag{17.9}\\]\nAufgeteilt auf die Geschosse wird diese nach Gleichung 17.10.\n\\[\nF_{d,i} = \\frac{z_i \\sum_{i=1} (G_k + \\psi_2 \\cdot Q_k)_i}{\\sum_{j=1} z_j\\cdot(G_k + \\psi_2 \\cdot Q_k)_j} \\cdot F_d\n\\tag{17.10}\\]\nDer Term der Gleichung 17.11 entspricht den Punktmassen.\n\\[\nG_k + \\psi_2 \\cdot Q_k\n\\tag{17.11}\\]\nDie Ersatzkraft greift am Massenschwerpunkt der Decke an. Diese gilt es ins Steifigkeitszentrum zu verschieben. Daraus resultiert ein Torsionsmoment.\n\n17.2.9.1 X-Richtung\n\nF_d_x = np.sum(np.array([m_1, m_2, m_3])*g*S_d_x)\nrender.eq_display('F_d_x', F_d_x.subs(params).evalf(3))\n\n\\[\\begin{equation}F_{d x} = 1.3 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\nH_masse_i = np.array([(H_1) * m_1,(H_1+H_2) * m_2,(H_1+H_2+H_3) * m_3])\n\nV_x_i = H_masse_i / np.sum(H_masse_i) * F_d_x\n\nV_x_i_dict = {f'V_x{i+1}': V_x_i[i].subs(params).evalf(3) for i in range(len(V_x_i))}\nrender.dict_to_table(V_x_i_dict)\n\n\n\n\n\n\n\n\n\\(V_{x1} = 2.25 \\cdot 10^{5} \\text{N}\\)\n\\(V_{x2} = 4.5 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(V_{x3} = 6.27 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\n\n\n17.2.9.2 Y-Richtung\n\nF_d_y = np.sum(np.array([m_1, m_2, m_3])*g*S_d_y)\nrender.eq_display('F_d_y', F_d_y.subs(params).evalf(3))\n\n\\[\\begin{equation}F_{d y} = 1.4 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\nV_y_i = H_masse_i / np.sum(H_masse_i) * F_d_y\n\n\nV_y_i_dict = {f'V_y{i+1}': V_y_i[i].subs(params).evalf(3) for i in range(len(V_y_i))}\nrender.dict_to_table(V_y_i_dict)\n\n\n\n\n\n\n\n\n\\(V_{y1} = 2.41 \\cdot 10^{5} \\text{N}\\)\n\\(V_{y2} = 4.83 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(V_{y3} = 6.73 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\n\n\n\n17.2.10 Wandkoordinaten zum Schubmittelpunkt\nDer Ursprung des Koordinatensystems wird in das Steifigkeitszentrum gelegt.\n\nx_i_star = x_i-x_c\n\nx_i_star_dict = {f'x{i+1}': x_i_star[i].subs(params).evalf(3) for i in range(len(x_i_star))}\nrender.dict_to_table(x_i_star_dict)\n\n\n\n\n\n\n\n\n\\(x_{1} = - 0.854 \\text{m}\\)\n\\(x_{2} = 7.65 \\text{m}\\)\n\n\n\\(x_{3} = - 2.85 \\text{m}\\)\n\\(x_{4} = 13.1 \\text{m}\\)\n\n\n\n\n\n\ny_i_star = y_i - y_c\n\ny_i_star_dict = {f'y{i+1}': y_i_star[i].subs(params).evalf(3) for i in range(len(y_i_star))}\nrender.dict_to_table(y_i_star_dict)\n\n\n\n\n\n\n\n\n\\(y_{1} = 4.46 \\text{m}\\)\n\\(y_{2} = - 10.5 \\text{m}\\)\n\n\n\\(y_{3} = - 3.04 \\text{m}\\)\n\\(y_{4} = 2.96 \\text{m}\\)\n\n\n\n\n\n\n\n17.2.11 Stockwerkstorsion\nBeachte die Vorzeichenkonvention: Das Torsionsmoment ist positiv im Gegenuhrzeigersinn.\nNach Norm (Schweizerischer Ingenieur- und Architektenverein (SIA), 2020) 16.5.3.4 ist die Exzentrizität (Schubmittelpunkt zu Massenschwerpunkt) anhand der Gebäudeabmessungen zu erhöhen.\n\\[\ne_{d,sup} = 1.5\\cdot e+0.05\\cdot b\n\\tag{17.12}\\]\n\\[\ne_{d,inf} = 0.5\\cdot e-0.05\\cdot b\n\\tag{17.13}\\]\n\\(b\\) Gebäudebreite in der entsprechenden Kraftrichtung\n\\(e\\) Exzentrizität\nAus den entstehenden 4 Lastfällen ist der ungünstigste massgebend. Es wird lediglich \\(e_{d,sup}\\) betrachtet.\n\n17.2.11.1 X-Richtung\n\ne_d_y_sup = sp.Abs(y_c) * 1.5+0.05*3*L_y\n\nrender.eq_display('e_dysup', e_d_y_sup.subs(params).evalf(3))\n\n\\[\\begin{equation}e_{dysup} = 5.31 \\text{m}\\end{equation}\\]\n\n\n\nT_x_i = V_x_i * e_d_y_sup\n\nT_x_i_dict = {f'T_x{i+1}': T_x_i[i].subs(params).evalf(3) for i in range(len(T_x_i))}\nrender.dict_to_table(T_x_i_dict)\n\n\n\n\n\n\n\n\n\n\\(T_{x1} = 1.2 \\cdot 10^{6} \\text{m} \\text{N}\\)\n\\(T_{x2} = 2.39 \\cdot 10^{6} \\text{m} \\text{N}\\)\n\n\n\\(T_{x3} = 3.33 \\cdot 10^{6} \\text{m} \\text{N}\\)\n\n\n\n\n\n\n\n\n17.2.11.2 Y-Richtung\n\ne_d_x_sup = sp.Abs(x_c) * 1.5+0.05*5*L_x\n\nrender.eq_display('e_dxsup', e_d_x_sup.subs(params).evalf(3))\n\n\\[\\begin{equation}e_{dxsup} = 5.72 \\text{m}\\end{equation}\\]\n\n\n\nT_y_i = V_y_i * e_d_x_sup\n\nT_y_i_dict = {f'T_y{i+1}': T_y_i[i].subs(params).evalf(3) for i in range(len(T_y_i))}\nrender.dict_to_table(T_y_i_dict)\n\n\n\n\n\n\n\n\n\\(T_{y1} = 1.38 \\cdot 10^{6} \\text{m} \\text{N}\\)\n\\(T_{y2} = 2.76 \\cdot 10^{6} \\text{m} \\text{N}\\)\n\n\n\\(T_{y3} = 3.85 \\cdot 10^{6} \\text{m} \\text{N}\\)\n\n\n\n\n\n\n\n\n\n17.2.12 Wandquerkraft\nDie Kräfte wirken jeweils parallel zur Wandebene. Die Beanspruchung der einzelnen Wandscheiben durch die Stockwerkquerkraft \\(V_{xi}\\) oder \\(V_{yi}\\) setzt sich aus einem Translationsanteil (Querkraft) und einem Rotationsanteil (Torsion) zusammen. Diese können sich im Grundriss günstig oder ungünstig überlagern.\nDer Kraftanteil wird durch Gleichung 17.14 und Gleichung 17.15 bestimmt.\n\\[\nF_{x,i} = \\frac{V_{x} \\cdot I_{yi}}{\\sum_{i=1}^n I_{y,i}} - T_{x} \\cdot \\frac{I_{y,i} \\cdot y_i^\\star}{\\sum (I_{x,i} \\cdot x_i^{\\star 2}) + ( I_{y,i} \\cdot y_i^{\\star 2})}\n\\tag{17.14}\\]\n\\[\nF_{y,i} = \\frac{V_{y} \\cdot I_{xi}}{\\sum_{i=1}^n I_{x,i}} + T_{y} \\cdot \\frac{I_{x,i} \\cdot x_i^\\star}{\\sum (I_{x,i} \\cdot x_i^{\\star 2}) + ( I_{y,i} \\cdot y_i^{\\star 2})}\n\\tag{17.15}\\]\nDabei kann Gleichung 17.16 als Wölbmoment interpretiert werden.\n\\[\n\\sum (I_{x,i} \\cdot x_i^{\\star 2}) + ( I_{y,i} \\cdot y_i^{\\star 2})\n\\tag{17.16}\\]\nWichtig ist dabei die Unterscheidung anhand der Ausrichtung der Wand. Als Beispiel wird für eine Einwirkung in X-Richtung für Wand 1 und Wand 2 die Gleichung 17.14 verwendet und für die Wand 3 und Wand 4 Gleichung 17.15 mit Einwirkung \\(V_y = 0\\) und für \\(T_y\\) wird \\(T_x\\) eingesetzt.\nDie dargestellten Resultate entsprechen den Einwirkungen auf die Wandscheiben pro Stockwerk. Zur Ermittlung der Wandquerkraft im EG sind sämtliche Stockwerkquerkräfte zu addieren.\n\ndef kraft_plot(kraft_vektor,torsionsmoment, querkraft, name='test', richtung='X'):\n    \n    from matplotlib.patches import FancyArrowPatch\n\n\n# Erstellen Sie den Plot mit angepasster Größe und gleichem Seitenverhältnis der Achsen\n    fig, ax = plt.subplots(1, figsize=(4.55,4.55))\n    ax.set_aspect('equal')\n\n\n    \n    # Wandmittelpunkte\n    ax.scatter(x_i_plot, y_i_plot, color='red', marker='+')\n\n\n    \n    # Kraft-Vektoren\n    forces = np.float64(kraft_vektor/unit.N)\n    for i, (x, y) in enumerate(zip(x_i_plot, y_i_plot)):\n        if i &lt; 2:\n            ax.arrow(x, y, forces[i]/abs(forces[i]), 0, head_width=0.3, head_length=0.7, fc='orange', ec='orange', linewidth=3)\n            ax.text(x + forces[i]/abs(forces[i]), y + 0.5, f'{abs(forces[i])/1000} kN', fontsize=12, color='orange')\n        else:\n            ax.arrow(x, y, 0, forces[i]/abs(forces[i]), head_width=0.3, head_length=0.7, fc='orange', ec='orange', linewidth=3)\n            ax.text(x + 0.5, y + forces[i]/abs(forces[i]), f'{abs(forces[i])/1000} kN', fontsize=12, color='orange')\n\n\n    \n    # Einwirkungen\n    arrow = FancyArrowPatch((-0.8, 0), (0, -0.8), connectionstyle=\"arc3,rad=0.8\", arrowstyle=\"Simple,tail_width=0.3,head_width=4,head_length=8\", color=\"red\")\n    ax.add_patch(arrow)\n    ax.text(-2, -2, f'{np.round(torsionsmoment/1000,1)} kNm', fontsize=12, color='red')\n    \n    \n    if richtung == 'X':\n        ax.arrow(0, 0, querkraft/ abs(querkraft), 0, head_width=0.3, head_length=0.7, fc='red', ec='red', linewidth=3)\n        ax.text(0 + 1, 0 + 1, f'{np.round(querkraft/1000,1)} kN', fontsize=12, color='red')\n        \n    if richtung == 'Y':\n        ax.arrow(0, 0, 0,querkraft/ abs(querkraft), head_width=0.3, head_length=0.7, fc='red', ec='red', linewidth=3)\n        ax.text(0 + 1, 0 + 1, f'{np.round(querkraft/1000,1)} kN', fontsize=12, color='red')\n    \n\n    \n    ax.axis('off')\n    fig.savefig(f'bilder/{name}_Vektoren.svg', transparent=True)\n    plt.close(fig)\n    \n    # Hier beginnt die Montage mit svgutils und angepasster SVG-Größe\n    sc.Figure(\"425.197\", \"269.291\",\n        sc.Panel(sc.SVG(\"bilder/aufgabe_ekv_gebaeude_GR.svg\").scale(1)),\n        sc.Panel(sc.SVG(f'bilder/{name}_Vektoren.svg')).move(73,-30)\n    ).save(f'bilder/{name}_Vektoren_GR.svg')\n    \n    display(SVG(f'bilder/{name}_Vektoren_GR.svg'))\n\n\n17.2.12.1 X-Richtung\n\nWandkraft_i_durch_V_x = np.array([])\nWandkraft_durch_V_x_list = []\nfor j in range(0,len(V_x_i)):\n\n    Wandkraft_12_durch_V_x = (V_x_i[j] * I_y_i[0:2] / np.sum(I_y_i)) - T_x_i[j] * (I_y_i[0:2]*y_i_star[0:2])/ np.sum((I_x_i*x_i_star**2)+(I_y_i*y_i_star**2))\n    \n    Wandkraft_34_durch_V_x =  T_x_i[j] * (I_x_i[2:]*x_i_star[2:])/ np.sum((I_x_i*x_i_star**2)+(I_y_i*y_i_star**2))\n\n    Wandkraft_durch_V_x = np.concatenate((Wandkraft_12_durch_V_x,Wandkraft_34_durch_V_x))\n    Wandkraft_i_durch_V_x = np.append(Wandkraft_i_durch_V_x, [Wandkraft_durch_V_x[i].subs(params).evalf(3) for i in range(len(Wandkraft_durch_V_x))])\n\n    \n    Wandkraft_durch_V_x_dict = {f'F_x_{j+1}{i+1}': Wandkraft_durch_V_x[i].subs(params).evalf(3) for i in range(len(Wandkraft_durch_V_x))}\n    Wandkraft_durch_V_x_list.append(Wandkraft_durch_V_x_dict)\n\n\nrender.dict_to_table(Wandkraft_durch_V_x_list[0])\n\n\n\n\n\n\n\n\n\\(F_{x 11} = 1.23 \\cdot 10^{5} \\text{N}\\)\n\\(F_{x 12} = 1.0 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(F_{x 13} = - 4.27 \\cdot 10^{4} \\text{N}\\)\n\\(F_{x 14} = 4.25 \\cdot 10^{4} \\text{N}\\)\n\n\n\n\n\n\nkraft_plot(Wandkraft_i_durch_V_x[0:4],np.float64(T_x_i_dict['T_x1']/unit.m/unit.N),np.float64(V_x_i_dict['V_x1']/unit.N),  name='V_x_stock_1', richtung='X')\n\n\n\n\nAbbildung 17.8: Scheibenkräfte im EG durch die Kraft in X-Richtung\n\n\n\n\n\n\nrender.dict_to_table(Wandkraft_durch_V_x_list[1])\n\n\n\n\n\n\n\n\n\\(F_{x 21} = 2.46 \\cdot 10^{5} \\text{N}\\)\n\\(F_{x 22} = 2.01 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(F_{x 23} = - 8.55 \\cdot 10^{4} \\text{N}\\)\n\\(F_{x 24} = 8.5 \\cdot 10^{4} \\text{N}\\)\n\n\n\n\n\n\nkraft_plot(Wandkraft_i_durch_V_x[4:8],np.float64(T_x_i_dict['T_x2']/unit.m/unit.N),np.float64(V_x_i_dict['V_x2']/unit.N),  name='V_x_stock_2', richtung='X')\n\n\n\n\nAbbildung 17.9: Scheibenkräfte im 1.OG durch die Kraft in X-Richtung\n\n\n\n\n\n\nrender.dict_to_table(Wandkraft_durch_V_x_list[2])\n\n\n\n\n\n\n\n\n\\(F_{x 31} = 3.42 \\cdot 10^{5} \\text{N}\\)\n\\(F_{x 32} = 2.8 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(F_{x 33} = - 1.19 \\cdot 10^{5} \\text{N}\\)\n\\(F_{x 34} = 1.19 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\nkraft_plot(Wandkraft_i_durch_V_x[8:],np.float64(T_x_i_dict['T_x3']/unit.m/unit.N),np.float64(V_x_i_dict['V_x3']/unit.N),  name='V_x_stock_3', richtung='X')\n\n\n\n\nAbbildung 17.10: Scheibenkräfte im 2.OG durch die Kraft in X-Richtung\n\n\n\n\n\n\n\n17.2.12.2 Y-Richtung\n\nWandkraft_i_durch_V_y = np.array([])\nWandkraft_durch_V_y_list = []\nfor j in range(0,len(V_y_i)):\n\n    Wandkraft_34_durch_V_y = (V_y_i[j] * I_x_i[2:] / np.sum(I_x_i)) + T_y_i[j] * (I_x_i[2:]*x_i_star[2:])/ np.sum((I_x_i*x_i_star**2)+(I_y_i*y_i_star**2))\n    \n    Wandkraft_12_durch_V_y =  -T_y_i[j] * (I_y_i[0:2]*y_i_star[0:2])/ np.sum((I_x_i*x_i_star**2)+(I_y_i*y_i_star**2))\n\n    Wandkraft_durch_V_y = np.concatenate((Wandkraft_12_durch_V_y,Wandkraft_34_durch_V_y),axis=0)\n    Wandkraft_i_durch_V_y = np.append(Wandkraft_i_durch_V_y, [Wandkraft_durch_V_y[i].subs(params).evalf(3) for i in range(len(Wandkraft_durch_V_y))])\n\n    Wandkraft_durch_V_y_dict = {f'F_y_{j+1}{i+1}': Wandkraft_durch_V_y[i].subs(params).evalf(3) for i in range(len(Wandkraft_durch_V_y))}\n    Wandkraft_durch_V_y_list.append(Wandkraft_durch_V_y_dict)\n\n\nrender.dict_to_table(Wandkraft_durch_V_y_list[0])\n\n\n\n\n\n\n\n\n\\(F_{y 11} = - 3.95 \\cdot 10^{4} \\text{N}\\)\n\\(F_{y 12} = 3.94 \\cdot 10^{4} \\text{N}\\)\n\n\n\\(F_{y 13} = 1.48 \\cdot 10^{5} \\text{N}\\)\n\\(F_{y 14} = 9.18 \\cdot 10^{4} \\text{N}\\)\n\n\n\n\n\n\nkraft_plot(Wandkraft_i_durch_V_y[0:4],np.float64(T_y_i_dict['T_y1']/unit.m/unit.N),np.float64(V_y_i_dict['V_y1']/unit.N),  name='V_y_stock_1', richtung='Y')\n\n\n\n\nAbbildung 17.11: Scheibenkräfte im EG durch die Kraft in Y-Richtung\n\n\n\n\n\n\nrender.dict_to_table(Wandkraft_durch_V_y_list[1])\n\n\n\n\n\n\n\n\n\\(F_{y 21} = - 7.89 \\cdot 10^{4} \\text{N}\\)\n\\(F_{y 22} = 7.88 \\cdot 10^{4} \\text{N}\\)\n\n\n\\(F_{y 23} = 2.97 \\cdot 10^{5} \\text{N}\\)\n\\(F_{y 24} = 1.84 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\nkraft_plot(Wandkraft_i_durch_V_y[4:8],np.float64(T_y_i_dict['T_y2']/unit.m/unit.N),np.float64(V_y_i_dict['V_y2']/unit.N),  name='V_y_stock_2', richtung='Y')\n\n\n\n\nAbbildung 17.12: Scheibenkräfte im 1.OG durch die Kraft in Y-Richtung\n\n\n\n\n\n\nrender.dict_to_table(Wandkraft_durch_V_y_list[2])\n\n\n\n\n\n\n\n\n\\(F_{y 31} = - 1.1 \\cdot 10^{5} \\text{N}\\)\n\\(F_{y 32} = 1.1 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(F_{y 33} = 4.14 \\cdot 10^{5} \\text{N}\\)\n\\(F_{y 34} = 2.56 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\nkraft_plot(Wandkraft_i_durch_V_y[8:],np.float64(T_y_i_dict['T_y3']/unit.m/unit.N),np.float64(V_y_i_dict['V_y3']/unit.N),  name='V_y_stock_3', richtung='Y')\n\n\n\n\nAbbildung 17.13: Scheibenkräfte im 2.OG durch die Kraft in Y-Richtung\n\n\n\n\n\n\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2020). Norm SIA 261:2020 Einwirkungen auf Tragwerke  (136. S.)."
  },
  {
    "objectID": "ekv_02.html#aufgabenstellung",
    "href": "ekv_02.html#aufgabenstellung",
    "title": "18  Beispiel: Rayleigh-Quotient und Fundamentsteifigkeit beim Ersatzkraftverfahren",
    "section": "18.1 Aufgabenstellung",
    "text": "18.1 Aufgabenstellung\nIn Abbildung 18.1 ist ein Gebäudegrundriss dargestellt. Dieser wird durch drei Stahlbeton-Wandscheiben ausgesteift. Die Anordnung ist symmetrisch, das Steifigkeitszentrum stimmt mit dem Massenzentrum der Decke überein.\n\n\n\nAbbildung 18.1: Grundriss des Gebäudes\n\n\nDas Untergeschoss gilt als steifer Kasten, folglich ist der Einspannungshorizont der Wandscheiben Oberkante UG. Es findet eine gewisse Einspannung der Wandscheiben in die Bodenplatte statt, je nach Ausbildung der Fundation. Diese kann man z.B. mit einer elastischen Einspannung (Drehfeder) modellieren. Die elastische Einspannung liegt im Bereich von 20% einer Volleinspannung. Im Beispiel wird diese als gelenkige Lagerung angenommen.\n\n\n\nAbbildung 18.2: Ansicht der Wand 3 des Gebäudes\n\n\nDie Modellierung in Abbildung 18.3 trifft folgende Annahmen:\n\nDie Decken sind gelenkig an die Tragwände angeschlossen\nDie Deckenscheiben wirken in ihrer Ebene als starre Scheiben\nDie Wandscheiben bzw. Tragwände sind in den Kellerkasten eingespannt, so dass die Modellierung als Kragarm gerechtfertigt ist\nDie Massen der Decken werden im Aufriss als Punktmassen am Kragarm abgebildet (Dabei werden die Massen der Wände pro Geschoss je zur Hälfte der Geschossmassen zugeordnet)\nDie Stützen tragen lediglich zum vertikalen Lastabtrag bei. Deren Steifigkeit kann vernachlässigt werden\n\n\n\n\nAbbildung 18.3: Modellierung als Mehrmassenschwinger\n\n\nGesucht:\n\nErste Eigenperiode in globaler Y-Richtung\nErsatzkräfte durch das Ersatzkraftverfahren\n\nGegeben:\n\nBaugrundklasse \\(B\\)\nErdbebenzone \\(Z2\\)\nDecken und Wände sind alle \\(d\\) stark\nSämtliche Decken gelten als Wohnflächen (Lastermittlung - vereinfacht auch die Dachfläche)\nReduktion der Biegesteifigkeit \\(\\gamma_{EI}\\) zur Berücksichtigung der Rissbildung\n\n\nrho_c, gamma_f, q,q_auflast_k, q_nutzlast_k = sp.symbols('rho_c, gamma_f, q, q_auflast_k, q_nutzlast_k')\nH_1, H_2, H_3 = sp.symbols(\"H_1, H_2, H_3\")\nm_1, m_2, m_3 = sp.symbols('m_1, m_2, m_3')\n\ngamma_EI = sp.symbols('gamma_EI')\n\nF_1, F_2, F_3 = sp.symbols('F_1, F_2, F_3')\n\nE, d, L_y, L_x, L_w1, L_w2, L_w3 = sp.symbols('E, d, L_y, L_x, L_w1, L_w2, L_w3')\n\n\nC_1 = sp.symbols('C_1')\n\n\nH = sp.symbols('H', positive=True)\n\nu_0 = sp.symbols('u_0')\n\n\nG_c, nu_c = sp.symbols('G_c, nu_c')\n\nG_eff_sand, nu_sand = sp.symbols('G_eff_sand nu_sand')\n\n\nparams = {\n    'E':30000 *unit.N/unit.mm**2,\n    'd':0.3*unit.m,\n    'L_y':5*unit.m, \n    'L_x':4*unit.m,\n    'L_w1':4*unit.m,\n    'L_w2':4*unit.m,\n    'L_w3':5*unit.m,\n    'q': 2.0,\n    'gamma_f': 1.0,\n    'q_nutzlast_k': 3*10**3*unit.N/unit.m**2,\n    'q_auflast_k': 1*10**3*unit.N/unit.m**2,\n    'H_1':4*unit.m,\n    'H_2':4*unit.m,\n    'H_3':4*unit.m,\n    'rho_c':25000*unit.N / unit.m**3,\n    'g':10 *unit.m/unit.second**2,\n    'gamma_EI':0.50,\n    'G_eff_sand':120*10**6*unit.N/unit.m**2,\n    'nu_sand':0.3,\n\n}\nparams_plot = convert.param_value(params)\nrender.dict_to_table(params)\n\n\n\nTabelle 18.1: Verwendete Parameter der Aufgabe\n\n\n\n\n\n\n\\(E = \\frac{30000 \\text{N}}{\\text{mm}^{2}}\\)\n\\(G_{eff sand} = \\frac{120000000 \\text{N}}{\\text{m}^{2}}\\)\n\n\n\\(H_{1} = 4 \\text{m}\\)\n\\(H_{2} = 4 \\text{m}\\)\n\n\n\\(H_{3} = 4 \\text{m}\\)\n\\(L_{w1} = 4 \\text{m}\\)\n\n\n\\(L_{w2} = 4 \\text{m}\\)\n\\(L_{w3} = 5 \\text{m}\\)\n\n\n\\(L_{x} = 4 \\text{m}\\)\n\\(L_{y} = 5 \\text{m}\\)\n\n\n\\(d = 0.3 \\text{m}\\)\n\\(g = \\frac{10 \\text{m}}{\\text{s}^{2}}\\)\n\n\n\\(\\gamma_{EI} = 0.5\\)\n\\(\\gamma_{f} = 1.0\\)\n\n\n\\(\\nu_{sand} = 0.3\\)\n\\(q = 2.0\\)\n\n\n\\(q_{auflast k} = \\frac{1000 \\text{N}}{\\text{m}^{2}}\\)\n\\(q_{nutzlast k} = \\frac{3000 \\text{N}}{\\text{m}^{2}}\\)\n\n\n\\(\\rho_{c} = \\frac{25000 \\text{N}}{\\text{m}^{3}}\\)"
  },
  {
    "objectID": "ekv_02.html#musterlösung",
    "href": "ekv_02.html#musterlösung",
    "title": "18  Beispiel: Rayleigh-Quotient und Fundamentsteifigkeit beim Ersatzkraftverfahren",
    "section": "18.2 Musterlösung",
    "text": "18.2 Musterlösung\n\n18.2.1 Lastermittlung\nGemäss Schweizerischer Ingenieur- und Architektenverein (SIA) (2020) Ziff. 16.5.2.3 sind ständige und quasiständige Lasten anzusetzen. Bei der Lastermittlung werden die Gewichtskräfte aus Eigenmassen und Auflasten ermittelt. Dazu werden pro Stockwerk die Gewichtskräfte der Wände definiert. Eine Punktmasse erhält jeweils die Hälfte der darunter- und darüber liegenden Wände. Für die Decke über 2.OG bleibt folglich nur eine Hälfte der Wände.\n\n\n\n\nA_decke = 5*L_x* 3 * L_y\nG_decke = A_decke * rho_c* d\nG_waende_stock = (L_w1 +L_w2+L_w3)*H_1 * rho_c * d\nQ_auflast_k = q_auflast_k * A_decke\nQ_nutzlast_k = q_nutzlast_k * A_decke\npsi_2 = 0.3\n\nparams['m_3'] = ((G_decke + Q_auflast_k+ G_waende_stock/2+psi_2 * Q_nutzlast_k)/g).subs(params)\nparams['m_2'] = ((G_decke + Q_auflast_k+ G_waende_stock+psi_2 * Q_nutzlast_k)/g).subs(params)\nparams['m_1'] = ((G_decke + Q_auflast_k+ G_waende_stock+psi_2 * Q_nutzlast_k)/g).subs(params)\n\nrender.eq_display('A_Decke', A_decke.subs(params).evalf(3),\n                  'G_Decke_k', G_decke.subs(params).evalf(3),\n                  'G_Waende_k', G_waende_stock.subs(params).evalf(3),\n                  'Q_auflast_k', Q_auflast_k.subs(params).evalf(3),\n                  'Q_nutzlast_k', Q_nutzlast_k.subs(params).evalf(3),\n                  'psi_2', psi_2,\n                  )\n\n\n\\[\\begin{equation}A_{Decke} = 300.0 \\text{m}^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{Decke k} = 2.25 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{Waende k} = 3.9 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Q_{auflast k} = 3.0 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Q_{nutzlast k} = 9.0 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\psi_{2} = 0.3\\end{equation}\\]\n\n\nDaraus lassen sich die Punktmassen bestimmen:\n\nrender.eq_display('m_1', \"(G_decke + Q_auflast_k+ G_Waende_k+psi_2 * Q_nutzlast_k)/g\",\n                 'm_1', m_1.subs(params).evalf(3),\n                 'm_2', \"(G_decke + Q_auflast_k+ G_Waende_k+psi_2 * Q_nutzlast_k)/g\",\n                 'm_2', m_2.subs(params).evalf(3),\n                 'm_3', \"(G_decke + Q_auflast_k+ G_Waende_k/2+psi_2 * Q_nutzlast_k)/g\",\n                 'm_3', m_3.subs(params).evalf(3))\n\n\\[\\begin{equation}m_{1} = \\frac{G_{Waende k} + G_{decke} + Q_{auflast k} + Q_{nutzlast k} \\psi_{2}}{g}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{1} = \\frac{3.21 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{2} = \\frac{G_{Waende k} + G_{decke} + Q_{auflast k} + Q_{nutzlast k} \\psi_{2}}{g}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{2} = \\frac{3.21 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{3} = \\frac{\\frac{G_{Waende k}}{2} + G_{decke} + Q_{auflast k} + Q_{nutzlast k} \\psi_{2}}{g}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{3} = \\frac{3.02 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\n\n\n18.2.2 Biegesteifigkeit\nDie Biegesteifigkeit wird in Y-Richtung bestimmt. Es wird lediglich Wand 3 berücksichtigt. Die Reduktion zur Berücksichtigung der Rissbildung ist ebenfalls miteinbezogen.\n\nI_y = L_w3 ** 3 * d / 12\n\nEI_y_ersatz = I_y * E * gamma_EI\n\nrender.eq_display(\n    'I_y' , 'L_w3 ** 3 * d / 12',\n    'I_y' , I_y.subs(params).evalf(3),\n    'EI_y_ersatz', I_y * E * gamma_EI,\n    'EI_y_ersatz', EI_y_ersatz.subs(params).evalf(3).simplify())\n\n\\[\\begin{equation}I_{y} = \\frac{L_{w3}^{3} d}{12}\\end{equation}\\]\n\n\n\\[\\begin{equation}I_{y} = 3.13 \\text{m}^{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}EI_{y ersatz} = \\frac{E L_{w3}^{3} d \\gamma_{EI}}{12}\\end{equation}\\]\n\n\n\\[\\begin{equation}EI_{y ersatz} = 4.69 \\cdot 10^{10} \\text{m}^{2} \\text{N}\\end{equation}\\]\n\n\n\n\n18.2.3 Formfunktion aus der Biegelinie\nAls geeignete statische Belastung für die Abbildung der Eigenform eignet sich eine lineare dreiecksförmige Verteilung von Einzellasten. Diese bewirken am Stab eine Verschiebung \\(u_i\\) auf Höhe der Geschossdecken.\n\n18.2.3.1 Rayleigh-Quotient\nGemäss dem Arbeitssatz gilt: Die von den äusseren Kräften \\(F_i\\) auf ihren Verschiebungswegen \\(u_i\\) geleistete Arbeit entspricht der inneren Arbeit, welche von den Schnittgrössen auf den Dehnungen im Querschnitt geleistet wird.\n\\[\nW_a = W_i\n\\tag{18.1}\\]\nDies führt zur Gleichung 18.2:\n\\[\n\\frac{1}{2} \\sum_{i=1}^n F_i\\cdot u_i=\\int_0^L \\frac{1}{2} EI \\cdot u''(x)^2 \\cdot d_x\n\\tag{18.2}\\]\nUnter Berücksichtigung, dass die Stäbe als masselos zu betrachten sind (da die Massen der Wände zu den Punktmassen dazugezählt sind), lässt sich die Eigenkreisfrequenz gemäss Gleichung 18.3 beschreiben.\n\\[\n\\omega_1^2 = \\frac{\\frac{1}{2}\\sum_{i=1}^n F_i \\cdot u_i}{\\frac{1}{2}\\sum_{i=1}^n m_i \\cdot u_i^2} = \\frac{\\text{max. potentielle Energie}}{\\text{max. kinetische Energie}}\n\\tag{18.3}\\]\nZur Ermittlung der Biegelinie, bzw. der Verformungen \\(u_i\\) wird das gleiche Vorgehen wie bei der Ermittlung der Nachgiebigkeitsmatrix angewendet.\n\n\n\nAbbildung 18.4: System mit Einwirkungen zur Bestimmung der Formfunktion anhand der Biegelinie\n\n\nDaraus lassen sich die Kräftezustände beschreiben:\n\n\n\nAbbildung 18.5: Schnittgrössen im realen und fiktiven Kräftezustand\n\n\nDurch die Anwendung der Arbeitsgleichung lassen sich die jeweiligen Deformationen bestimmen. Die Indizes \\(ij\\) in \\(\\delta_{ij}\\) bedeuten \\(i\\) Position der realen Einwirkung und \\(j\\) Position der fiktiven Einwirkung. Dies resultiert zur Nachgiebigkeitsmatrix. Invertiert folgt daraus die Steifigkeitsmatrix. Mit den Einwirkungen multipliziert folgt die Deformation an jedem Punkt.\nZur Bestimmung der Nachgiebigkeitsmatrix werden die Kräfte \\(F_i = 1\\) gesetzt. Durch Multiplikation mit dem effektiven Kraftvektor resultieren die entsprechenden Verformungen.\n\nF_1_n, F_2_n, F_3_n = 1 ,1 ,1\n\n\ndef delta_ij(M, m_l, m_r, L):\n    return (sp.Rational(1,6) / EI_y_ersatz) * M*(m_l+2*m_r)*L\n\n\ndelta_11 = delta_ij(F_1_n * H_1, 0, H_1, H_1)\ndelta_22 = delta_ij(F_2_n * (H_1+H_2), 0, (H_1+H_2), (H_1+H_2))\ndelta_33 = delta_ij(F_3_n * (H_1+H_2+H_3), 0, (H_1+H_2+H_3), (H_1+H_2+H_3))\n\ndelta_12 = delta_ij(F_1_n*H_1, H_1, H_1+H_2, H_1)\ndelta_21 = delta_12\n\ndelta_13 = delta_ij(F_1_n*H_1,H_1+H_2, H_1+H_2+H_3, H_1)\ndelta_31 = delta_13\n\ndelta_23 = delta_ij(F_2_n*(H_1+H_2), H_3, H_1+H_2+H_3, H_1 + H_2)\ndelta_32 = delta_23\n\nrender.eq_display('delta_11', delta_11,\n               'delta_12', delta_12,\n               'delta_13', delta_13,\n               'delta_21', delta_21,\n               'delta_22', delta_22,\n               'delta_23', delta_23,\n               'delta_31', delta_31,\n               'delta_32', delta_32,\n               'delta_33', delta_33,\n)\n\n\\[\\begin{equation}\\delta_{11} = \\frac{4 H_{1}^{3}}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{12} = \\frac{2 H_{1}^{2} \\cdot \\left(3 H_{1} + 2 H_{2}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{13} = \\frac{2 H_{1}^{2} \\cdot \\left(3 H_{1} + 3 H_{2} + 2 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{21} = \\frac{2 H_{1}^{2} \\cdot \\left(3 H_{1} + 2 H_{2}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{22} = \\frac{2 \\left(H_{1} + H_{2}\\right)^{2} \\cdot \\left(2 H_{1} + 2 H_{2}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{23} = \\frac{2 \\left(H_{1} + H_{2}\\right)^{2} \\cdot \\left(2 H_{1} + 2 H_{2} + 3 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{31} = \\frac{2 H_{1}^{2} \\cdot \\left(3 H_{1} + 3 H_{2} + 2 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{32} = \\frac{2 \\left(H_{1} + H_{2}\\right)^{2} \\cdot \\left(2 H_{1} + 2 H_{2} + 3 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\delta_{33} = \\frac{2 \\left(H_{1} + H_{2} + H_{3}\\right)^{2} \\cdot \\left(2 H_{1} + 2 H_{2} + 2 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\end{equation}\\]\n\n\nEingesetzt in die Nachgiebigkeitsmatrix und mit dem Kraftvektor multipliziert:\n\n\nparams['F_1'] = 1000*unit.N\nparams['F_2'] = 2000*unit.N\nparams['F_3'] = 3000*unit.N\n\n\nD_matrix = sp.Matrix([[delta_11, delta_12, delta_13],[delta_21, delta_22, delta_23],[delta_31, delta_32, delta_33]])\n\n\nF_vektor = sp.Matrix([[F_1],[F_2],[F_3]])\n\nu_vektor = D_matrix * F_vektor\nrender.eq_display(\n    sp.MatrixSymbol('D', 3,3), \nsp.simplify(D_matrix),\n    sp.MatrixSymbol('D', 3,3), \nunit.convert_to(sp.simplify(D_matrix.subs(params)).evalf(3), unit.mm),\n    sp.MatrixSymbol('F', 3,1), F_vektor.subs(params),\n    'u', 'D * F',\n    sp.MatrixSymbol('u', 3,1), unit.convert_to(sp.simplify(u_vektor.subs(params)).evalf(3), unit.mm))\n\n\\[\\begin{equation}\\mathbf{D} = \\left[\\begin{matrix}\\frac{4 H_{1}^{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{H_{1}^{2} \\cdot \\left(6 H_{1} + 4 H_{2}\\right)}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{H_{1}^{2} \\cdot \\left(6 H_{1} + 6 H_{2} + 4 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\\\\\frac{H_{1}^{2} \\cdot \\left(6 H_{1} + 4 H_{2}\\right)}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{4 \\left(H_{1} + H_{2}\\right)^{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{\\left(H_{1} + H_{2}\\right)^{2} \\cdot \\left(4 H_{1} + 4 H_{2} + 6 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}}\\\\\\frac{H_{1}^{2} \\cdot \\left(6 H_{1} + 6 H_{2} + 4 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{\\left(H_{1} + H_{2}\\right)^{2} \\cdot \\left(4 H_{1} + 4 H_{2} + 6 H_{3}\\right)}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{4 \\left(H_{1} + H_{2} + H_{3}\\right)^{3}}{E L_{w3}^{3} d \\gamma_{EI}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{D} = \\left[\\begin{matrix}\\frac{4.55 \\cdot 10^{-7} \\text{mm}}{\\text{N}} & \\frac{1.14 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{1.82 \\cdot 10^{-6} \\text{mm}}{\\text{N}}\\\\\\frac{1.14 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{3.64 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{6.37 \\cdot 10^{-6} \\text{mm}}{\\text{N}}\\\\\\frac{1.82 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{6.37 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{1.23 \\cdot 10^{-5} \\text{mm}}{\\text{N}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F} = \\left[\\begin{matrix}1000 \\text{N}\\\\2000 \\text{N}\\\\3000 \\text{N}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}u = D F\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{u} = \\left[\\begin{matrix}0.00819 \\text{mm}\\\\0.0275 \\text{mm}\\\\0.0514 \\text{mm}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\n18.2.3.1.1 Alternative\nAlternativ kann die Nachgiebigkeitsmatrix mit dem folgenden Bildungsgesetz ermitteln. Dies gilt nur bei gleichen Stockwerkshöhen!\n\\[\nD_{ij} = \\frac{H^3}{6EI}\\cdot [j^2 \\cdot(3\\cdot i - j)]\n\\tag{18.4}\\]\nvereinfacht: \\[\nD_{ij} = v\\cdot \\Delta\n\\tag{18.5}\\]\n\nD_bildung = sp.Matrix([[2,5,8],[5,16,28],[8,28,54]])\n\nv_term = H_1*H_2*H_3 / (6 * EI_y_ersatz)\n\nrender.eq_display(\n    'v', 'H_1*H_2*H_3 / (6 * EI_y_ersatz)',\n    sp.MatrixSymbol('Delta',3,3), D_bildung,\n    sp.MatrixSymbol('D', 3,3), D_bildung*v_term,\n    sp.MatrixSymbol('D', 3,3),unit.convert_to(sp.simplify((D_bildung*v_term).subs(params).evalf(3)),unit.mm),\n)\n\n\\[\\begin{equation}v = \\frac{H_{1} H_{2} H_{3}}{6 EI_{y ersatz}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\Delta} = \\left[\\begin{matrix}2 & 5 & 8\\\\5 & 16 & 28\\\\8 & 28 & 54\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{D} = \\left[\\begin{matrix}\\frac{4 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{10 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{16 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}}\\\\\\frac{10 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{32 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{56 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}}\\\\\\frac{16 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{56 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}} & \\frac{108 H_{1} H_{2} H_{3}}{E L_{w3}^{3} d \\gamma_{EI}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{D} = \\left[\\begin{matrix}\\frac{4.55 \\cdot 10^{-7} \\text{mm}}{\\text{N}} & \\frac{1.14 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{1.82 \\cdot 10^{-6} \\text{mm}}{\\text{N}}\\\\\\frac{1.14 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{3.64 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{6.37 \\cdot 10^{-6} \\text{mm}}{\\text{N}}\\\\\\frac{1.82 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{6.37 \\cdot 10^{-6} \\text{mm}}{\\text{N}} & \\frac{1.23 \\cdot 10^{-5} \\text{mm}}{\\text{N}}\\end{matrix}\\right]\\end{equation}\\]\n\n\nDie durch das Bildungsgesetz ermittelte Nachgiebigkeitsmatrix entspricht, der mittels der Arbeitsgleichung ermittelten.\n\n\n\n18.2.3.2 Eigenkreisfrequenz\nDiese kann nach Gleichung 18.3 ermittelt werden.\n\nE_pot = sum(u_vektor.multiply_elementwise(F_vektor))\nM_vektor = sp.Matrix([[m_1],[m_2],[m_3]])\nE_kin = sum(u_vektor.multiply_elementwise(u_vektor).multiply_elementwise(M_vektor))\n\n\nrender.eq_display(\n    'E_pot', E_pot.subs(params).simplify().evalf(3),\n    'E_kin', E_kin.subs(params).simplify().evalf(3)\n\n)\n\n\\[\\begin{equation}E_{pot} = 0.218 \\text{m} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}E_{kin} = 0.00106 \\text{m} \\text{N} \\text{s}^{2}\\end{equation}\\]\n\n\n\nomega_1 = sp.sqrt(E_pot / E_kin)\n\nf_1 = omega_1 / 2 / sp.pi\nT_1 = 1 / f_1\n\n\nrender.eq_display(\n    'omega_1', omega_1.subs(params).simplify().evalf(3),\n    'f_1', f_1.subs(params).simplify().evalf(3),\n    'T_1', T_1.subs(params).simplify().evalf(3)\n)\n\n\\[\\begin{equation}\\omega_{1} = \\frac{14.3}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}f_{1} = \\frac{2.28}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{1} = 0.439 \\text{s}\\end{equation}\\]\n\n\n\n\n18.2.3.3 Bemessungsspektrum\n\na_gd = 1.0*unit.m /unit.second**2\n\n\nS_d_y = bemessungsspektrum(a_gd, T_1.subs(params).simplify().evalf(3), params['q'], params['gamma_f'], Baugrundklasse='B')\n\nrender.eq_display('S_d_y', S_d_y.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(a_{gd} = \\frac{1.0 \\text{m}}{\\text{s}^{2}}\\)\n\\(g = \\frac{10.0 \\text{m}}{\\text{s}^{2}}\\)\n\n\n\\(\\gamma_{f} = 1.0\\)\n\\(q = 2.0\\)\n\n\n\n\n\n\\[\\begin{equation}S_{d} = \\frac{2.5 S_{} T_{C} a_{gd} \\gamma_{f}}{T g q}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{d y} = 0.12\\end{equation}\\]\n\n\n\n\n18.2.3.4 Gesamt-Ersatzkraft\nDie Stockwerksquerkraft resultiert nach Norm aus Gleichung 18.6.\n\\[\nF_d = S_d \\cdot \\sum_{j=1} (G_k + \\psi_2 \\cdot Q_k)_j\n\\tag{18.6}\\]\nAufgeteilt auf die Geschosse wird diese nach Gleichung 18.7.\n\\[\nF_{d,i} = \\frac{z_i \\sum_{i=1} (G_k + \\psi_2 \\cdot Q_k)_i}{\\sum_{j=1} z_j\\cdot(G_k + \\psi_2 \\cdot Q_k)_j} \\cdot F_d\n\\tag{18.7}\\]\nDer Term der Gleichung 18.8 entspricht den Punktmassen.\n\\[\nG_k + \\psi_2 \\cdot Q_k\n\\tag{18.8}\\]\nDie Ersatzkraft greift am Massenschwerpunkt der Decke an.\n\nF_d_y = np.sum(np.array([m_1, m_2, m_3])*g*S_d_y)\nrender.eq_display('F_d_y', F_d_y.subs(params).evalf(3))\n\n\\[\\begin{equation}F_{d y} = 1.13 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\nH_masse_i = np.array([(H_1) * m_1,(H_1+H_2) * m_2,(H_1+H_2+H_3) * m_3])\n\nF_y_i = H_masse_i / np.sum(H_masse_i) * F_d_y\n\n\nF_y_i_dict = {f'F_y{i+1}': F_y_i[i].subs(params).evalf(3) for i in range(len(F_y_i))}\nrender.dict_to_table(F_y_i_dict)\n\n\n\n\n\n\n\n\n\\(F_{y1} = 1.94 \\cdot 10^{5} \\text{N}\\)\n\\(F_{y2} = 3.88 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(F_{y3} = 5.47 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\n\n\n18.2.3.5 Schnittgrössen\n\nparams_plot = convert.param_value(params)\n# Querkraft\n\nF_y_i = list(F_y_i_dict.values())[::-1]\nV_max = [F_y_i[0], F_y_i[0]+F_y_i[1],F_y_i[0]+F_y_i[1]+F_y_i[2]][::-1]\nV_x = sp.Piecewise((V_max[0].subs(params)/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))), (V_max[1].subs(params)/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))), (V_max[2].subs(params)/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n# Biegemoment\nM_x = sp.integrate(-V_x, x) + C_1\nC_1_solve = sp.solve(M_x.subs(x, (H_1+H_2+H_3).subs(params_plot)), C_1)[0]\nM_x = M_x.subs(C_1, C_1_solve)\n\n# Normalkraft\ng = 10*unit.m/unit.second**2\nN_x = sp.Piecewise(((m_1+m_2+m_3).subs(params)*g/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))),((m_3+m_2).subs(params)*g/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))),((m_3).subs(params)*g/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n\n# Numerische Daten generieren\nx_array = np.linspace(-0.01, float((H_1+H_2+H_3+.01).subs(params_plot)), 1000)\nV_x_lamb = sp.lambdify(x, V_x)\nV_x_array = V_x_lamb(x_array)\n\nM_x_lamb = sp.lambdify(x,M_x)\nM_x_array = M_x_lamb(x_array)\n\nN_x_lamb = sp.lambdify(x,N_x)\nN_x_array = N_x_lamb(x_array)\n\n# Figure und Axes erstellen\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n\n# Ersten Plot erstellen\n\nax1.plot(V_x_array/1000, x_array)\nax1.set_title('$V(x)$')\n\n## Horizontale Linien\nax1.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.set_xlabel('$[kN]$')\nax1.set_ylabel('$[m]$')\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n# Zweiten Plot erstellen\n\nax2.plot(M_x_array/1000, x_array, color='orange')\nax2.set_title('$M(x)$')\n\n## Horizontale Linien\nax2.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.set_xlabel('$[kNm]$')\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Dritten Plot erstellen\n\nax3.plot(N_x_array/1000, x_array, color='green')\nax3.set_title('$N(x)$')\nax3.set_xlabel('$[kN]$')\n\n\n## Horizontale Linien\nax3.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax3.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\n\nax3.axvline(0,linestyle='dashed', color='black')\n\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\nAbbildung 18.6: Maximale Schnittgrössen\n\n\n\n\nUnter der Annahme das der Einspanngrad der Tragwand in die biegeweiche Bodenplatte zu vernachlässigen ist, kann das Biegemoment am Kragarm in ein Kräftepaar mit der Stockwerkshöhe im UG von 4m aufgelöst werden. Entsprechend dem System in Abbildung 18.2. Somit ergeben sich nachfolgend dargestellten Schnittkräfte. Elastische Einspanngrade in die Bodenplatte können in Abhängigkeit der Steifigkeit der Fundation berücksichtigt werden. Zu beachten sind die hohen Querkräfte der Tragwand im UG. Da infolge Querkraft ein sprödes Versagen erfolgt, ist bei der Querkraft-Bemessung besonders Beachtung zu schenken.\n\nparams_plot = convert.param_value(params)\n# Querkraft\n\nF_y_i = list(F_y_i_dict.values())[::-1]\nV_max = [F_y_i[0], F_y_i[0]+F_y_i[1],F_y_i[0]+F_y_i[1]+F_y_i[2]][::-1]\nV_x = sp.Piecewise((-np.sum(V_max).subs(params)/unit.N, ((x&lt;0)&(x&gt;=-H_1.subs(params_plot)))),(V_max[0].subs(params)/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))), (V_max[1].subs(params)/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))), (V_max[2].subs(params)/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n# Biegemoment\nM_x = sp.integrate(-V_x, x) + C_1\nC_1_solve = sp.solve(M_x.subs(x, (H_1+H_2+H_3).subs(params_plot)), C_1)[0]\nM_x = M_x.subs(C_1, C_1_solve)\n\n# Normalkraft\ng = 10*unit.m/unit.second**2\nN_x = sp.Piecewise(((m_1+m_2+m_3*2).subs(params)*g/unit.N, ((x&lt;0)&(x&gt;=-H_1.subs(params_plot)))),((m_1+m_2+m_3).subs(params)*g/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))),((m_3+m_2).subs(params)*g/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))),((m_3).subs(params)*g/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n\n# Numerische Daten generieren\nx_array = np.linspace(float((-H_1-.01).subs(params_plot)), float((H_1+H_2+H_3+.01).subs(params_plot)), 1000)\nV_x_lamb = sp.lambdify(x, V_x)\nV_x_array = V_x_lamb(x_array)\n\nM_x_lamb = sp.lambdify(x,M_x)\nM_x_array = M_x_lamb(x_array)\n\nN_x_lamb = sp.lambdify(x,N_x)\nN_x_array = N_x_lamb(x_array)\n\n# Figure und Axes erstellen\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n\n# Ersten Plot erstellen\n\nax1.plot(V_x_array/1000, x_array)\nax1.set_title('$V(x)$')\n\n## Horizontale Linien\nax1.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.set_xlabel('$[kN]$')\nax1.set_ylabel('$[m]$')\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n# Zweiten Plot erstellen\n\nax2.plot(M_x_array/1000, x_array, color='orange')\nax2.set_title('$M(x)$')\n\n## Horizontale Linien\nax2.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.set_xlabel('$[kNm]$')\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Dritten Plot erstellen\n\nax3.plot(N_x_array/1000, x_array, color='green')\nax3.set_title('$N(x)$')\nax3.set_xlabel('$[kN]$')\n\n\n## Horizontale Linien\nax3.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax3.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\n\nax3.axvline(0,linestyle='dashed', color='black')\n\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\nAbbildung 18.7: Maximale Schnittgrössen erweitert in das UG\n\n\n\n\nIn einem weiteren Schritt sind die Auflagerkräfte in der Decke über UG und in der Bodenplatte mit einem geeigneten Fachwerkmodell in die Aussenwände (ebene Scheibe) abzuleiten. Des Weiteren ist auf die lokale Lasteinleitung der Auflagerkräfte in die Decken bzw. Bodenplatte zu achten bzw. rechnerisch nachzuweisen.\n\nR_A = -V_x.subs(x,-3)*unit.N\nR_B = (V_x.subs(x,-3) - V_x.subs(x,1)) * unit.N\n\nrender.eq_display('R_A', R_A,\n                  'R_B', R_B)\n\n\\[\\begin{equation}R_{A} = 2.61 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}R_{B} = - 3.74 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\n\n\n18.2.4 Formfunktion analytisch\nAls Formfunktion wählen wir die bekannte normierte analytische Funktion für den Kragstab, welche die kinematischen Randbedingungen erfüllt.\n\n18.2.4.1 Rayleigh-Quotient\n\nparams[H] = (H_1 + H_2 + H_3).subs(params)\n\n\nPsi_x = 1 - sp.cos(sp.pi * x / ( 2*H))\nrender.eq_display('H', H.subs(params),\n                  'Psi(x)', Psi_x)\n\n\\[\\begin{equation}H = 12 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = 1 - \\cos{\\left(\\frac{\\pi x}{2 H} \\right)}\\end{equation}\\]\n\n\n\\[\nE_{pot,max} = E_{kin,max}\n\\tag{18.9}\\]\n\\[\n\\omega_1^2 = \\frac{\\int_0^L EI[u''(x)]^2 dx}{\\int_0^L m_{const.}[u(x)]^2 dx}\n\\tag{18.10}\\]\nDies lässt sich mit entsprechender Formfunktion schreiben:\n\\[\n\\omega_1^2 = \\frac{\\int_0^L EI[\\Psi''(x)]^2 dx}{\\int_0^L m_{const.}[\\Psi(x)]^2 dx}\n\\tag{18.11}\\]\nDurch die Ermittlung der zweiten Ableitung der Formfunktion:\n\nPsi_x_diff_1 = sp.diff(Psi_x, x)\nPsi_x_diff_2 = sp.diff(Psi_x, x,x)\n\n\nrender.eq_display('Psi(x)', Psi_x,\n                  'Derivative(Psi(x),x)', Psi_x_diff_1,\n                  'Derivative(Psi(x),x,x)', Psi_x_diff_2,)\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = 1 - \\cos{\\left(\\frac{\\pi x}{2 H} \\right)}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d}{d x} \\Psi{\\left(x \\right)} = \\frac{\\pi \\sin{\\left(\\frac{\\pi x}{2 H} \\right)}}{2 H}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d x^{2}} \\Psi{\\left(x \\right)} = \\frac{\\pi^{2} \\cos{\\left(\\frac{\\pi x}{2 H} \\right)}}{4 H^{2}}\\end{equation}\\]\n\n\nDie Funktionswerte der Punktmassen:\n\nPsi_x1 = Psi_x.subs(x, sp.Rational(1,3)*H)\nPsi_x2 = Psi_x.subs(x, sp.Rational(2,3)*H)\nPsi_x3 = Psi_x.subs(x, sp.Rational(3,3)*H)\n\nrender.eq_display('Psi_x1(1/3*H)', Psi_x1.evalf(3),\n                 'Psi_x2(2/3*H)', Psi_x2,\n                 'Psi_x3(H)', Psi_x3\n                 )\n\n\\[\\begin{equation}\\Psi_{x1}{\\left(\\frac{H}{3} \\right)} = 0.134\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi_{x2}{\\left(\\frac{2 H}{3} \\right)} = \\frac{1}{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi_{x3}{\\left(H \\right)} = 1\\end{equation}\\]\n\n\n\n\n18.2.4.2 Eigenkreisfrequenz\nGleichung 18.11 umgeformt und substituiert:\n\\[\n\\omega_1 = \\sqrt{\\frac{k^\\star}{m^\\star}}\n\\tag{18.12}\\]\nMasse:\n\nm_star = m_1*Psi_x1**2 + m_2 *Psi_x2**2 + m_3 * Psi_x3**2\nm_star\n\nrender.eq_display(sp.Symbol('m^\\star'), \"m_1*Psi_x1**2 + m_2 *Psi_x2**2 + m_3 * Psi_x2**2\",\n                  sp.Symbol('m^\\star'), m_star,\n                  sp.Symbol('m^\\star'), m_star.subs(params).evalf(3),\n                 )\n\n\\[\\begin{equation}m^{\\star} = \\Psi_{x1}^{2} m_{1} + \\Psi_{x2}^{2} m_{2} + \\Psi_{x2}^{2} m_{3}\\end{equation}\\]\n\n\n\\[\\begin{equation}m^{\\star} = m_{1} \\left(1 - \\frac{\\sqrt{3}}{2}\\right)^{2} + \\frac{m_{2}}{4} + m_{3}\\end{equation}\\]\n\n\n\\[\\begin{equation}m^{\\star} = \\frac{3.88 \\cdot 10^{5} \\text{N} \\text{s}^{2}}{\\text{m}}\\end{equation}\\]\n\n\nSteifigkeit:\n\nk_star = EI_y_ersatz*sp.integrate(Psi_x_diff_2**2, (x, 0, H))\n\n\nrender.eq_display(sp.Symbol('k^\\star'), \"EI_y_ersatz*Integral(Derivative(Psi(x),x,x)**2, (x, 0, L))\",\n                  sp.Symbol('k^\\star'), k_star,\n                  sp.Symbol('k^\\star'), k_star.subs(params).evalf(3).simplify(),\n                 )\n\n\\[\\begin{equation}k^{\\star} = EI_{y ersatz} \\int\\limits_{0}^{L} \\left(\\frac{d^{2}}{d x^{2}} \\Psi{\\left(x \\right)}\\right)^{2}\\, dx\\end{equation}\\]\n\n\n\\[\\begin{equation}k^{\\star} = \\frac{\\pi^{4} E L_{w3}^{3} d \\gamma_{EI}}{384 H^{3}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k^{\\star} = \\frac{8.25 \\cdot 10^{7} \\text{N}}{\\text{m}}\\end{equation}\\]\n\n\nEigenkreisfrequenz:\n\nomega_1 = sp.sqrt(k_star /m_star)\nrender.eq_display('omega_1', omega_1.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}\\omega_{1} = \\frac{14.6}{\\text{s}}\\end{equation}\\]\n\n\nEigenfrequenz und Eigenperiode:\n\nf_1 = omega_1 / 2 / sp.pi\nT_1 = 1 / f_1\n\nrender.eq_display('f_1', f_1.subs(params).simplify().evalf(3),\n                  'T_1', T_1.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}f_{1} = \\frac{2.32}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{1} = 0.43 \\text{s}\\end{equation}\\]\n\n\n\n\n\n18.2.5 Erweiterung des Rayleigh-Quotienten\nEine Erweiterung des Rayleigh-Quotienten besteht in der näherungsweisen Berücksichtigung von Schubverformungen und Fundamentverdrehungen. Beide führen zu einem weicheren System. Bei langen Stahlbetonwänden und Mauerwerkswänden sind die Schubverformungen zu berücksichtigen. Bei weichem Baugrund folglich die Fundamentverdrehungen.\nDie Abbildung 18.8 zeigt ein idealisiertes Kragsystem für einen Mehrmassenschwinger in ausgelenkter Lage. Es gilt die Annahme für kleine Winkel \\(\\tan(\\phi) = \\phi\\).\n\n\n\nAbbildung 18.8: Mehrmassenschwinger erweitert mit einer Fundamentverdrehung und Schubsteifigkeit\n\n\nDie Eigenform wird mit einer linearen Formfunktion \\(\\Psi(x)\\) angenähert.\n\n\nPsi_x = (u_0 / H * x)\nPsi_x_diff_2 = sp.Derivative(Psi_x, x,x).doit()\n\nrender.eq_display('Psi(x)', Psi_x,\n                  'Derivative(Psi(x),x,x)', Psi_x_diff_2,\n                 'Psi(0)', Psi_x.subs(x,0),\n                 'Psi(H)', Psi_x.subs(x,H))\n\n\\[\\begin{equation}\\Psi{\\left(x \\right)} = \\frac{u_{0} x}{H}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\frac{d^{2}}{d x^{2}} \\Psi{\\left(x \\right)} = 0\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi{\\left(0 \\right)} = 0\\end{equation}\\]\n\n\n\\[\\begin{equation}\\Psi{\\left(H \\right)} = u_{0}\\end{equation}\\]\n\n\n\n18.2.5.1 Rayleigh-Quotient\nDer Rayleigh-Quotient lässt sich in Analogie des Vorgehens in Gleichung 18.1 folgendermassen beschreiben:\n\\[\n\\omega_1^2 = \\frac{F\\cdot u_0}{\\sum_{i=1}^n m_i [\\Psi_i(x)]^2}\n\\tag{18.13}\\]\nDie Verformung \\(u_0\\) setzt aus einer Reihenschaltung von Federn zusammen und bezeichnet die Nachgiebigkeit. Diese Nachgiebigkeiten setzen sich aus der Beige- und Schubverformung des Stabes und der Fundamntdrehung infolge dem Einspannmoment \\(M = 1 \\cdot H\\) zusammen.\n\\[\nu_0 = \\frac{H^3}{3 \\cdot EI} + \\frac{H}{G\\cdot A_s} + \\frac{H^2}{k_\\phi}\n\\tag{18.14}\\]\n\n18.2.5.1.1 Schubverformung\nDie Gleichung 18.14 wird folgend hergeleitet:\n\\[\n\\gamma = \\frac{\\tau}{G} = \\frac{\\frac{V}{A_s}}{G} =  \\frac{u_G}{H}\n\\tag{18.15}\\]\n\\(\\gamma = \\text{Schubwinkel}\\) Der Schubwinkel ist bei der Schubspannung gleichbedeutend wie die Dehnung \\(\\varepsilon\\) bei der Normalspannung.\n\\(\\tau = \\frac{V}{A_s}\\) Die Schubspannung definiert sich aus der Querkraft über die Querschnittsfläche. Als Annahme gilt eine konstante Schubspannungsverteilung über die Wandlänge.\n\\(G = \\text{Schubmodul}\\) Das Schubmodul ist das Elastizitätsmodul bei den Schubspannungen.\n\\(u_G = \\text{Anteil an Gesamtverformung}\\)\nGleichung Gleichung 18.15 lässt sich nach \\(u_G\\) umformen für \\(V = 1\\):\n\\[\nu_G = \\frac{H}{G\\cdot A_s}\n\\tag{18.16}\\]\nZur Beziehung, es lässt sich ein Dreieck aus \\(u_G\\) und \\(H\\) bilden, der Winkel am Fusspunkt entspricht dem Schubwinkel.\n\\[\n\\gamma = \\frac{u_G}{H}\n\\tag{18.17}\\]\n\n\n18.2.5.1.2 Fundamentverdrehung\nInfolge elastischer Lagerung resultiert die Fundamentverdrehung:\n\\[\nk_{\\varphi} = \\frac{M}{\\varphi}\n\\tag{18.18}\\]\nDas Biegemoment resultiert aus \\(F=1\\) mit entsprechendem Hebelarm. Die Verdrehung folgt aus der Kopfverschiebung verteilt an die Systemhöhe. Gleiche Winkelbetrachtung wie bei dem Schubwinkel. Mit \\(M = 1 \\cdot H\\) und \\(\\varphi = \\frac{u_{\\varphi}}{H}\\)\n\\[\nu_{\\varphi} = \\frac{H^2}{k_{\\varphi}}\n\\tag{18.19}\\]\n\\(u_{\\varphi} = \\text{Anteil an Gesamtverformung}\\)\n\n\n18.2.5.1.3 Biegeverformung\nFür die Biegeverformung gilt folgendes: \\[\nu_B = \\frac{F}{k}\n\\tag{18.20}\\]\nDie Steifigkeit für den eingespannten Kragarm: \\[\nk = \\frac{3 \\cdot EI }{H^3}\n\\tag{18.21}\\]\n\n\n\n18.2.5.2 Nachgiebigkeiten\nWir wissen nun, welchen Einfluss die Fundamentverdrehung, sowie die Schubverformung auf den Rayleigh-Quotienten hat. Nun gilt es die Federsteifigkeit zu definieren.\n\n18.2.5.2.1 Schubverformung\nDabei gilt, die Schubsteifigkeit wird um den gleichen Faktor wie die Biegesteifigkeit abgemindert, um das Rissverhalten zu berücksichtigen.\n\nA_s = (L_w3 * d)\nnu_c = 0.2\nG_c = (E / (2*(1-nu_c)))\n\nrender.eq_display('A_s', A_s,\n                  'A_s', A_s.subs(params),\n                  'nu_c', nu_c,\n                  'G_c', '(E_ / (2*(1-nu_c)))',\n                  'G_c', G_c.subs(params))\n\n\\[\\begin{equation}A_{s} = L_{w3} d\\end{equation}\\]\n\n\n\\[\\begin{equation}A_{s} = 1.5 \\text{m}^{2}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\nu_{c} = 0.2\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{c} = \\frac{E_{}}{2 - 2 \\nu_{c}}\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{c} = \\frac{18750.0 \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\nSchubsteifigkeit der Tragwand:\n\nG_cA_2 = G_c*gamma_EI * A_s\nrender.eq_display(\n    'GA_II', 'G_c*gamma_EI * A_s',\n    'GA_II', G_cA_2.subs(params).simplify())\n\n\\[\\begin{equation}GA_{II} = A_{s} G_{c} \\gamma_{EI}\\end{equation}\\]\n\n\n\\[\\begin{equation}GA_{II} = 14062500000.0 \\text{N}\\end{equation}\\]\n\n\nVerformungsanteil durch die Querkraft:\n\nu_g = H / G_cA_2\n\nrender.eq_display('u_g', u_g.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}u_{g} = \\frac{8.53 \\cdot 10^{-10} \\text{m}}{\\text{N}}\\end{equation}\\]\n\n\n\n\n18.2.5.2.2 Fundamentverdrehung\nSowie wird die Fundamentsteifigkeit nach Schweizerischer Ingenieur- und Architektenverein (SIA) (2017) Tabelle 7 ermittelt. Der Baugrund wird als locker gelagerter Sand angenommen. Effektive Werte sind aus geologischen Berichten zu entnehmen. Dabei ist die Baugrundklasse zu berücksichtigen:\nBodenkennwert nach Tabelle 6:\n\nG_eff = G_eff_sand * 0.935\n\nrender.eq_display('G_eff','G_eff_sand * 0.935',\n                  'G_eff', G_eff.subs(params))\n\n\\[\\begin{equation}G_{eff} = 0.935 G_{eff sand}\\end{equation}\\]\n\n\n\\[\\begin{equation}G_{eff} = \\frac{112200000.0 \\text{N}}{\\text{m}^{2}}\\end{equation}\\]\n\n\nDrehfeder Baugrund nach Tabelle 7 und Tabelle 8\n\na = 5 * L_x\nb = 3 * L_y\n\nk_xx = (G_eff * b**3 / (1-nu_sand)) * (0.4 * (a/b)+0.1)\n\n\nrender.eq_display(\n\n    'b', b.subs(params),\n    'a', a.subs(params),\n    'k_xx', 'G_eff * b**3 / (1-nu_sand) * (0.4 * (a/b)+0.1)',\n    'k_xx', k_xx.subs(params).simplify().evalf(3))\n\n\\[\\begin{equation}b = 15 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}a = 20 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{xx} = \\frac{G_{eff} b^{3} \\cdot \\left(\\frac{0.4 a}{b} + 0.1\\right)}{1 - \\nu_{sand}}\\end{equation}\\]\n\n\n\\[\\begin{equation}k_{xx} = 3.43 \\cdot 10^{11} \\text{m} \\text{N}\\end{equation}\\]\n\n\nMultiplikationsfaktor zur Berücksichtigung der Einspannung:\n\n\nh_2 = 4*unit.m + d/2\nh_3 = d\nh_1 = h_2 - (h_3/2)\n\nm_xx = 1 + sp.Rational(2.5)*h_3 / b * (1 + 2*h_3 / b *(h_3/h_2)**(-0.2) * sp.sqrt(b/a))\n\nrender.eq_display(\n    'h_1', h_1.subs(params),\n    'h_2', h_2.subs(params),\n    'h_3', h_3.subs(params),\n    'm_xx','1 + 2.5*h_3 / b * (1 + 2*h_3 / b *(h_3/h_2)**(-0.2) * sqrt(b/a))',\n    \n    'm_xx', m_xx.subs(params).evalf(4))\n\n\\[\\begin{equation}h_{1} = 4 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}h_{2} = 4.15 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}h_{3} = 0.3 \\text{m}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{xx} = 1 + \\frac{2.5 h_{3} \\cdot \\left(1 + \\frac{2 h_{3} \\sqrt{\\frac{b}{a}}}{b \\left(\\frac{h_{3}}{h_{2}}\\right)^{0.2}}\\right)}{b}\\end{equation}\\]\n\n\n\\[\\begin{equation}m_{xx} = 1.053\\end{equation}\\]\n\n\nDrehfeder unter Berücksichtigung der Einspannung:\n\nk_xx = k_xx * m_xx\n\nrender.eq_display('k_xx', k_xx.subs(params).evalf(3))\n\n\\[\\begin{equation}k_{xx} = 3.61 \\cdot 10^{11} \\text{m} \\text{N}\\end{equation}\\]\n\n\nIn Gleichung 18.19 eingesetzt:\n\nu_phi = H**2 / k_xx\n\nrender.eq_display('u_varphi', u_phi.subs(params).evalf(3))\n\n\\[\\begin{equation}u_{\\varphi} = \\frac{3.99 \\cdot 10^{-10} \\text{m}}{\\text{N}}\\end{equation}\\]\n\n\n\n\n18.2.5.2.3 Biegeverformung\n\nk_biege = 3*EI_y_ersatz / H**3\nu_B = 1/k_biege\n\nrender.eq_display('k_biege', k_biege.subs(params).evalf(3),\n                  'u_B', u_B.subs(params).evalf(3).simplify())\n\n\\[\\begin{equation}k_{biege} = \\frac{81.4 \\text{m} \\text{N}}{\\text{mm}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{B} = \\frac{1.23 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\end{equation}\\]\n\n\n\n\n18.2.5.2.4 Totale Deformation\n\nparams[F] = 1\nparams[u_0] = (u_B + u_g + u_phi).subs(params).simplify()\n\nrender.eq_display(\n    \n    'u_0', 'u_B + u_g + u_phi',\n    'u_0', u_0.subs(params).evalf(3).simplify())\n\n\\[\\begin{equation}u_{0} = u_{B} + u_{g} + u_{\\phi}\\end{equation}\\]\n\n\n\\[\\begin{equation}u_{0} = \\frac{1.35 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\end{equation}\\]\n\n\nEingesetzt in Gleichung 18.13:\n\nomega_1_squared = F*u_0 / (m_1 * Psi_x.subs(x, H_1)**2 + m_2 * Psi_x.subs(x, H_2+H_1)**2 +m_3 * Psi_x.subs(x, H_3+H_2+H_1)**2)\n\nomega_1 = sp.sqrt(omega_1_squared)\n\nrender.eq_display(\n    'omega_1^2', omega_1_squared.subs(params).evalf(3).simplify(),\n    'omega_1', omega_1.subs(params).evalf(3).simplify()\n)\n\n\\[\\begin{equation}\\omega_{1}^{2} = \\frac{154.0}{\\text{s}^{2}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\omega_{1} = \\frac{12.4}{\\text{s}}\\end{equation}\\]\n\n\n\n\nf_1 = omega_1 / 2 / sp.pi\nT_1 = 1 / f_1\n\n\nrender.eq_display(\n    'f_1', f_1.subs(params).simplify().evalf(3),\n    'T_1', T_1.subs(params).simplify().evalf(3)\n)\n\n\\[\\begin{equation}f_{1} = \\frac{1.97}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{1} = 0.506 \\text{s}\\end{equation}\\]\n\n\n\n\n\n18.2.5.3 Bemessungsspektrum\n\na_gd = 1.0*unit.m /unit.second**2\n\n\nS_d_y = bemessungsspektrum(a_gd, T_1.subs(params).simplify().evalf(3), params['q'], params['gamma_f'], Baugrundklasse='B')\n\nrender.eq_display('S_d_y', S_d_y.evalf(3))\n\n\n\n\n\n\n\n\n\\(S = 1.2\\)\n\\(T_{B} = 0.08 \\text{s}\\)\n\n\n\\(T_{C} = 0.35 \\text{s}\\)\n\\(T_{D} = 2.0 \\text{s}\\)\n\n\n\\(a_{gd} = \\frac{1.0 \\text{m}}{\\text{s}^{2}}\\)\n\\(g = \\frac{10.0 \\text{m}}{\\text{s}^{2}}\\)\n\n\n\\(\\gamma_{f} = 1.0\\)\n\\(q = 2.0\\)\n\n\n\n\n\n\\[\\begin{equation}S_{d} = \\frac{2.5 S_{} T_{C} a_{gd} \\gamma_{f}}{T g q}\\end{equation}\\]\n\n\n\\[\\begin{equation}S_{d y} = 0.104\\end{equation}\\]\n\n\n\n\n18.2.5.4 Gesamt-Ersatzkraft\nDas Vorgehen ist analog Gleichung 18.6 und Folgenden.\n\nF_d_y_nach = np.sum(np.array([m_1, m_2, m_3])*g*S_d_y)\nRed = (1-(F_d_y / F_d_y_nach).subs(params).evalf(3))*100*unit.percent\n\nrender.eq_display('F_d_y_nach', F_d_y_nach.subs(params).evalf(3),\n                 'Reduktion', Red)\n\n\\[\\begin{equation}F_{d y nach} = 9.78 \\cdot 10^{5} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}Reduktion = - 15.4 \\%\\end{equation}\\]\n\n\nIm Vergleich mit der Lösung ohne Nachgiebigkeit verringert sich die Gesamt-Ersatzkraft um ca. 15 % und folglich die Schnittgrössen ebenfalls. Wenn die Eigenperiode im abfallenden Ast des Spektrums zu liegen kommt, ist die Berücksichtigung der Nachgiebigkeiten eine wirtschaftliche Lösung.\n\nH_masse_i = np.array([(H_1) * m_1,(H_1+H_2) * m_2,(H_1+H_2+H_3) * m_3])\n\nF_y_i = H_masse_i / np.sum(H_masse_i) * F_d_y_nach\n\n\nF_y_i_dict = {f'F_y{i+1}': F_y_i[i].subs(params).evalf(3) for i in range(len(F_y_i))}\nrender.dict_to_table(F_y_i_dict)\n\n\n\n\n\n\n\n\n\\(F_{y1} = 1.68 \\cdot 10^{5} \\text{N}\\)\n\\(F_{y2} = 3.36 \\cdot 10^{5} \\text{N}\\)\n\n\n\\(F_{y3} = 4.74 \\cdot 10^{5} \\text{N}\\)\n\n\n\n\n\n\n\n\n18.2.5.5 Schnittgrössen\n\nparams_plot = convert.param_value(params)\n# Querkraft\n\nF_y_i = list(F_y_i_dict.values())[::-1]\nV_max = [F_y_i[0], F_y_i[0]+F_y_i[1],F_y_i[0]+F_y_i[1]+F_y_i[2]][::-1]\nV_x = sp.Piecewise((-np.sum(V_max).subs(params)/unit.N, ((x&lt;0)&(x&gt;=-H_1.subs(params_plot)))),(V_max[0].subs(params)/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))), (V_max[1].subs(params)/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))), (V_max[2].subs(params)/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n# Biegemoment\nM_x = sp.integrate(-V_x, x) + C_1\nC_1_solve = sp.solve(M_x.subs(x, (H_1+H_2+H_3).subs(params_plot)), C_1)[0]\nM_x = M_x.subs(C_1, C_1_solve)\n\n# Normalkraft\ng = 10*unit.m/unit.second**2\nN_x = sp.Piecewise(((m_1+m_2+m_3*2).subs(params)*g/unit.N, ((x&lt;0)&(x&gt;=-H_1.subs(params_plot)))),((m_1+m_2+m_3).subs(params)*g/unit.N, ((x&gt;0)&(x&lt;=H_1.subs(params_plot)))),((m_3+m_2).subs(params)*g/unit.N, ((x&gt;=H_1.subs(params_plot))&(x&lt;=(H_1+H_2).subs(params_plot)))),((m_3).subs(params)*g/unit.N, ((x&gt;=(H_1+H_2).subs(params_plot))&(x&lt;=(H_1+H_2+H_3).subs(params_plot)))), (0,True))\n\n\n\n# Numerische Daten generieren\nx_array = np.linspace(float((-H_1-.01).subs(params_plot)), float((H_1+H_2+H_3+.01).subs(params_plot)), 1000)\nV_x_lamb = sp.lambdify(x, V_x)\nV_x_array = V_x_lamb(x_array)\n\nM_x_lamb = sp.lambdify(x,M_x)\nM_x_array = M_x_lamb(x_array)\n\nN_x_lamb = sp.lambdify(x,N_x)\nN_x_array = N_x_lamb(x_array)\n\n# Figure und Axes erstellen\nfig, (ax1, ax2, ax3) = plt.subplots(1, 3)\n\n# Ersten Plot erstellen\n\nax1.plot(V_x_array/1000, x_array)\nax1.set_title('$V(x)$')\n\n## Horizontale Linien\nax1.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax1.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax1.set_xlabel('$[kN]$')\nax1.set_ylabel('$[m]$')\n\nax1.axvline(0,linestyle='dashed', color='black')\n\n\n# Zweiten Plot erstellen\n\nax2.plot(M_x_array/1000, x_array, color='orange')\nax2.set_title('$M(x)$')\n\n## Horizontale Linien\nax2.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax2.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\nax2.set_xlabel('$[kNm]$')\n\nax2.axvline(0,linestyle='dashed', color='black')\n\n\n# Dritten Plot erstellen\n\nax3.plot(N_x_array/1000, x_array, color='green')\nax3.set_title('$N(x)$')\nax3.set_xlabel('$[kN]$')\n\n\n## Horizontale Linien\nax3.axhline(H_1.subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\nax3.axhline((H_1+H_2).subs(params_plot),linestyle='dashed', color='gray',linewidth=1)\n\n\nax3.axvline(0,linestyle='dashed', color='black')\n\n\n\n# Plots anzeigen\nplt.show()\n\n\n\n\nAbbildung 18.9: Maximale Schnittgrössen erweitert in das UG unter Berücksichtigung der Nachgiebigkeiten\n\n\n\n\n\nR_A_nach = -V_x.subs(x,-3)*unit.N\nR_B_nach = (V_x.subs(x,-3) - V_x.subs(x,1)) * unit.N\n\nrender.eq_display('R_A', R_A_nach,\n                  'R_B', R_B_nach)\n\n\\[\\begin{equation}R_{A} = 2.26 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\\[\\begin{equation}R_{B} = - 3.24 \\cdot 10^{6} \\text{N}\\end{equation}\\]\n\n\n\n\n\n18.2.6 Reduktion der Wandlänge\nNeben der Berücksichtigung der Nachgiebigkeit seitens Fundation und Schubverformungen, hat die Wandlänge einen wesentlichen Einfluss auf Ersatzkräfte. Die Tabelle 18.2 zeigt den Einfluss der Wandlänge \\(L_{w3}\\) auf die Erdbebenersatzkräfte. Als obere Grenze gilt die Bedingung aus Schweizerischer Ingenieur- und Architektenverein (SIA) (2020) Ziff. 16.5.2.1, die Grundschwingzeit darf \\(4\\cdot T_c\\) nicht überschreiten.\n\n\nTabelle 18.2: Einfluss der Wandlänge auf die Ersatzkräfte und Grundschwingzeit\n\n\n\n\n\n\n\n\n\n\\(5\\) m\n\\(4\\) m\n\\(3\\) m\n\n\n\n\n\\(F_d\\)\n\\(1128.4\\) kN\n\\(803.50\\) kN\n\\(519.28\\) kN\n\n\n\\(F_{3d}\\)\n\\(546.50\\) kN\n\\(390.06\\) kN\n\\(252.66\\) kN\n\n\n\\(F_{2d}\\)\n\\(387.88\\) kN\n\\(275.63\\) kN\n\\(177.75\\) kN\n\n\n\\(F_{1d}\\)\n\\(193.94\\) kN\n\\(137.81\\) kN\n\\(88.875\\) kN\n\n\n\\(T_1\\)\n\\(0.439\\) s\n\\(0.612\\) s\n\\(0.939\\) s\n\n\n\n\n\nT_C = 0.35*unit.second\n\nT_1_max = 4 * T_C\n\nrender.eq_display(\n    'T_1_max', '4*T_C',\n    'T_1_max', T_1_max)\n\n\\[\\begin{equation}T_{1 max} = 4 T_{C}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{1 max} = 1.4 \\text{s}\\end{equation}\\]\n\n\n\n\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2017). Norm SIA 269/8:2017 Erhaltung von Tragwerken – Erdbeben (136. S.).\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2020). Norm SIA 261:2020 Einwirkungen auf Tragwerke  (136. S.)."
  },
  {
    "objectID": "ekv_03.html#aufgabenstellung",
    "href": "ekv_03.html#aufgabenstellung",
    "title": "19  Beispiel: Rayleigh-Quotient an einem Sechsmassenschwinger beim Ersatzkraftverfahren",
    "section": "19.1 Aufgabenstellung",
    "text": "19.1 Aufgabenstellung\nDas Beispiel ist aus Dupraz und Schweizerischer Ingenieur-und Architekten-Verein (2004) Seite 77 entnommen. Die Lastermittlung wird übernommen. Es wird vom vereinfachten Modell in Abbildung 19.1 ausgegangen. Der Fokus liegt auf der Bestimmung der Grundfrequenz.\n\n\n\nAbbildung 19.1: Vereinfachtes Modell für einen Mehrmassenschwinger\n\n\nGesucht:\n\nErstelle die Nachgiebigkeitsmatrix (Verwende das Bildungsgesetz)\nGrundschwingzeit\n\nGegeben:\n\nH_i, m_i,  I, I_x, I_y, f= sp.symbols('H_i, m_i  I  I_x I_y f')\nn = 6 # n-Massenschwinger\nF = sp.MatrixSymbol('F', n,1)\nu = sp.MatrixSymbol('u', n,1)\nf_hat = sp.MatrixSymbol('\\hat{f}', n,n)\nM = sp.MatrixSymbol('M', n,1)\n\n\nparams={\n    E: 27*10**9*unit.N/ unit.m**2,\n    H_i: 3.105*unit.m,\n    m_i: 1278*10**3*unit.N*unit.second**2 /unit.m,\n    I_x: 14.89*unit.m**4,\n    I_y: 28.27*unit.m**4,\n}\n\nparams_plot = convert.param_value(params)\n\nrender.dict_to_table(params)\n\n\n\n\n\n\n\n\n\\(E = \\frac{27000000000 \\text{N}}{\\text{m}^{2}}\\)\n\\(H_{i} = 3.105 \\text{m}\\)\n\n\n\\(I_{x} = 14.89 \\text{m}^{4}\\)\n\\(I_{y} = 28.27 \\text{m}^{4}\\)\n\n\n\\(m_{i} = \\frac{1278000 \\text{N} \\text{s}^{2}}{\\text{m}}\\)"
  },
  {
    "objectID": "ekv_03.html#musterlösung",
    "href": "ekv_03.html#musterlösung",
    "title": "19  Beispiel: Rayleigh-Quotient an einem Sechsmassenschwinger beim Ersatzkraftverfahren",
    "section": "19.2 Musterlösung",
    "text": "19.2 Musterlösung\n\n19.2.1 Rayleigh-Quotient\n\nrl_eqs={\n    \n}\n\n\ndef nachgiebigkeitsmatrix_nach_bildungsgesetz(n):\n    \"\"\"\n    Erstellt die Nachgiebigkeitsmatrix nach dem Bildungsgesetz. Dieses ist nur zulässig für gleichmässige Stockwerkshöhen, sowie gleichbleibenden Stockwerkssteifigkeiten.\n    Dies muss abschliessend mit h^3/(6*E*I) mutlipliziert werden.\n    \"\"\"\n    from sympy import symbols, zeros\n\n    \n    def bildungsgesetz(i,j):\n        return j**2*(3*i-j)\n\n    matrix = sp.zeros(n, n)\n    matrix_symbols =sp.zeros(n,n)\n    matrix_unsymm = sp.zeros(n, n)\n    \n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            if i &gt;=j:\n                matrix[i-1,j-1] = bildungsgesetz(i,j)\n                matrix_symbols[i-1,j-1] = sp.Symbol(f'f_{i,j}')\n                matrix_unsymm[i-1,j-1] = bildungsgesetz(i,j)\n\n            if j&gt;i:\n                matrix[i-1, j-1] = bildungsgesetz(j,i)\n                matrix_symbols[i-1,j-1] = sp.Symbol(f'f_{i,j}')\n\n    \n    return matrix, matrix_symbols, matrix_unsymm\n            \n\n\nrl_eqs[f_hat] = sp.UnevaluatedExpr(H_i**3/(6*E*I))*nachgiebigkeitsmatrix_nach_bildungsgesetz(n)[0]\n\nrl_eqs[F] = sp.Matrix(list(range(1, n+1)))\nrl_eqs[u] = f_hat * F\n\n\nrl_eqs[M] = sp.ones(n,1)*m_i\n\n\nrl_eqs[f] = sp.Mul(sp.UnevaluatedExpr(1 / (2*sp.pi)),sp.sqrt(sp.Sum(sp.HadamardProduct(F, u)[i,0], (i, 0, F.shape[0]-1)) / sp.Sum(sp.HadamardProduct(M,u.applyfunc(lambda x:x**2))[i,0],(i,0,M.shape[0]-1))), evaluate=False)\n\nrl_eqs[T] = 1 / f\n\nMittels dem Rayleigh-Quotient für das vereinfachte Modell lässt sich die Grundfrequenz direkt bestimmen.\n\nrender.eq_display(\n    f,rl_eqs[f],\n    F, rl_eqs[F],\n    M, rl_eqs[M],\n    T, rl_eqs[T],\n)\n\n\\[\\begin{equation}f = \\frac{1}{2 \\pi} \\sqrt{\\frac{\\sum_{i=0}^{5} \\mathbf{F}_{i, 0} \\mathbf{u}_{i, 0}}{\\sum_{i=0}^{5} \\mathbf{M}_{i, 0} \\mathbf{u}_{i, 0}^{2}}}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{F} = \\left[\\begin{matrix}1\\\\2\\\\3\\\\4\\\\5\\\\6\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{M} = \\left[\\begin{matrix}m_{i}\\\\m_{i}\\\\m_{i}\\\\m_{i}\\\\m_{i}\\\\m_{i}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}T = \\frac{1}{f}\\end{equation}\\]\n\n\nDabei entspricht \\(\\mathbf{u}\\) dem Verschiebungsvektor infolge des Kraftvektors \\(\\mathbf{F}\\). Der Verschiebungsvektor kann mittels Nachgiebigkeitsmatrix bestimmt werden.\n\n19.2.1.1 Nachgiebigkeitsmatrix\nFür gleichbleibende Geschosshöhen und Geschosssteifigkeiten lässt sich die Nachgiebigkeitsmatrix leicht mittels dem Bildungsgesetz in Gleichung 19.1 ermitteln.\n\\[\n\\hat{f}_{i,j} = \\frac{H^3}{6EI} \\cdot j^2(3i-j) \\text{ für } i\\geq j\n\\tag{19.1}\\]\n\\(\\hat{\\mathbf{f}}\\) entspricht der Nachgiebigkeitsmatrix mit den Einträgen \\(\\hat{f}_{i,j}\\).\nBeachte dabei, dass die Gleichung 19.1 nur für \\(i\\geq j\\) gilt. Die Einträge entsprechen folgendem Schema:\n\ndisplay(nachgiebigkeitsmatrix_nach_bildungsgesetz(n)[1])\n\n\\[\\begin{equation}\\left[\\begin{matrix}f_{(1, 1)} & f_{(1, 2)} & f_{(1, 3)} & f_{(1, 4)} & f_{(1, 5)} & f_{(1, 6)}\\\\f_{(2, 1)} & f_{(2, 2)} & f_{(2, 3)} & f_{(2, 4)} & f_{(2, 5)} & f_{(2, 6)}\\\\f_{(3, 1)} & f_{(3, 2)} & f_{(3, 3)} & f_{(3, 4)} & f_{(3, 5)} & f_{(3, 6)}\\\\f_{(4, 1)} & f_{(4, 2)} & f_{(4, 3)} & f_{(4, 4)} & f_{(4, 5)} & f_{(4, 6)}\\\\f_{(5, 1)} & f_{(5, 2)} & f_{(5, 3)} & f_{(5, 4)} & f_{(5, 5)} & f_{(5, 6)}\\\\f_{(6, 1)} & f_{(6, 2)} & f_{(6, 3)} & f_{(6, 4)} & f_{(6, 5)} & f_{(6, 6)}\\end{matrix}\\right]\\end{equation}\\]\n\n\nUnter strikter Anwendung von Gleichung 19.1 folgt daraus:\n\ndisplay(nachgiebigkeitsmatrix_nach_bildungsgesetz(n)[2])\n\n\\[\\begin{equation}\\left[\\begin{matrix}2 & 0 & 0 & 0 & 0 & 0\\\\5 & 16 & 0 & 0 & 0 & 0\\\\8 & 28 & 54 & 0 & 0 & 0\\\\11 & 40 & 81 & 128 & 0 & 0\\\\14 & 52 & 108 & 176 & 250 & 0\\\\17 & 64 & 135 & 224 & 325 & 432\\end{matrix}\\right]\\end{equation}\\]\n\n\nAufgrund von Symmetrie kann diese abschliessend über die Diagonale gespiegelt werden:\n\nrender.eq_display(f_hat/sp.UnevaluatedExpr(H_i**3 /(6*E*I)), nachgiebigkeitsmatrix_nach_bildungsgesetz(n)[0])\n\n\\[\\begin{equation}\\frac{6 E I}{H_{i}^{3}} \\mathbf{\\hat{f}} = \\left[\\begin{matrix}2 & 5 & 8 & 11 & 14 & 17\\\\5 & 16 & 28 & 40 & 52 & 64\\\\8 & 28 & 54 & 81 & 108 & 135\\\\11 & 40 & 81 & 128 & 176 & 224\\\\14 & 52 & 108 & 176 & 250 & 325\\\\17 & 64 & 135 & 224 & 325 & 432\\end{matrix}\\right]\\end{equation}\\]\n\n\nDurch Multiplikation der Nachgiebigkeit mit der Einwirkung resultiert die Deformation.\n\nrender.eq_display(u, rl_eqs[u],\n                 u, calcs.subs_recursive(u, rl_eqs),\n                 u, calcs.subs_recursive(u, rl_eqs).doit())\n\n\\[\\begin{equation}\\mathbf{u} = \\mathbf{\\hat{f}} \\mathbf{F}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{u} = \\left[\\begin{matrix}2 \\frac{H_{i}^{3}}{6 E I} & 5 \\frac{H_{i}^{3}}{6 E I} & 8 \\frac{H_{i}^{3}}{6 E I} & 11 \\frac{H_{i}^{3}}{6 E I} & 14 \\frac{H_{i}^{3}}{6 E I} & 17 \\frac{H_{i}^{3}}{6 E I}\\\\5 \\frac{H_{i}^{3}}{6 E I} & 16 \\frac{H_{i}^{3}}{6 E I} & 28 \\frac{H_{i}^{3}}{6 E I} & 40 \\frac{H_{i}^{3}}{6 E I} & 52 \\frac{H_{i}^{3}}{6 E I} & 64 \\frac{H_{i}^{3}}{6 E I}\\\\8 \\frac{H_{i}^{3}}{6 E I} & 28 \\frac{H_{i}^{3}}{6 E I} & 54 \\frac{H_{i}^{3}}{6 E I} & 81 \\frac{H_{i}^{3}}{6 E I} & 108 \\frac{H_{i}^{3}}{6 E I} & 135 \\frac{H_{i}^{3}}{6 E I}\\\\11 \\frac{H_{i}^{3}}{6 E I} & 40 \\frac{H_{i}^{3}}{6 E I} & 81 \\frac{H_{i}^{3}}{6 E I} & 128 \\frac{H_{i}^{3}}{6 E I} & 176 \\frac{H_{i}^{3}}{6 E I} & 224 \\frac{H_{i}^{3}}{6 E I}\\\\14 \\frac{H_{i}^{3}}{6 E I} & 52 \\frac{H_{i}^{3}}{6 E I} & 108 \\frac{H_{i}^{3}}{6 E I} & 176 \\frac{H_{i}^{3}}{6 E I} & 250 \\frac{H_{i}^{3}}{6 E I} & 325 \\frac{H_{i}^{3}}{6 E I}\\\\17 \\frac{H_{i}^{3}}{6 E I} & 64 \\frac{H_{i}^{3}}{6 E I} & 135 \\frac{H_{i}^{3}}{6 E I} & 224 \\frac{H_{i}^{3}}{6 E I} & 325 \\frac{H_{i}^{3}}{6 E I} & 432 \\frac{H_{i}^{3}}{6 E I}\\end{matrix}\\right] \\left[\\begin{matrix}1\\\\2\\\\3\\\\4\\\\5\\\\6\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{u} = \\left[\\begin{matrix}\\frac{42 H_{i}^{3}}{E I}\\\\\\frac{925 H_{i}^{3}}{6 E I}\\\\\\frac{950 H_{i}^{3}}{3 E I}\\\\\\frac{1535 H_{i}^{3}}{3 E I}\\\\\\frac{2173 H_{i}^{3}}{3 E I}\\\\\\frac{5663 H_{i}^{3}}{6 E I}\\end{matrix}\\right]\\end{equation}\\]\n\n\nDurch Einsetzen der bestimmten Verformung in die Gleichung der Eigenfrequenz folgt:\n\nrender.eq_display(f, calcs.subs_recursive(f, rl_eqs).doit(),\n                 T, calcs.subs_recursive(T, rl_eqs).doit())\n\n\\[\\begin{equation}f = \\frac{\\sqrt{43665341610} \\sqrt{\\frac{E I}{H_{i}^{3} m_{i}}}}{4993178 \\pi}\\end{equation}\\]\n\n\n\\[\\begin{equation}T = \\frac{\\sqrt{43665341610} \\pi}{8745 \\sqrt{\\frac{E I}{H_{i}^{3} m_{i}}}}\\end{equation}\\]\n\n\n\n\n\n19.2.2 Grundschwingzeit\n\n19.2.2.1 X-Richtung\nEs gilt \\(I\\) mit \\(I_y\\) zu substituieren.\n\nu_j_x = calcs.subs_recursive(u, rl_eqs).doit().subs(I, I_y)\nf_x = calcs.subs_recursive(f, rl_eqs).doit().subs(I, I_y)\nT_x = calcs.subs_recursive(T, rl_eqs).doit().subs(I,I_y)\nrender.eq_display(I_y, I_y.subs(params),\n                  sp.MatrixSymbol('\\mathbf{u_x}', n,1), u_j_x.evalf(3),\n                  sp.MatrixSymbol('\\mathbf{u_x}', n,1), u_j_x.subs(params).evalf(3),\n                 )\n\n\\[\\begin{equation}I_{y} = 28.27 \\text{m}^{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\mathbf{u_x}} = \\left[\\begin{matrix}\\frac{42.0 H_{i}^{3}}{E I_{y}}\\\\\\frac{154.0 H_{i}^{3}}{E I_{y}}\\\\\\frac{317.0 H_{i}^{3}}{E I_{y}}\\\\\\frac{512.0 H_{i}^{3}}{E I_{y}}\\\\\\frac{724.0 H_{i}^{3}}{E I_{y}}\\\\\\frac{944.0 H_{i}^{3}}{E I_{y}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\mathbf{u_x}} = \\left[\\begin{matrix}\\frac{1.65 \\cdot 10^{-9} \\text{m}}{\\text{N}}\\\\\\frac{6.05 \\cdot 10^{-9} \\text{m}}{\\text{N}}\\\\\\frac{1.24 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{2.01 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{2.84 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{3.7 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\end{matrix}\\right]\\end{equation}\\]\n\n\nUnd für die Grundfrequenz:\n\nrender.eq_display('f_x', f_x.subs(params).evalf(3),\n                 'T_x', T_x.subs(params).evalf(3))\n\n\\[\\begin{equation}f_{x} = \\frac{1.88}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{x} = 0.531 \\text{s}\\end{equation}\\]\n\n\n\n\n19.2.2.2 Y-Richtung\nEs gilt \\(I\\) mit \\(I_x\\) zu substituieren.\n\nu_j_y = calcs.subs_recursive(u, rl_eqs).doit().subs(I, I_x)\nf_y = calcs.subs_recursive(f, rl_eqs).doit().subs(I, I_x)\nT_y = calcs.subs_recursive(T, rl_eqs).doit().subs(I,I_x)\nrender.eq_display(I_x, I_x.subs(params),\n                  sp.MatrixSymbol('\\mathbf{u_y}', n,1), u_j_y.evalf(3),\n                  sp.MatrixSymbol('\\mathbf{u_y}', n,1), u_j_y.subs(params).evalf(3),\n                 )\n\n\\[\\begin{equation}I_{x} = 14.89 \\text{m}^{4}\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\mathbf{u_y}} = \\left[\\begin{matrix}\\frac{42.0 H_{i}^{3}}{E I_{x}}\\\\\\frac{154.0 H_{i}^{3}}{E I_{x}}\\\\\\frac{317.0 H_{i}^{3}}{E I_{x}}\\\\\\frac{512.0 H_{i}^{3}}{E I_{x}}\\\\\\frac{724.0 H_{i}^{3}}{E I_{x}}\\\\\\frac{944.0 H_{i}^{3}}{E I_{x}}\\end{matrix}\\right]\\end{equation}\\]\n\n\n\\[\\begin{equation}\\mathbf{\\mathbf{u_y}} = \\left[\\begin{matrix}\\frac{3.13 \\cdot 10^{-9} \\text{m}}{\\text{N}}\\\\\\frac{1.15 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{2.36 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{3.81 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{5.39 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\\\\\frac{7.03 \\cdot 10^{-8} \\text{m}}{\\text{N}}\\end{matrix}\\right]\\end{equation}\\]\n\n\nUnd für die Grundfrequenz:\n\nrender.eq_display('f_y', f_y.subs(params).evalf(3),\n                 'T_y', T_y.subs(params).evalf(3))\n\n\\[\\begin{equation}f_{y} = \\frac{1.37}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{y} = 0.732 \\text{s}\\end{equation}\\]\n\n\n\n\n\n19.2.3 Abminderung der Steifigkeit\nUm die Rissbildung zu berücksichtigen, wird die Steifigkeit auf 30 % abgemindert.\n\n19.2.3.1 X-Richtung\n\nf_x_red = f_x.subs(E,0.3*E)\nT_x_red = T_x.subs(E,0.3*E)\n\nrender.eq_display('f_xred', f_x_red.subs(params).evalf(3),\n                 'T_x_red', T_x_red.subs(params).evalf(3))\n\n\\[\\begin{equation}f_{xred} = \\frac{1.03}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{x red} = 0.97 \\text{s}\\end{equation}\\]\n\n\n\n\n19.2.3.2 Y-Richtung\n\nf_y_red = f_y.subs(E,0.3*E)\nT_y_red = T_y.subs(E,0.3*E)\nrender.eq_display('f_yred', f_y_red.subs(params).evalf(3),\n                 'T_y_red', T_y_red.subs(params).evalf(3))\n\n\\[\\begin{equation}f_{yred} = \\frac{0.748}{\\text{s}}\\end{equation}\\]\n\n\n\\[\\begin{equation}T_{y red} = 1.34 \\text{s}\\end{equation}\\]\n\n\n\n\n\n\nDupraz, P.-André. und Schweizerischer Ingenieur-und Architekten-Verein. (2004). Grundlagen der Projektierung von Tragwerken, Einwirkungen auf Tragwerke : Bemessungsbeispiele zu den Normen SIA 260 und 261. SIA, Schweizerischer Ingenieur- und Architektenverein Zürich."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literatur",
    "section": "",
    "text": "Dupraz, P.-André. and Schweizerischer Ingenieur-und Architekten-Verein.\n(2004). Grundlagen der projektierung von tragwerken, einwirkungen\nauf tragwerke : Bemessungsbeispiele zu den normen SIA 260 und 261.\nSIA, Schweizerischer Ingenieur- und Architektenverein Zürich.\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2017).\nNorm SIA 269/8:2017 Erhaltung von Tragwerken –\nErdbeben (136. p.).\n\n\nSchweizerischer Ingenieur- und Architektenverein (SIA). (2020).\nNorm SIA 261:2020 Einwirkungen auf Tragwerke\n (136. p.)."
  }
]